<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,400italic|Source+Code+Pro:400,700" type="text/css">
  <script src="https://kit.fontawesome.com/fbb4c3a0bc.js" crossorigin="anonymous"></script>
  <script defer data-domain="stjs.tech" src="https://plausible.io/js/plausible.js"></script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" } }
  })
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <title>Software Tools in JavaScript</title>
  <link href="/static/local.css" rel="stylesheet" type="text/css">
  <script src="/static/local.js"></script>
  <script>
  const ENTRIES = {"introduction": { title: "Introduction", label: "Chapter 1" },"systems-programming": { title: "Systems Programming", label: "Chapter 2" },"async-programming": { title: "Asynchronous Programming", label: "Chapter 3" },"unit-test": { title: "Unit Testing", label: "Chapter 4" },"file-backup": { title: "File Backup", label: "Chapter 5" },"data-table": { title: "Data Tables", label: "Chapter 6" },"pattern-matching": { title: "Pattern Matching", label: "Chapter 7" },"regex-parser": { title: "Parsing Expressions", label: "Chapter 8" },"page-templates": { title: "Page Templates", label: "Chapter 9" },"build-manager": { title: "Build Manager", label: "Chapter 10" },"layout-engine": { title: "Layout Engine", label: "Chapter 11" },"file-interpolator": { title: "File Interpolator", label: "Chapter 12" },"module-loader": { title: "Module Loader", label: "Chapter 13" },"style-checker": { title: "Style Checker", label: "Chapter 14" },"code-generator": { title: "Code Generator", label: "Chapter 15" },"doc-generator": { title: "Documentation Generator", label: "Chapter 16" },"module-bundler": { title: "Module Bundler", label: "Chapter 17" },"package-manager": { title: "Package Manager", label: "Chapter 18" },"virtual-machine": { title: "Virtual Machine", label: "Chapter 19" },"debugger": { title: "Debugger", label: "Chapter 20" },"conclusion": { title: "Conclusion", label: "Chapter 21" },"license": { title: "Licensing", label: "Appendix A" },"bibliography": { title: "Bibliography", label: "Appendix B" },"conduct": { title: "Code of Conduct", label: "Appendix C" },"contributing": { title: "Contributing", label: "Appendix D" },"glossary": { title: "Glossary", label: "Appendix E" },"links": { title: "Links", label: "Appendix F" },"authors": { title: "Authors", label: "Appendix G" },"index": { title: "Index", label: "Appendix H" }}
  const FIGURES = {"async-programming-chained": "3.4","async-programming-event-loop": "3.1","async-programming-handling-errors": "3.6","async-programming-resolve": "3.3","async-programming-set-timeout": "3.2","async-programming-temporary-named-fields": "3.5","build-manager-compiling": "10.1","build-manager-dependencies": "10.2","build-manager-pattern-rules": "10.4","build-manager-template-method": "10.3","code-generator-spread": "15.1","data-table-col-ops": "6.4","data-table-conceptual": "6.1","data-table-object-storage": "6.5","data-table-packed-storage": "6.6","data-table-row-ops": "6.3","data-table-storage-order": "6.2","debugger-initialization": "20.1","debugger-test-interact": "20.2","doc-generator-comments": "16.1","doc-generator-fill-in-headers": "16.4","doc-generator-mapping": "16.3","doc-generator-process-plain": "16.2","file-backup-hash-function": "5.1","file-backup-mock-fs": "5.4","file-backup-storage": "5.3","file-backup-streaming": "5.2","file-interpolator-cache": "12.3","file-interpolator-conceptual": "12.1","file-interpolator-eval": "12.2","file-interpolator-search-path": "12.4","layout-engine-coordinate-system": "11.1","layout-engine-draw-over": "11.4","layout-engine-layout": "11.3","layout-engine-sizing": "11.2","layout-engine-wrap": "11.5","module-bundler-bundling": "17.1","module-bundler-complicated": "17.2","module-bundler-head-tail": "17.5","module-bundler-returning-functions": "17.6","module-bundler-structure": "17.4","module-bundler-transitive-closure": "17.3","module-loader-circularity": "13.3","module-loader-closures": "13.1","module-loader-iife": "13.2","package-manager-allowable": "18.1","package-manager-pruning": "18.2","page-templates-comprehension": "9.10","page-templates-options": "9.1","page-templates-output-conditional": "9.8","page-templates-output-loop": "9.9","page-templates-output-multiple-variables": "9.7","page-templates-output-single-constant": "9.5","page-templates-output-single-variable": "9.6","page-templates-output-static-text": "9.4","page-templates-stack": "9.2","page-templates-visitor": "9.3","pattern-matching-dom-tree": "7.1","pattern-matching-greedy-failure": "7.4","pattern-matching-query-selectors": "7.2","pattern-matching-regex-objects": "7.3","pattern-matching-rest": "7.5","regex-parser-expression-tree": "8.1","regex-parser-finite-state-machine": "8.3","regex-parser-mechanics": "8.2","style-checker-iterator": "14.3","style-checker-parse-tree": "14.1","style-checker-walk-tree": "14.2","systems-programming-anonymous-functions": "2.4","systems-programming-array-filter": "2.6","systems-programming-callbacks": "2.2","systems-programming-destructuring-assignment": "2.7","systems-programming-execution-order": "2.3","systems-programming-globbing": "2.5","systems-programming-process-argv": "2.1","systems-programming-triple-callback": "2.8","unit-test-hope-structure": "4.2","unit-test-lifecycle": "4.3","unit-test-mental-model": "4.1","virtual-machine-architecture": "19.1","virtual-machine-count-up": "19.3","virtual-machine-storage-allocation": "19.5","virtual-machine-trace-counter": "19.4","virtual-machine-unpacking": "19.2"}
  const TABLES = {"data-table-performance": "6.1","package-manager-example-dependencies": "18.1","package-manager-example-result": "18.2","package-manager-exclusions": "18.3","pattern-matching-cases": "7.2","pattern-matching-supported": "7.1","regex-parser-grammar-codes": "8.1","systems-programming-times": "2.1","virtual-machine-op-codes": "19.1"}
</script>

  <script>window.onload = () => fixPage()</script>
</head>

  <body >
    <nav class="nav-main">
  <ul>
    <li><a href="/" aria-label="Home"><em>Software Tools in JavaScript</em></a></li>
    <li><div class="dropdown">
<span class="navtitle">▿ Chapters</span>
<div class="dropdown-content" id="Chapters"><a class="dropdown-item" href="/introduction/"><span class="nowrap">Introduction</span></a><br/><a class="dropdown-item" href="/systems-programming/"><span class="nowrap">Systems Programming</span></a><br/><a class="dropdown-item" href="/async-programming/"><span class="nowrap">Asynchronous Programming</span></a><br/><a class="dropdown-item" href="/unit-test/"><span class="nowrap">Unit Testing</span></a><br/><a class="dropdown-item" href="/file-backup/"><span class="nowrap">File Backup</span></a><br/><a class="dropdown-item" href="/data-table/"><span class="nowrap">Data Tables</span></a><br/><a class="dropdown-item" href="/pattern-matching/"><span class="nowrap">Pattern Matching</span></a><br/><a class="dropdown-item" href="/regex-parser/"><span class="nowrap">Parsing Expressions</span></a><br/><a class="dropdown-item" href="/page-templates/"><span class="nowrap">Page Templates</span></a><br/><a class="dropdown-item" href="/build-manager/"><span class="nowrap">Build Manager</span></a><br/><a class="dropdown-item" href="/layout-engine/"><span class="nowrap">Layout Engine</span></a><br/><a class="dropdown-item" href="/file-interpolator/"><span class="nowrap">File Interpolator</span></a><br/><a class="dropdown-item" href="/module-loader/"><span class="nowrap">Module Loader</span></a><br/><a class="dropdown-item" href="/style-checker/"><span class="nowrap">Style Checker</span></a><br/><a class="dropdown-item" href="/code-generator/"><span class="nowrap">Code Generator</span></a><br/><a class="dropdown-item" href="/doc-generator/"><span class="nowrap">Documentation Generator</span></a><br/><a class="dropdown-item" href="/module-bundler/"><span class="nowrap">Module Bundler</span></a><br/><a class="dropdown-item" href="/package-manager/"><span class="nowrap">Package Manager</span></a><br/><a class="dropdown-item" href="/virtual-machine/"><span class="nowrap">Virtual Machine</span></a><br/><a class="dropdown-item" href="/debugger/"><span class="nowrap">Debugger</span></a><br/><a class="dropdown-item" href="/conclusion/"><span class="nowrap">Conclusion</span></a></div>
</div>
</li>
    <li><div class="dropdown">
<span class="navtitle">▿ Appendices</span>
<div class="dropdown-content" id="Appendices"><a class="dropdown-item" href="/license/"><span class="nowrap">Licensing</span></a><br/><a class="dropdown-item" href="/bibliography/"><span class="nowrap">Bibliography</span></a><br/><a class="dropdown-item" href="/conduct/"><span class="nowrap">Code of Conduct</span></a><br/><a class="dropdown-item" href="/contributing/"><span class="nowrap">Contributing</span></a><br/><a class="dropdown-item" href="/glossary/"><span class="nowrap">Glossary</span></a><br/><a class="dropdown-item" href="/links/"><span class="nowrap">Links</span></a><br/><a class="dropdown-item" href="/authors/"><span class="nowrap">Authors</span></a><br/><a class="dropdown-item" href="/index/"><span class="nowrap">Index</span></a></div>
</div>
</li>
  </ul>
</nav>

    <div class="container content">
      
<header>
  <h1 class="page-title" slug="data-table">Data Tables</h1>
  <h2 class="lede">Storing and manipulating tables efficiently</h2>
</header>


      <main>
        <ul class="toc"></ul>
        <div class="terms"><p><strong>Terms defined:</strong> <span g="json">JavaScript Object Notation</span>, <span g="sql">SQL</span>, <span g="column_major">column-major storage</span>, <span g="data_frame">data frame</span>, <span g="garbage_collection">garbage collection</span>, <span g="heterogeneous">heterogeneous</span>, <span g="homogeneous">homogeneous</span>, <span g="immutable">immutable</span>, <span g="row_major">row-major storage</span>, <span g="tagged_data">tagged data</span>, <span g="test_harness">test harness</span></p>
</div>
        <p><span x="systems-programming"></span> said that
operations in memory are thousands of times faster than operations that touch the filesystem,
but what about different in-memory operations—how do they compare with each other?
Putting it another way,
how can we tell which of several designs is going to be the most efficient?</p>

<p>The best answer is to conduct some <span i="experiments">experiments</span>.
To see how to do this,
we will take a look several ways to implement data tables
with one or more named columns and zero or more rows.
Each row has one value for each column,
and all the values in a column have the same type
(<span f="data-table-conceptual"></span>).
Data tables appear over and over again in programming,
from spreadsheets and databases
to the <span g="data_frame" i="data frame">data frames</span> in
<span i="R">R's</span> <span i="tidyverse"><a href="https://www.tidyverse.org/" title="Tidyverse">tidyverse</a></span> packages,
<span i="Python"><a href="https://www.python.org/" title="Python">Python's</a></span> <span i="Pandas"><a href="https://pandas.pydata.org/" title="Pandas">Pandas</a></span> library,
or the <span i="DataForge"><a href="http://www.data-forge-js.com/" title="Data-Forge">DataForge</a></span> library for JavaScript <cite>Davis2018</cite>.</p>

<figure id="data-table-conceptual" slug="data-table">
  <img src="figures/conceptual.svg" alt="Data table structure" />
  <figcaption>The structure of a data table.</figcaption>
</figure>

<p>The key operations on data tables are those provided by <span g="sql" i="SQL">SQL</span>:
filter, select, summarize, and join.
These can be implemented in about five hundred lines of code,
but their performance depends on how the data table is stored.</p>

<h2 id="how-can-we-implement-data-tables">How can we implement data tables?</h2>

<p>One way to store a table is <span g="row_major" i="row-major storage order; storage order!row-major">row-major</span> order,
in which the values in each row are stored together in memory.
This is sometimes also called <span g="heterogeneous" i="heterogeneous storage; storage!heterogeneous">heterogeneous</span> storage
because each "unit" of storage can contain values of different types.
We can implement this design in JavaScript using an array of objects,
each of which has the same keys
(<span f="data-table-storage-order"></span>).</p>

<p>Another option is <span g="column_major" i="column-major storage order; storage order!column-major">column-major</span>
or <span g="homogeneous" i="homogeneous storage; storage!homogeneous">homogeneous</span> order,
in which all the values in a column are stored together.
In JavaScript,
this could be implemented using an object
whose members are all arrays of the same length.</p>

<figure id="data-table-storage-order" slug="data-table">
  <img src="figures/storage-order.svg" alt="Row-major vs. column-major storage order" />
  <figcaption>Row-major storage vs. column-major storage for data tables.</figcaption>
</figure>

<p>To find out which is better
we will construct one of each,
try some operations,
record their execution times and memory use,
and then compare them.
Crucially,
the answer will depend on both the implementations themselves
and on what mix of operations we measure.
For example,
if one strategy works better for filter and another for select,
the ratio of filters to selects may determine which is "best".</p>

<div class="callout">

  <h3 id="immutability">Immutability</h3>

  <p>All of our implementations will treat each data table as <span g="immutable" i="immutable data">immutable</span>:
once we have created it,
we will not modify its contents.
This doesn't actually have much impact on performance
an makes the programming easier and safer,
since shared data structures are a rich source of bugs.</p>

</div>

<p>For our first experiment,
let's build a row-major table with some number of columns.
To keep it simple,
we will repeat the values 0, 1, and 2 to fill the table.</p>

<pre class="language-js" title="build.js"><code class="language-js">
export const buildRows = (nRows, labels) =&gt; {
  const result = []
  for (let iR = 0; iR &lt; nRows; iR += 1) {
    const row = {}
    labels.forEach(label =&gt; {
      row[label] = iR
    })
    result.push(row)
  }
  return result
}</code><div class="file-link"><a href="build.js">build.js</a></div></pre>

<p>Next,
we write <code>filter</code> and <code>select</code> for tables laid out this way.
We need to provide a callback function to <code>filter</code> to determine which rows to keep
like the callback for <code>Array.filter</code>;
for selecting columns,
we provide a list of the keys that identify the columns we want to keep.
We expect filtering to be relatively fast,
since it is <span i="recycling data">recycling</span> rows,
while selecting should be relatively slow because we have to construct a new set of arrays
(<span f="data-table-row-ops"></span>).</p>

<pre class="language-js" title="table-performance.js"><code class="language-js">
const rowFilter = (table, func) =&gt; {
  return table.filter(row =&gt; func(row))
}

const rowSelect = (table, toKeep) =&gt; {
  return table.map(row =&gt; {
    const newRow = {}
    toKeep.forEach(label =&gt; {
      newRow[label] = row[label]
    })
    return newRow
  })
}</code><div class="file-link"><a href="table-performance.js">table-performance.js</a></div></pre>

<figure id="data-table-row-ops" slug="data-table">
  <img src="figures/row-ops.svg" alt="Row-major operations" />
  <figcaption>Operations on row-major data tables.</figcaption>
</figure>

<p>Now let's do the same for column-major storage.
Building the object that holds the columns is straightforward:</p>

<pre class="language-js" title="build.js"><code class="language-js">
export const buildCols = (nRows, labels) =&gt; {
  const result = {}
  labels.forEach(label =&gt; {
    result[label] = []
    for (let iR = 0; iR &lt; nRows; iR += 1) {
      result[label].push(iR)
    }
  })
  return result
}</code><div class="file-link"><a href="build.js">build.js</a></div></pre>

<p>Filtering is more complex because the values in each row are scattered across several arrays,
but selecting is just a matter of recycling the arrays we want in the new table.
We expect selecting to be relatively fast,
since only the references to the columns need to be copied,
but filtering will be relatively slow since we are constructing multiple new arrays
(<span f="data-table-col-ops"></span>).</p>

<pre class="language-js" title="table-performance.js"><code class="language-js">
const colFilter = (table, func) =&gt; {
  const result = {}
  const labels = Object.keys(result)
  labels.forEach(label =&gt; {
    result[label] = []
  })
  for (let iR = 0; iR &lt; table.label_1.length; iR += 1) {
    if (func(table, iR)) {
      labels.forEach(label =&gt; {
        result[label].push(table[label][iR])
      })
    }
  }
  return result
}

const colSelect = (table, toKeep) =&gt; {
  const result = {}
  toKeep.forEach(label =&gt; {
    result[label] = table[label]
  })
  return result
}</code><div class="file-link"><a href="table-performance.js">table-performance.js</a></div></pre>

<figure id="data-table-col-ops" slug="data-table">
  <img src="figures/col-ops.svg" alt="Column-major operations" />
  <figcaption>Operations on column-major data tables.</figcaption>
</figure>

<div class="callout">

  <h3 id="not-quite-polymorphic">Not quite polymorphic</h3>

  <p>Our tests would be simpler to write if the two versions of <code>filter</code> and <code>select</code>
took exactly the same parameters,
but the row-testing functions for <code>filter</code> are different
because of the differences in the ways the tables are stored.
We could force them to be the same by (for example)
packing the values for each row in the column-major implementation
into a temporary object
and passing that to the same filtering function we used for the row-major implementation,
but that extra work would bias the performance comparison in row-major's favor.</p>

</div>

<h2 id="how-can-we-test-the-performance-of-our-implementations">How can we test the performance of our implementations?</h2>

<p>Now that we have our tables and operations,
we can build a <span g="test_harness" i="test harness; experiments!test harness">test harness</span> to run those operations
on data tables of varying sizes.
We arbitrarily decide to keep half of the columns and one-third of the rows;
these ratios will affect our decision about which is better,
so if we were doing this for a real application we would test what happens
as these fractions vary.
And as we said earlier,
the relative performance will also depend on the how many filters we do for each select;
our balance should be based on data from whatever application we intend to support.</p>

<p>Our performance measurement program looks like this:</p>

<pre class="language-js" title="table-performance.js"><code class="language-js">
const RANGE = 3

const main = () =&gt; {
  const nRows = parseInt(process.argv[2])
  const nCols = parseInt(process.argv[3])
  const filterPerSelect = parseFloat(process.argv[4])

  const labels = [...Array(nCols).keys()].map(i =&gt; `label_${i + 1}`)
  const someLabels = labels.slice(0, Math.floor(labels.length / 2))
  assert(someLabels.length &gt; 0,
    'Must have some labels for select (array too short)')

  const [rowTable, rowSize, rowHeap] = memory(buildRows, nRows, labels)
  const [colTable, colSize, colHeap] = memory(buildCols, nRows, labels)

  const rowFilterTime =
    time(rowFilter, rowTable,
      row =&gt; ((row.label_1 % RANGE) === 0))
  const rowSelectTime =
    time(rowSelect, rowTable, someLabels)
  const colFilterTime =
    time(colFilter, colTable,
      (table, iR) =&gt; ((table.label_1[iR] % RANGE) === 0))
  const colSelectTime =
    time(colSelect, colTable, someLabels)

  const ratio = calculateRatio(filterPerSelect,
    rowFilterTime, rowSelectTime,
    colFilterTime, colSelectTime)

  const result = {
    nRows,
    nCols,
    filterPerSelect,
    rowSize,
    rowHeap,
    colSize,
    colHeap,
    rowFilterTime,
    rowSelectTime,
    colFilterTime,
    colSelectTime,
    ratio
  }
  console.log(yaml.safeDump(result))
}</code><div class="file-link"><a href="table-performance.js">table-performance.js</a></div></pre>

<p>The functions that actually do the measurements
use the <a href="https://www.npmjs.com/package/microtime" title="microtime"><code>microtime</code></a> library to get microsecond level timing
because JavaScript's <code>Date</code> only gives us millisecond-level resolution.
We use <a href="https://www.npmjs.com/package/object-sizeof" title="object-sizeof package"><code>object-sizeof</code></a> to estimate memory how much memory our structures require;
we also call <code>process.memoryUsage()</code> and look at the <code>heapUsed</code> value
to see how much memory <a href="https://nodejs.org/en/" title="Node.js">Node</a> is using while the program runs,
but that may be affected by <span g="garbage_collection">garbage collection</span>
and a host of other factors outside our control.</p>

<pre class="language-js" title="table-performance.js"><code class="language-js">
const memory = (func, ...params) =&gt; {
  const before = process.memoryUsage()
  const result = func(...params)
  const after = process.memoryUsage()
  const heap = after.heapUsed - before.heapUsed
  const size = sizeof(result)
  return [result, size, heap]
}

const time = (func, ...params) =&gt; {
  const before = microtime.now()
  func(...params)
  const after = microtime.now()
  return after - before
}

const calculateRatio = (f2S, rFilterT, rSelectT, cFilterT, cSelectT) =&gt; {
  return ((f2S * rFilterT) + rSelectT) / ((f2S * cFilterT) + cSelectT)
}</code><div class="file-link"><a href="table-performance.js">table-performance.js</a></div></pre>

<p>Let's run our program for a table with 100 rows and 3 columns and a 3:1 ratio of filter to select:</p>

<pre class="language-sh" title="table-performance-100-03-03.sh"><code class="language-sh">node table-performance.js 100 3 3

</code><div class="file-link"><a href="table-performance-100-03-03.sh">table-performance-100-03-03.sh</a></div></pre>
<pre class="language-out" title="table-performance-100-03-03.out"><code class="language-out">nRows: 100
nCols: 3
filterPerSelect: 3
rowSize: 6600
rowHeap: 26512
colSize: 2442
colHeap: 8536
rowFilterTime: 75
rowSelectTime: 111
colFilterTime: 137
colSelectTime: 48
ratio: 0.7320261437908496

</code><div class="file-link"><a href="table-performance-100-03-03.out">table-performance-100-03-03.out</a></div></pre>

<p class="continue">What if we increase the table size to 10,000 rows by 30 columns with the same 3:1 filter/select ratio?</p>

<pre class="language-out" title="table-performance-10000-30-03.out"><code class="language-out">nRows: 10000
nCols: 30
filterPerSelect: 3
rowSize: 7020000
rowHeap: 18392064
colSize: 2400462
colHeap: -3473800
rowFilterTime: 2929
rowSelectTime: 15863
colFilterTime: 4529
colSelectTime: 104
ratio: 1.8004528522386969

</code><div class="file-link"><a href="table-performance-10000-30-03.out">table-performance-10000-30-03.out</a></div></pre>

<p class="continue">And if we keep the table size the same but use a 10:1 filter/select ratio?</p>

<pre class="language-out" title="table-performance-10000-30-10.out"><code class="language-out">nRows: 10000
nCols: 30
filterPerSelect: 10
rowSize: 7020000
rowHeap: 18287160
colSize: 2400462
colHeap: -3645056
rowFilterTime: 2376
rowSelectTime: 15566
colFilterTime: 4380
colSelectTime: 90
ratio: 0.8960127591706539

</code><div class="file-link"><a href="table-performance-10000-30-10.out">table-performance-10000-30-10.out</a></div></pre>

<table id="data-table-performance">
  <caption>Relative performance of operations on row-major and column-major data tables.</caption>
  <thead>
    <tr>
      <th style="text-align: left">value</th>
      <th style="text-align: right">100-03-03</th>
      <th style="text-align: right">10000-30-03</th>
      <th style="text-align: right">10000-30-10</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">nRows</td>
      <td style="text-align: right">100</td>
      <td style="text-align: right">10000</td>
      <td style="text-align: right">10000</td>
    </tr>
    <tr>
      <td style="text-align: left">nCols</td>
      <td style="text-align: right">3</td>
      <td style="text-align: right">30</td>
      <td style="text-align: right">30</td>
    </tr>
    <tr>
      <td style="text-align: left">filterPerSelect</td>
      <td style="text-align: right">3</td>
      <td style="text-align: right">3</td>
      <td style="text-align: right">10</td>
    </tr>
    <tr>
      <td style="text-align: left">rowFilterTime</td>
      <td style="text-align: right">75</td>
      <td style="text-align: right">2929</td>
      <td style="text-align: right">2376</td>
    </tr>
    <tr>
      <td style="text-align: left">rowSelectTime</td>
      <td style="text-align: right">111</td>
      <td style="text-align: right">15863</td>
      <td style="text-align: right">15566</td>
    </tr>
    <tr>
      <td style="text-align: left">colFilterTime</td>
      <td style="text-align: right">137</td>
      <td style="text-align: right">4529</td>
      <td style="text-align: right">4380</td>
    </tr>
    <tr>
      <td style="text-align: left">colSelectTime</td>
      <td style="text-align: right">48</td>
      <td style="text-align: right">104</td>
      <td style="text-align: right">90</td>
    </tr>
  </tbody>
</table>

<p>The results in <span t="data-table-performance"></span> show that column-major storage is better.
It uses less memory (presumably because column labels aren't duplicated once per row)
and the time required to construct new objects when doing select with row-major storage
outweighs cost of appending to arrays when doing filter with column-major storage.
Unfortunately,
the code for column-major storage is a little more complicated to write,
which is a cost that doesn't show up in experiments.</p>

<h2 id="what-is-the-most-efficient-way-to-save-a-table">What is the most efficient way to save a table?</h2>

<p>Data is valuable,
so we are going to store data tables in files of some kind.
If one storage scheme is much more efficient than another and we are reading or writing frequently,
that could change our mind about which implementation to pick.</p>

<p>Two simple text-based schemes are row-oriented and column-oriented <span g="json">JSON</span>—basically,
just printing the data structures we have.
Let's run the 10,000×30 test:</p>

<pre class="language-out" title="storage-performance-10000-30.out"><code class="language-out">nRows: 10000
nCols: 30
rowStringTime: 57342
rowStringSize: 9393402
colStringTime: 13267
colStringSize: 2934164

</code><div class="file-link"><a href="storage-performance-10000-30.out">storage-performance-10000-30.out</a></div></pre>

<p>The time needed for the row-major version is almost ten times greater than
that needed for the column-major version;
we assume that the redundant printing of the labels is mostly to blame,
just as redundant storage of the labels was to blame for row-major's greater memory requirements.</p>

<p>If that diagnosis is correct,
then a packed version of row-major storage ought to be faster.
We save the column headers once,
then copy the data values into an array of arrays and save that:</p>

<pre class="language-js" title="packed-rows.js"><code class="language-js">
const asPackedJson = (table) =&gt; {
  const temp = {}
  temp.keys = Object.keys(table[0])
  temp.values = table.map(row =&gt; temp.keys.map(k =&gt; row[k]))
  return JSON.stringify(temp)
}</code><div class="file-link"><a href="packed-rows.js">packed-rows.js</a></div></pre>

<pre class="language-out" title="packed-rows-10000-30.out"><code class="language-out">nRows: 10000
nCols: 30
packedRowStringTime: 29659
packedRowStringSize: 2974084

</code><div class="file-link"><a href="packed-rows-10000-30.out">packed-rows-10000-30.out</a></div></pre>

<p>These results show that changing layout for storage
is faster than turning the data structure we have into a string.
Again,
we assume this is because copying data takes less time than turning labels into strings over and over,
but column-major storage is still the best approach.</p>

<h2 id="does-binary-storage-improve-performance">Does binary storage improve performance?</h2>

<p>Let's try one more strategy for storing our tables.
JavaScript stores values in <span g="tagged_data" i="tagged data structure">tagged</span> data structures:
some bits define the value's type
while other bits store the value itself in a type-dependent way
(<span f="data-table-object-storage"></span>).</p>

<figure id="data-table-object-storage" slug="data-table">
  <img src="figures/object-storage.svg" alt="JavaScript object storage" />
  <figcaption>How JavaScript uses tagged data structures to store objects.</figcaption>
</figure>

<p>We can save space by keeping track of the types ourselves
and just storing the bits that represent the values.
JavaScript has an <span i="ArrayBuffer"><code>ArrayBuffer</code></span> class for exactly this purpose.
It stores any value we want as a set of bits;
we then access those bits through a view that presents the data as a particular type,
such as Boolean (one byte per value) or number (64 bits per number).
As <span f="data-table-packed-storage"></span> shows,
we can mix different types of data in a single <code>ArrayBuffer</code>,
but it's up to us to keep track of which bytes belong to which values.</p>

<figure id="data-table-packed-storage" slug="data-table">
  <img src="figures/packed-storage.svg" alt="Packing objects for storage" />
  <figcaption>Storing object values as bits with lookup information.</figcaption>
</figure>

<p>To store a column-major table we will fill an <code>ArrayBuffer</code> with:</p>

<ol>
  <li>
    <p>Two integers that hold the table's size (number of rows and number of columns).</p>
  </li>
  <li>
    <p>A string with the column labels joined by newline characters.
(We use newlines as a separator because we assume column labels can't contain them.)</p>
  </li>
  <li>
    <p>The numbers themselves.</p>
  </li>
</ol>

<pre class="language-js" title="packed-cols.js"><code class="language-js">
const asBinary = (table) =&gt; {
  const labels = Object.keys(table)

  const nCols = labels.length
  const nRows = table[labels[0]].length
  const dimensions = new Uint32Array([nCols, nRows])

  const allLabels = labels.join('\n')
  const encoder = new TextEncoder()
  const encodedLabels = encoder.encode(allLabels)

  const dataSize = sizeof(0) * nCols * nRows
  const totalSize =
    dimensions.byteLength + encodedLabels.byteLength + dataSize

  const buffer = new ArrayBuffer(totalSize)
  const result = new Uint8Array(buffer)
  result.set(dimensions, 0)
  result.set(encodedLabels, dimensions.byteLength)

  let current = dimensions.byteLength + encodedLabels.byteLength
  labels.forEach(label =&gt; {
    const temp = new Float64Array(table[label])
    result.set(temp, current)
    current += temp.byteLength
  })

  return result
}</code><div class="file-link"><a href="packed-cols.js">packed-cols.js</a></div></pre>

<pre class="language-out" title="packed-cols-10000-30.out"><code class="language-out">nRows: 10000
nCols: 30
packedColBinaryTime: 6074
packedColBinarySize: 2400268

</code><div class="file-link"><a href="packed-cols-10000-30.out">packed-cols-10000-30.out</a></div></pre>

<p>Packing the data table saves time
because copying bits is faster than turning numbers into characters,
but it doesn't save as much space as expected.
The reason is that double-precision numbers are 8 bytes long,
but because we have chosen simple integer values for our tests,
they can be represented by just 5 characters (which is 10 bytes).
If we had "real" numbers the storage benefit would probably be more pronounced;
once again,
the result of our experiment depends on the test cases we choose.</p>

<div class="callout">

  <h3 id="engineering">Engineering</h3>

  <p>If science is the use of the experimental method to investigate the world,
engineering is the use of the experimental method
to investigate and improve the things that people build.
Good software designers collect and analyze data all the time
to find out whether one website design works better than another <cite>Kohavi2020</cite>
or to improve the performance of CPUs <cite>Patterson2017</cite>;
a few simple experiments like these can sometimes save weeks or months of effort.</p>

</div>

        
        <h2 id="exercises">Exercises</h2>

<h3 class="exercise" id="x-row-fraction">Varying filter behavior</h3>

<p>How does our decision about which storage format is better change
if we keep 1% of rows when filtering instead of one third?
What if we keep 90% of rows?</p>


<h3 class="exercise" id="x-string-filter">Filtering by strings</h3>

<p>Modify the comparison of filter and select to work with tables
that contain columns of strings instead of columns of numbers
and see how that changes performance.
For testing,
creating random 4-letter strings using the characters A-Z
and then filter by:</p>

<ul>
  <li>an exact match,</li>
  <li>strings starting with a specific character, and</li>
  <li>strings that contain a specific character</li>
</ul>


<h3 class="exercise" id="x-join-performance">Join performance</h3>

<p>A join combines data from two tables based on matching keys.
For example,
if the two tables are:</p>

<div class="latex" command="\vspace{\baselineskip}" />

<table>
  <thead>
    <tr>
      <th>Key</th>
      <th>Left</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>A</td>
      <td>a1</td>
    </tr>
    <tr>
      <td>B</td>
      <td>b1</td>
    </tr>
    <tr>
      <td>C</td>
      <td>c1</td>
    </tr>
  </tbody>
</table>

<div class="latex" command="\vspace{\baselineskip}" />

<p class="continue">and:</p>

<div class="latex" command="\vspace{\baselineskip}" />

<table>
  <thead>
    <tr>
      <th>Key</th>
      <th>Right</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>A</td>
      <td>a2</td>
    </tr>
    <tr>
      <td>A</td>
      <td>a3</td>
    </tr>
    <tr>
      <td>B</td>
      <td>b2</td>
    </tr>
  </tbody>
</table>

<div class="latex" command="\vspace{\baselineskip}" />

<p class="continue">then the join is:</p>

<div class="latex" command="\vspace{\baselineskip}" />

<table>
  <thead>
    <tr>
      <th>Key</th>
      <th>Left</th>
      <th>Right</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>A</td>
      <td>a1</td>
      <td>a2</td>
    </tr>
    <tr>
      <td>A</td>
      <td>a1</td>
      <td>a3</td>
    </tr>
    <tr>
      <td>B</td>
      <td>b1</td>
      <td>b2</td>
    </tr>
  </tbody>
</table>

<div class="latex" command="\vspace{\baselineskip}" />

<p>Write a test to compare the performance of row-wise vs. column-wise storage
when joining two tables based on matching numeric keys.
Does the answer depend on the fraction of keys that match?</p>


<h3 class="exercise" id="x-join-optimization">Join optimization</h3>
<p>The simplest way to <span g="join">join</span> two tables is
to look for matching keys using a double loop.
An alternative is to build an <span g="index_database">index</span> for each table
and then use it to construct matches.
For example, suppose the tables are:</p>

<div class="latex" command="\vspace{\baselineskip}" />

<table>
  <thead>
    <tr>
      <th>Key</th>
      <th>Left</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>A</td>
      <td>a1</td>
    </tr>
    <tr>
      <td>B</td>
      <td>b1</td>
    </tr>
    <tr>
      <td>C</td>
      <td>c1</td>
    </tr>
  </tbody>
</table>

<div class="latex" command="\vspace{\baselineskip}" />

<p class="continue">and:</p>

<div class="latex" command="\vspace{\baselineskip}" />

<table>
  <thead>
    <tr>
      <th>Key</th>
      <th>Right</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>A</td>
      <td>a2</td>
    </tr>
    <tr>
      <td>A</td>
      <td>a3</td>
    </tr>
    <tr>
      <td>B</td>
      <td>b2</td>
    </tr>
  </tbody>
</table>

<div class="latex" command="\vspace{\baselineskip}" />

<p>The first step is to create a <code>Map</code> showing where each key is found in the first table:</p>

<pre><code class="language-js">{A: [0], B: [1], C: [2]}
</code></pre>

<p class="continue">The second step is to create a similar <code>Map</code> for the second table:</p>

<pre><code class="language-js">{A: [0, 1], B: [2]}
</code></pre>

<p class="continue">We can then loop over the keys in one of the maps,
look up values in the second map,
and construct all of the matches.</p>

<p>Write a function that joins two tables this way.
Is it faster or slower than using a double loop?
How does the answer depend on the number of keys and the fraction that match?</p>

<h3 class="exercise" id="x-flip-storage">Flipping storage</h3>

<p>Our tests showed that storing row-oriented tables as JSON
is much slower than storing column-oriented tables.
Write a test to determine whether converting a row-oriented table to a column-oriented table
and then saving the latter
is faster than saving the row-oriented table directly.</p>


<h3 class="exercise" id="x-sparse-storage">Sparse storage</h3>

<p>A <span g="sparse_matrix">sparse matrix</span> is one in which most of the values are zero.
Instead of storing them all,
a program can use a map to store non-zero values
and a lookup function to return zero for anything that isn't stored explicitly:</p>

<pre><code class="language-js">def spareMatrixGet(matrix, row, col) =&gt; {
  return matrix.contains(row, col)
    ? matrix.get(row, col)
    : 0
}
</code></pre>

<p>The same technique can be used if most of the entries in a data table are missing.
Write a function that creates a sparse table in which a random 5% of the values are non-zero
and the other 95% are zero,
then compare the memory requirements and performance of filter and select for this implementation
versus those of row-wise and column-wise storage.</p>


<h3 class="exercise" id="x-loading-time">Loading time</h3>

<p>Modify the programs in this section to measure the time required to convert a data table from JSON or binary form
back to a data structure.</p>


<h3 class="exercise" id="x-fixed-width">Saving fixed-width strings</h3>

<p>To improve performance,
databases often store <span g="fixed_width_string">fixed-width</span> strings,
i.e.,
they limit the length of the strings in a column to some fixed size
and <span g="pad_string">pad</span> strings that are shorter than that.</p>

<ol>
  <li>
    <p>Write a function that takes an array of strings and an integer with
and creates an <code>ArrayBuffer</code> containing the strings padded to that width.
The function should throw an exception if any of the strings
are longer than the specified width.</p>
  </li>
  <li>
    <p>Write another function that takes an <code>ArrayBuffer</code> as input
and returns an array of strings.
This function should remove the padding
so that strings shorter than the fixed width are restored to their original form.</p>
  </li>
</ol>


<h3 class="exercise" id="x-variable-width">Saving variable-width strings</h3>
<p><span g="fixed_width_string">Fixed-width</span> storage is inefficient for large blocks of text
such as contracts, novels, and resumés,
since padding every document to the length of the longest will probably waste a lot of space.
An alternative way to store these in binary is to save each entry as a (length, text) pair.</p>

<ol>
  <li>
    <p>Write a function that takes a list of strings as input
and returns an <code>ArrayBuffer</code> containing (length, text) pairs.</p>
  </li>
  <li>
    <p>Write another function that takes such an <code>ArrayBuffer</code>
and returns an array containing the original text.</p>
  </li>
  <li>
    <p>Write tests with Mocha to confirm that your functions work correctly.</p>
  </li>
</ol>

<h3 class="exercise" id="x-ascii-storage">ASCII storage</h3>

<p>The original ASCII standard specified
a 7-bit <span g="character_encoding">character encoding</span> for letters commonly used in English,
and many data files still only use characters whose numeric codes are in the range 0–127.</p>

<ol>
  <li>
    <p>Write a function that takes an array of single-letter strings
and returns an <code>ArrayBuffer</code> that stores them using one byte per character
if all of the characters will fit into 7 bits,
and multiple bytes per character if any of the characters require more than 7 bits.</p>
  </li>
  <li>
    <p>Write another function that takes an <code>ArrayBuffer</code> generated by the first function
and re-creates the array of characters.
The function must <em>only</em> take the <code>ArrayBuffer</code> as an argument,
so the first element of the <code>ArrayBuffer</code> should indicate
how to interpret the rest of its contents.</p>
  </li>
  <li>
    <p>Write tests with Mocha to check that your functions work correctly.</p>
  </li>
</ol>




      </main>
      <footer>
  <hr/>
  <small>
    <span class="copyright"><i class="far fa-copyright"></i> <time datetime="2020-01-01">2020</time>-<time datetime="2022-03-14T08:04:08-04:00">2022</time> Greg Wilson</span>
    &middot;
    <span>Powered by <a href="http://jekyllrb.com/">Jekyll</a></span>
    &middot;
    <span>Last built 2022-03-14 08:04:08 -0400</span>
  </small>
  <div class="ftr-links">
    <a href="mailto:gvwilson@third-bit.com" aria-label="Mail the author"><i class="far fa-envelope" aria-hidden="true"></i></a>
    |
    <a href="https://github.com/gvwilson" aria-label="Author's GitHub repository"><i class="fab fa-github" aria-hidden="true"></i></a>
    <a href="https://twitter.com/gvwilson" aria-label="Author's Twitter feed"><i class="fab fa-twitter" aria-hidden="true"></i></a>
    <a href="https://www.linkedin.com/in/greg-wilson-a26510b6/" aria-label="Author's LinkedIn profile"><i class="fab fa-linkedin-in" aria-hidden="true"></i></a>
    |
    <a href="/license/" aria-label="License"><i class="fab fa-creative-commons-by" aria-hidden="true"></i><i class="fab fa-creative-commons-nc" aria-hidden="true"></i><img src="/static/hippocratic.svg" alt="Hippocratic License logo" class="iconlink" /></a>
  </div>
</footer>

    </div>
  </body>
</html>
