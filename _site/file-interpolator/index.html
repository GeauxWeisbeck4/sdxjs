<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,400italic|Source+Code+Pro:400,700" type="text/css">
  <script src="https://kit.fontawesome.com/fbb4c3a0bc.js" crossorigin="anonymous"></script>
  <script defer data-domain="stjs.tech" src="https://plausible.io/js/plausible.js"></script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" } }
  })
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <title>Software Tools in JavaScript</title>
  <link href="/static/local.css" rel="stylesheet" type="text/css">
  <script src="/static/local.js"></script>
  <script>
  const ENTRIES = {"introduction": { title: "Introduction", label: "Chapter 1" },"systems-programming": { title: "Systems Programming", label: "Chapter 2" },"async-programming": { title: "Asynchronous Programming", label: "Chapter 3" },"unit-test": { title: "Unit Testing", label: "Chapter 4" },"file-backup": { title: "File Backup", label: "Chapter 5" },"data-table": { title: "Data Tables", label: "Chapter 6" },"pattern-matching": { title: "Pattern Matching", label: "Chapter 7" },"regex-parser": { title: "Parsing Expressions", label: "Chapter 8" },"page-templates": { title: "Page Templates", label: "Chapter 9" },"build-manager": { title: "Build Manager", label: "Chapter 10" },"layout-engine": { title: "Layout Engine", label: "Chapter 11" },"file-interpolator": { title: "File Interpolator", label: "Chapter 12" },"module-loader": { title: "Module Loader", label: "Chapter 13" },"style-checker": { title: "Style Checker", label: "Chapter 14" },"code-generator": { title: "Code Generator", label: "Chapter 15" },"doc-generator": { title: "Documentation Generator", label: "Chapter 16" },"module-bundler": { title: "Module Bundler", label: "Chapter 17" },"package-manager": { title: "Package Manager", label: "Chapter 18" },"virtual-machine": { title: "Virtual Machine", label: "Chapter 19" },"debugger": { title: "Debugger", label: "Chapter 20" },"conclusion": { title: "Conclusion", label: "Chapter 21" },"license": { title: "Licensing", label: "Appendix A" },"bibliography": { title: "Bibliography", label: "Appendix B" },"conduct": { title: "Code of Conduct", label: "Appendix C" },"contributing": { title: "Contributing", label: "Appendix D" },"glossary": { title: "Glossary", label: "Appendix E" },"links": { title: "Links", label: "Appendix F" },"authors": { title: "Authors", label: "Appendix G" },"index": { title: "Index", label: "Appendix H" }}
  const FIGURES = {"async-programming-chained": "3.4","async-programming-event-loop": "3.1","async-programming-handling-errors": "3.6","async-programming-resolve": "3.3","async-programming-set-timeout": "3.2","async-programming-temporary-named-fields": "3.5","build-manager-compiling": "10.1","build-manager-dependencies": "10.2","build-manager-pattern-rules": "10.4","build-manager-template-method": "10.3","code-generator-spread": "15.1","data-table-col-ops": "6.4","data-table-conceptual": "6.1","data-table-object-storage": "6.5","data-table-packed-storage": "6.6","data-table-row-ops": "6.3","data-table-storage-order": "6.2","debugger-initialization": "20.1","debugger-test-interact": "20.2","doc-generator-comments": "16.1","doc-generator-fill-in-headers": "16.4","doc-generator-mapping": "16.3","doc-generator-process-plain": "16.2","file-backup-hash-function": "5.1","file-backup-mock-fs": "5.4","file-backup-storage": "5.3","file-backup-streaming": "5.2","file-interpolator-cache": "12.3","file-interpolator-conceptual": "12.1","file-interpolator-eval": "12.2","file-interpolator-search-path": "12.4","layout-engine-coordinate-system": "11.1","layout-engine-draw-over": "11.4","layout-engine-layout": "11.3","layout-engine-sizing": "11.2","layout-engine-wrap": "11.5","module-bundler-bundling": "17.1","module-bundler-complicated": "17.2","module-bundler-head-tail": "17.5","module-bundler-returning-functions": "17.6","module-bundler-structure": "17.4","module-bundler-transitive-closure": "17.3","module-loader-circularity": "13.3","module-loader-closures": "13.1","module-loader-iife": "13.2","package-manager-allowable": "18.1","package-manager-pruning": "18.2","page-templates-comprehension": "9.10","page-templates-options": "9.1","page-templates-output-conditional": "9.8","page-templates-output-loop": "9.9","page-templates-output-multiple-variables": "9.7","page-templates-output-single-constant": "9.5","page-templates-output-single-variable": "9.6","page-templates-output-static-text": "9.4","page-templates-stack": "9.2","page-templates-visitor": "9.3","pattern-matching-dom-tree": "7.1","pattern-matching-greedy-failure": "7.4","pattern-matching-query-selectors": "7.2","pattern-matching-regex-objects": "7.3","pattern-matching-rest": "7.5","regex-parser-expression-tree": "8.1","regex-parser-finite-state-machine": "8.3","regex-parser-mechanics": "8.2","style-checker-iterator": "14.3","style-checker-parse-tree": "14.1","style-checker-walk-tree": "14.2","systems-programming-anonymous-functions": "2.4","systems-programming-array-filter": "2.6","systems-programming-callbacks": "2.2","systems-programming-destructuring-assignment": "2.7","systems-programming-execution-order": "2.3","systems-programming-globbing": "2.5","systems-programming-process-argv": "2.1","systems-programming-triple-callback": "2.8","unit-test-hope-structure": "4.2","unit-test-lifecycle": "4.3","unit-test-mental-model": "4.1","virtual-machine-architecture": "19.1","virtual-machine-count-up": "19.3","virtual-machine-storage-allocation": "19.5","virtual-machine-trace-counter": "19.4","virtual-machine-unpacking": "19.2"}
  const TABLES = {"data-table-performance": "6.1","package-manager-example-dependencies": "18.1","package-manager-example-result": "18.2","package-manager-exclusions": "18.3","pattern-matching-cases": "7.2","pattern-matching-supported": "7.1","regex-parser-grammar-codes": "8.1","systems-programming-times": "2.1","virtual-machine-op-codes": "19.1"}
</script>

  <script>window.onload = () => fixPage()</script>
</head>

  <body >
    <nav class="nav-main">
  <ul>
    <li><a href="/" aria-label="Home"><em>Software Tools in JavaScript</em></a></li>
    <li><div class="dropdown">
<span class="navtitle">▿ Chapters</span>
<div class="dropdown-content" id="Chapters"><a class="dropdown-item" href="/introduction/"><span class="nowrap">Introduction</span></a><br/><a class="dropdown-item" href="/systems-programming/"><span class="nowrap">Systems Programming</span></a><br/><a class="dropdown-item" href="/async-programming/"><span class="nowrap">Asynchronous Programming</span></a><br/><a class="dropdown-item" href="/unit-test/"><span class="nowrap">Unit Testing</span></a><br/><a class="dropdown-item" href="/file-backup/"><span class="nowrap">File Backup</span></a><br/><a class="dropdown-item" href="/data-table/"><span class="nowrap">Data Tables</span></a><br/><a class="dropdown-item" href="/pattern-matching/"><span class="nowrap">Pattern Matching</span></a><br/><a class="dropdown-item" href="/regex-parser/"><span class="nowrap">Parsing Expressions</span></a><br/><a class="dropdown-item" href="/page-templates/"><span class="nowrap">Page Templates</span></a><br/><a class="dropdown-item" href="/build-manager/"><span class="nowrap">Build Manager</span></a><br/><a class="dropdown-item" href="/layout-engine/"><span class="nowrap">Layout Engine</span></a><br/><a class="dropdown-item" href="/file-interpolator/"><span class="nowrap">File Interpolator</span></a><br/><a class="dropdown-item" href="/module-loader/"><span class="nowrap">Module Loader</span></a><br/><a class="dropdown-item" href="/style-checker/"><span class="nowrap">Style Checker</span></a><br/><a class="dropdown-item" href="/code-generator/"><span class="nowrap">Code Generator</span></a><br/><a class="dropdown-item" href="/doc-generator/"><span class="nowrap">Documentation Generator</span></a><br/><a class="dropdown-item" href="/module-bundler/"><span class="nowrap">Module Bundler</span></a><br/><a class="dropdown-item" href="/package-manager/"><span class="nowrap">Package Manager</span></a><br/><a class="dropdown-item" href="/virtual-machine/"><span class="nowrap">Virtual Machine</span></a><br/><a class="dropdown-item" href="/debugger/"><span class="nowrap">Debugger</span></a><br/><a class="dropdown-item" href="/conclusion/"><span class="nowrap">Conclusion</span></a></div>
</div>
</li>
    <li><div class="dropdown">
<span class="navtitle">▿ Appendices</span>
<div class="dropdown-content" id="Appendices"><a class="dropdown-item" href="/license/"><span class="nowrap">Licensing</span></a><br/><a class="dropdown-item" href="/bibliography/"><span class="nowrap">Bibliography</span></a><br/><a class="dropdown-item" href="/conduct/"><span class="nowrap">Code of Conduct</span></a><br/><a class="dropdown-item" href="/contributing/"><span class="nowrap">Contributing</span></a><br/><a class="dropdown-item" href="/glossary/"><span class="nowrap">Glossary</span></a><br/><a class="dropdown-item" href="/links/"><span class="nowrap">Links</span></a><br/><a class="dropdown-item" href="/authors/"><span class="nowrap">Authors</span></a><br/><a class="dropdown-item" href="/index/"><span class="nowrap">Index</span></a></div>
</div>
</li>
  </ul>
</nav>

    <div class="container content">
      
<header>
  <h1 class="page-title" slug="file-interpolator">File Interpolator</h1>
  <h2 class="lede">Managing source files that have been broken into pieces</h2>
</header>


      <main>
        <ul class="toc"></ul>
        <div class="terms"><p><strong>Terms defined:</strong> <span g="header_file">header file</span>, <span g="literate_programming">literate programming</span>, <span g="loader">loader</span>, <span g="sandbox">sandbox</span>, <span g="search_path">search path</span>, <span g="shell_variable">shell variable</span></p>
</div>
        <p>Many of the examples in these lessons are too long
to show comfortably in one block of code on a printed page,
so we needed a way to break them up.
As an experiment,
we wrote a custom <span g="loader" i="module loader">module loader</span>
that reads a source file containing specially-formatted comments
and then reads and inserts the files specified in those comments
before running the code
(<span f="file-interpolator-conceptual"></span>).
Modern programming languages don't work this way,
but <span i="C">C</span> and <span i="C++">C++</span> do this
with <span g="header_file" i="header file!in C and C++">header files</span>,
and <span i="static site generator!header file; header file!static site generator">static site generators</span>
(<span x="page-templates"></span>) do this to share fragments of HTML.</p>

<figure id="file-interpolator-conceptual" slug="file-interpolator">
  <img src="figures/conceptual.svg" alt="Using file inclusions" />
  <figcaption>Including fragments of code to create runnable programs.</figcaption>
</figure>

<p>The special comments in our source files contain two fields:
the text to put in the displayed version
and file to include when loading:</p>

<pre class="language-js" title="interpolation-example.js"><code class="language-js">
class Something {
  /*+ constructor + constructor.js +*/

  /*+ a long method + long_method.js +*/

  /*+ another method + another_method.js +*/
}

</code><div class="file-link"><a href="interpolation-example.js">interpolation-example.js</a></div></pre>

<p>We got this to work,
but decided to use a different approach in this book.
The stumbling block was that the style-checking tool <span i="ESLint"><a href="https://eslint.org/" title="ESLint">ESLint</a></span>
didn't know what to make of our inclusions,
so we would either have to modify it or build a style checker of our own.
(We will actually do that in <span x="style-checker"></span>,
but we won't go nearly as far as ESLint.)</p>

<p>Despite being a dead end,
the inclusion tool is a good way to show
how JavaScript turns source code into something it can execute.
We need to be able to do this in the next couple of chapters,
so we might as well tackle it now.</p>

<h2 id="how-can-we-evaluate-javascript-dynamically">How can we evaluate JavaScript dynamically?</h2>

<p>We want to display files as they are on the web and in print,
but interpolate the files referenced in special comments
when we load things with <code>import</code>.
To do this,
we need to understand the lifecycle of a JavaScript program.
When we ask for a file,
<a href="https://nodejs.org/en/" title="Node.js">Node</a> reads the text,
translates it into runnable instructions,
and runs those instructions.
We can do the second and third steps whenever we want using a function called <code>eval</code>,
which takes a string as input and executes it as if it were part of the program
(<span f="file-interpolator-eval"></span>).</p>

<figure id="file-interpolator-eval" slug="file-interpolator">
  <img src="figures/eval.svg" alt="How eval works" />
  <figcaption><code>eval</code> vs. normal translation and execution.</figcaption>
</figure>

<div class="callout">

  <h3 id="this-is-not-a-good-idea">This is not a good idea</h3>

  <p><span i="eval!insecurity of"><code>eval</code></span> is a security risk:
arbitrary code can do arbitrary things,
so if we take a string typed in by a user and execute it without any checks
it could email our bookmark list to villains all over the world,
erase our hard drive,
or do anything else that code can do (which is pretty much anything).
Browsers do their best to run code in a <span g="sandbox" i="sandbox (for safe execution)">sandbox</span> for safety,
but Node doesn't,
so it's up to us to be (very) careful.</p>

</div>

<p>To see <code>eval</code> in action,
let's evaluate an expression:</p>

<pre class="language-js" title="eval-two-plus-two.js"><code class="language-js">
console.log(eval('2 + 2'))

</code><div class="file-link"><a href="eval-two-plus-two.js">eval-two-plus-two.js</a></div></pre>
<pre class="language-out" title="eval-two-plus-two.out"><code class="language-out">4

</code><div class="file-link"><a href="eval-two-plus-two.out">eval-two-plus-two.out</a></div></pre>

<p class="continue">Notice that the input to <code>eval</code> is <em>not</em> <code>2 + 2</code>,
but rather a string containing the digit 2,
a space,
a plus sign,
another space,
and another 2.
When we call <code>eval</code>,
it translates this string
using exactly the same parser that Node uses for our program
and immediately runs the result.</p>

<p>We can make the example a little more interesting
by constructing the string dynamically:</p>

<pre class="language-js" title="eval-loop.js"><code class="language-js">
const x = 1 
const y = 3 
const z = 5 
for (const name of ['x', 'y', 'z', 'oops']) {
  const expr = `${name} + 1`
  console.log(name, '+ 1 =', eval(expr))
}

</code><div class="file-link"><a href="eval-loop.js">eval-loop.js</a></div></pre>
<pre class="language-out" title="eval-loop.out"><code class="language-out">x + 1 = 2
y + 1 = 4
z + 1 = 6
undefined:1
oops + 1
^

ReferenceError: oops is not defined
    at eval (eval at &lt;anonymous&gt; \
    (/u/stjs/file-interpolator/eval-loop.js:7:30), &lt;anonymous&gt;:1:1)
    at /u/stjs/file-interpolator/eval-loop.js:7:30
    at ModuleJob.run (internal/modules/esm/module_job.js:152:23)
    at async Loader.import (internal/modules/esm/loader.js:166:24)
    at async Object.loadESM (internal/process/esm_loader.js:68:5)

</code><div class="file-link"><a href="eval-loop.out">eval-loop.out</a></div></pre>

<p class="continue">The first time the loop runs the string is <code>'x + 1'</code>;
since there's a variable called <code>x</code> in scope,
<code>eval</code> does the addition and we print the result.
The same thing happens for the variables <code>y</code> and <code>z</code>,
but we get an error when we try to evaluate the string <code>'oops + 1'</code>
because there is no variable in scope called <code>oops</code>.</p>

<p><code>eval</code> can use whatever variables are in scope when it's called,
but what happens to any variables it defines?
This example creates a variable called <code>x</code> and runs <code>console.log</code> to display it,
but as the output shows,
<code>x</code> is local to the <code>eval</code> call
just as variables created inside a function
only exist during a call to that function:</p>

<pre class="language-js" title="eval-local-vars.js"><code class="language-js">
const code = `
  const x = 'hello'
  console.log('x in eval is', x)
`

eval(code)
console.log('typeof x after eval', typeof x)

</code><div class="file-link"><a href="eval-local-vars.js">eval-local-vars.js</a></div></pre>
<pre class="language-out" title="eval-local-vars.out"><code class="language-out">x in eval is hello
typeof x after eval undefined

</code><div class="file-link"><a href="eval-local-vars.out">eval-local-vars.out</a></div></pre>

<p>However,
<code>eval</code> can modify variables defined outside the text being evaluated
in the same way that a function can modify global variables:</p>

<pre class="language-js" title="eval-global-vars.js"><code class="language-js">
let x = 'original' 
eval('x = &quot;modified&quot;')
console.log('x after eval is', x)

</code><div class="file-link"><a href="eval-global-vars.js">eval-global-vars.js</a></div></pre>
<pre class="language-out" title="eval-global-vars.out"><code class="language-out">x after eval is modified

</code><div class="file-link"><a href="eval-global-vars.out">eval-global-vars.out</a></div></pre>

<p class="continue">This means that
if the text we give to <code>eval</code> modifies a structure that is defined outside the text,
that change outlives the call to <code>eval</code>:</p>

<pre class="language-js" title="eval-global-structure.js"><code class="language-js">
const seen = {}

for (const name of ['x', 'y', 'z']) {
  const expr = `seen[&quot;${name}&quot;] = &quot;${name.toUpperCase()}&quot;`
  eval(expr)
}

console.log(seen)

</code><div class="file-link"><a href="eval-global-structure.js">eval-global-structure.js</a></div></pre>
<pre class="language-out" title="eval-global-structure.out"><code class="language-out">{ x: 'X', y: 'Y', z: 'Z' }

</code><div class="file-link"><a href="eval-global-structure.out">eval-global-structure.out</a></div></pre>

<p>The examples so far have all evaluated strings embedded in the program itself,
but <code>eval</code> doesn't care where its input comes from.
Let's move the code that does the modifying into <code>to-be-loaded.js</code>:</p>

<pre class="language-js" title="to-be-loaded.js"><code class="language-js">
// Modify a global structure defined by whoever loads us.
Seen.from_loaded_file = 'from loaded file'

</code><div class="file-link"><a href="to-be-loaded.js">to-be-loaded.js</a></div></pre>

<p class="continue">This doesn't work on its own because <code>Seen</code> isn't defined:</p>

<pre class="language-out" title="to-be-loaded.out"><code class="language-out">/u/stjs/file-interpolator/to-be-loaded.js:3
Seen.from_loaded_file = 'from loaded file'
^

ReferenceError: Seen is not defined
    at /u/stjs/file-interpolator/to-be-loaded.js:3:1
    at ModuleJob.run (internal/modules/esm/module_job.js:152:23)
    at async Loader.import (internal/modules/esm/loader.js:166:24)
    at async Object.loadESM (internal/process/esm_loader.js:68:5)

</code><div class="file-link"><a href="to-be-loaded.out">to-be-loaded.out</a></div></pre>

<p class="continue">But if we read the file and <code>eval</code> the text <em>after</em> defining <code>Seen</code>,
it does what we want:</p>

<pre class="language-js" title="does-the-loading.js"><code class="language-js">
import fs from 'fs'

const Seen = {}

const filename = process.argv[2]
const content = fs.readFileSync(filename, 'utf-8')
console.log('before eval, Seen is', Seen)
eval(content)
console.log('after eval, Seen is', Seen)

</code><div class="file-link"><a href="does-the-loading.js">does-the-loading.js</a></div></pre>
<pre class="language-sh" title="does-the-loading.sh"><code class="language-sh">node does-the-loading.js to-be-loaded.js

</code><div class="file-link"><a href="does-the-loading.sh">does-the-loading.sh</a></div></pre>
<pre class="language-out" title="does-the-loading.out"><code class="language-out">before eval, Seen is {}
after eval, Seen is { from_loaded_file: 'from loaded file' }

</code><div class="file-link"><a href="does-the-loading.out">does-the-loading.out</a></div></pre>

<h2 id="how-can-we-manage-files">How can we manage files?</h2>

<p>The source files in this book are small enough
that we don't have to worry about reading them repeatedly,
but we would like to avoid re-reading things unnecessarily
in large systems or when there might be network delays.
The usual approach is to create a <span i="cache!of loaded files">cache</span>
using the <span i="Singleton pattern; design pattern!Singleton">Singleton pattern</span>
that we first met in <span x="unit-test"></span>.
Whenever we want to read a file,
we check to see if it's already in the cache
(<span f="file-interpolator-cache"></span>).
If it is,
we use that copy;
if not,
we read it and add it to the cache
using the file path as a lookup key.</p>

<figure id="file-interpolator-cache" slug="file-interpolator">
  <img src="figures/cache.svg" alt="Implementing a cache as a singleton" />
  <figcaption>Using the Singleton pattern to implement a cache of loaded files.</figcaption>
</figure>

<p>We can write a simple cache in just a few lines of code:</p>

<pre class="language-js" title="need-simple.js"><code class="language-js">
import fs from 'fs'

class Cache {
  constructor () {
    this.loaded = new Map()
  }

  need (name) {
    if (this.loaded.has(name)) {
      console.log(`returning cached value for ${name}`)
      return this.loaded.get(name)
    }
    console.log(`loading ${name}`)
    const content = fs.readFileSync(name, 'utf-8')
    const result = eval(content)
    this.loaded.set(name, result)
    return result
  }
}

const cache = new Cache()

export default (name) =&gt; {
  return cache.need(name)
}

</code><div class="file-link"><a href="need-simple.js">need-simple.js</a></div></pre>

<p>Since we are using <code>eval</code>, though,
we can't rely on <code>export</code> to make things available to the rest of the program.
Instead,
we rely on the fact that the result of an <code>eval</code> call is the value of
the last expression evaluated.
Since a variable name on its own evaluates to the variable's value,
we can create a function and then use its name
to "export" it from the evaluated file:</p>

<pre class="language-js" title="import-simple.js"><code class="language-js">
// Define.
const report = (message) =&gt; {
  console.log(`report in import-01.js with message &quot;${message}&quot;`)
}

// Export.
report

</code><div class="file-link"><a href="import-simple.js">import-simple.js</a></div></pre>

<p>To test our program,
we load the implementation of the cache using <code>import</code>,
then use it to load and evaluate another file.
This example expects that "other file" to define a function,
which we call in order to show that everything is working:</p>

<pre class="language-js" title="test-simple.js"><code class="language-js">import need from './need-simple.js'

const imported = need('./import-simple.js')
imported('called from test-simple.js')

</code><div class="file-link"><a href="test-simple.js">test-simple.js</a></div></pre>
<pre class="language-sh" title="test-simple.sh"><code class="language-sh">node test-simple.js

</code><div class="file-link"><a href="test-simple.sh">test-simple.sh</a></div></pre>

<h2 id="how-can-we-find-files">How can we find files?</h2>

<p>Each of the files included in our examples is in the same directory as the file including it,
but in C/C++ or a page templating system
we might include a particular file in several different places.
We don't want to have to put all of our files in a single directory,
so we need a way specify where to look for files that are being included.</p>

<p>One option is to use relative paths,
but another option is to give our program
a list of directories to look in.
This is called a <span g="search_path" i="search path">search path</span>,
and many programs use them,
including Node itself.
By convention,
a search path is written as a colon-separated list of directories on Unix
or using semi-colons on Windows.
If the path to an included starts with <code>./</code>,
we look for it locally;
if not,
we go through the directories in the search path in order
until we find a file with a matching name
(<span f="file-interpolator-search-path"></span>).</p>

<figure id="file-interpolator-search-path" slug="file-interpolator">
  <img src="figures/search-path.svg" alt="Implementing a search path" />
  <figcaption>Using a colon-separated list of directories as a search path.</figcaption>
</figure>

<div class="callout">

  <h3 id="thats-just-how-it-is">That's just how it is</h3>

  <p>The rules about search paths in the paragraph above are a convention:
somebody did it this way years ago
and (almost) everyone has imitated it since.
We could implement search paths some other way,
but as with configuration file formats,
variable naming conventions,
and many other things,
the last thing the world needs is more innovation.</p>

</div>

<p>Since the cache is responsible for finding files,
it should also handle the search path.
The outline of the class stays the same:</p>

<pre class="language-js" title="need-path.js"><code class="language-js">
import fs from 'fs'
import path from 'path'

class Cache {
  constructor () {
    this.loaded = new Map()
    this.constructSearchPath()
  }

  need (fileSpec) {
    if (this.loaded.has(fileSpec)) {
      console.log(`returning cached value for ${fileSpec}`)
      return this.loaded.get(fileSpec)
    }
    console.log(`loading value for ${fileSpec}`)
    const filePath = this.find(fileSpec)
    const content = fs.readFileSync(filePath, 'utf-8')
    const result = eval(content)
    this.loaded.set(fileSpec, result)
    return result
  }

}

const cache = new Cache()

export default (fileSpec) =&gt; {
  return cache.need(fileSpec)
}</code><div class="file-link"><a href="need-path.js">need-path.js</a></div></pre>

<p>To get the search path,
we look for the <span g="shell_variable" i="shell variable (for storing search path); search path!shell variable">shell variable</span> <code>NEED_PATH</code>.
(Writing shell variables' names in upper case is another convention.)
If <code>NEED_PATH</code> exists,
we split it on colons to create a list of directories:</p>

<pre class="language-js" title="need-path.js"><code class="language-js">
  constructSearchPath () {
    this.searchPath = []
    if ('NEED_PATH' in process.env) {
      this.searchPath = process.env.NEED_PATH
        .split(':')
        .filter(x =&gt; x.length &gt; 0)
    }
  }</code><div class="file-link"><a href="need-path.js">need-path.js</a></div></pre>

<p>When we need to find a file we first check to see if the path is local.
If it's not,
we try the directories in the search path in order:</p>

<pre class="language-js" title="need-path.js"><code class="language-js">
  constructSearchPath () {
    this.searchPath = []
    if ('NEED_PATH' in process.env) {
      this.searchPath = process.env.NEED_PATH
        .split(':')
        .filter(x =&gt; x.length &gt; 0)
    }
  }</code><div class="file-link"><a href="need-path.js">need-path.js</a></div></pre>

<p>To test this,
we put the file to import in a subdirectory called <code>modules</code>:</p>

<pre class="language-js" title="modules/imported-left.js"><code class="language-js">
// Define.
const report = (message) =&gt; {
  console.log(`in LEFT with message &quot;${message}&quot;`)
}

// Export.
report

</code><div class="file-link"><a href="modules/imported-left.js">modules/imported-left.js</a></div></pre>

<p class="continue">and then put the file doing the importing in the current directory:</p>

<pre class="language-js" title="test-import-left.js"><code class="language-js">import need from './need-path.js'
const imported = need('imported-left.js')
imported('called from test-import-left.js')

</code><div class="file-link"><a href="test-import-left.js">test-import-left.js</a></div></pre>

<p>We now need to set the variable <code>NEED_PATH</code>.
There are many ways to do this in shell;
if we only need the variable to exist for a single command,
the simplest is to write it as:</p>

<pre><code class="language-shell">NAME=value command
</code></pre>

<p class="continue">right before the command (on the same line).
Here's the shell command that runs our test case
using <code>$PWD</code> to get the current working directory:</p>

<pre class="language-sh" title="test-import-left.sh"><code class="language-sh">NEED_PATH=$PWD/modules/ node test-import-left.js

</code><div class="file-link"><a href="test-import-left.sh">test-import-left.sh</a></div></pre>
<pre class="language-out" title="test-import-left.out"><code class="language-out">loading value for imported-left.js
trying /u/stjs/file-interpolator/modules/imported-left.js for \
imported-left.js
in LEFT with message &quot;called from test-import-left.js&quot;

</code><div class="file-link"><a href="test-import-left.out">test-import-left.out</a></div></pre>

<p>Now let's create a second importable file in the <code>modules</code> directory:</p>

<pre class="language-js" title="modules/imported-right.js"><code class="language-js">
// Define.
const report = (message) =&gt; {
  console.log(`in RIGHT with message &quot;${message}&quot;`)
}

// Export.
report

</code><div class="file-link"><a href="modules/imported-right.js">modules/imported-right.js</a></div></pre>

<p class="continue">and load that twice to check that caching works:</p>

<pre class="language-js" title="test-import-right.js"><code class="language-js">import need from './need-path.js'

const imported = need('imported-right.js')
imported('called from test-import-right.js')

const alsoImported = need('imported-right.js')
alsoImported('called from test-import-right.js')

</code><div class="file-link"><a href="test-import-right.js">test-import-right.js</a></div></pre>
<pre class="language-out" title="test-import-right.out"><code class="language-out">loading value for imported-right.js
trying /u/stjs/file-interpolator/modules/imported-right.js for \
imported-right.js
in RIGHT with message &quot;called from test-import-right.js&quot;
returning cached value for imported-right.js
in RIGHT with message &quot;called from test-import-right.js&quot;

</code><div class="file-link"><a href="test-import-right.out">test-import-right.out</a></div></pre>

<h2 id="how-can-we-interpolate-pieces-of-code">How can we interpolate pieces of code?</h2>

<p>Interpolating files is straightforward once we have this machinery in place.
We modify <code>Cache.find</code> to return a directory and a file path,
then add an <code>interpolate</code> method to replace special comments:</p>

<pre class="language-js" title="caching.js"><code class="language-js">
class Cache {
  // ...
  interpolate (fileDir, outer) {
    return outer.replace(Cache.INTERPOLATE_PAT,
                         (match, comment, filename) =&gt; {
      filename = filename.trim()
      const filePath = path.join(fileDir, filename)
      if (!fs.existsSync(filePath)) {
        throw new Error(`Cannot find ${filePath}`)
      }
      const inner = fs.readFileSync(filePath, 'utf-8')
      return inner
    })
  }
  // ...
}
Cache.INTERPOLATE_PAT = /\/\*\+(.+?)\+(.+?)\+\*\//g

</code><div class="file-link"><a href="caching.js">caching.js</a></div></pre>

<p>We can now have a file like this:</p>

<pre class="language-js" title="import-interpolate.js"><code class="language-js">
class Example {
  constructor (msg) {
    this.constructorMessage = msg
  }
  /*+ top method + import-interpolate-topmethod.js +*/
  /*+ bottom method + import-interpolate-bottommethod.js +*/
}

Example

</code><div class="file-link"><a href="import-interpolate.js">import-interpolate.js</a></div></pre>

<p class="continue">and subfiles like this:</p>

<pre class="language-js" title="import-interpolate-topmethod.js"><code class="language-js">
topMethod (msg) {
  this.bottomMethod(`(topMethod ${msg})`)
}

</code><div class="file-link"><a href="import-interpolate-topmethod.js">import-interpolate-topmethod.js</a></div></pre>

<p class="continue">and this:</p>

<pre class="language-js" title="import-interpolate-bottommethod.js"><code class="language-js">
bottomMethod (msg) {
  console.log(`(bottomMethod ${msg})`)
}

</code><div class="file-link"><a href="import-interpolate-bottommethod.js">import-interpolate-bottommethod.js</a></div></pre>

<p>Let's test it:</p>

<pre class="language-sh" title="test-import-interpolate.sh"><code class="language-sh">node test-import-interpolate.js

</code><div class="file-link"><a href="test-import-interpolate.sh">test-import-interpolate.sh</a></div></pre>
<pre class="language-out" title="test-import-interpolate.out"><code class="language-out">(bottomMethod (topMethod called from test-import-interpolate.js))

</code><div class="file-link"><a href="test-import-interpolate.out">test-import-interpolate.out</a></div></pre>

<p>When this program runs, its <span i="lifecycle!of file interpolation">lifecycle</span> is:</p>

<ol>
  <li>Node starts to run <code>test-import-interpolate.js</code>.</li>
  <li>It sees the <code>import</code> of need-interpolate` so it reads and evaluates that code.</li>
  <li>Doing this creates a singleton cache object.</li>
  <li>The program then calls <code>need('./import-interpolate.js')</code>.</li>
  <li>This checks the cache: nope, nothing there.</li>
  <li>So it loads <code>import-interpolate.js</code>.</li>
  <li>It finds two specially-formatted comments in the text…</li>
  <li>…so it loads the file described by each one and inserts the text in place of the comment.</li>
  <li>Now that it has the complete text, it calls <code>eval</code>…</li>
  <li>…and stores the result of <code>eval</code> (which is a class) in the cache.</li>
  <li>It also returns that class.</li>
  <li>We then create an instance of that class and call its method.</li>
</ol>

<p>This works,
but as we said in the introduction we decided not to use it
because it didn't play well with other tools.
No piece of software exists in isolation;
when we evaluate a design,
we always have to ask how it fits into everything else we have.</p>

<h2 id="what-did-we-do-instead">What did we do instead?</h2>

<p>Rather than interpolating file fragments,
we extract or erase parts of regular JavaScript files
based on specially-formatted comments
like the <code>&lt;fragment&gt;...&lt;/fragment&gt;</code> pair shown below.</p>

<pre><code class="language-js">class Example {
  constructor (name) {
    this.name = name
  }

  // &lt;fragment&gt;
  fragment (message) {
    console.log(`${name}: ${message}`)
  }
  // &lt;/fragment&gt;
}
</code></pre>

<p>The code that selects the part of the file we want to display
is part of our page templating system.
It re-extracts code for display every time the web version of this site is built,
which ensures that we always shows what's in the current version of our examples.
However,
this system doesn't automatically update the description of the code:
if we write, "It does X,"
then modify the code to do Y,
our lesson can be inconsistent.
<span g="literate_programming" i="literate programming">Literate programming</span> was invented
to try to prevent this from happening,
but it never really caught on—unfortunately,
most programming systems that describe themselves as "literate" these days
only implement part of <span i="Knuth, Donald"><a href="https://www-cs-faculty.stanford.edu/~knuth/" title="Donald Knuth">Donald Knuth's</a></span> original vision.</p>

        
        <h2 id="exercises">Exercises</h2>

<h3 class="exercise" id="x-security-hole">Security concerns</h3>

<ol>
  <li>
    <p>Write a function <code>loadAndRun</code> that reads a file, evaluates it, and returns the result.</p>
  </li>
  <li>
    <p>Create a file <code>trust-me.js</code> that prints "nothing happening here" when it is evaluated,
but also deletes everything in the directory called <code>target</code>.</p>
  </li>
  <li>
    <p>Write tests for this using <a href="https://www.npmjs.com/package/mock-fs" title="Node mock-fs"><code>mock-fs</code></a>.</p>
  </li>
</ol>

<p class="continue">Please be careful doing this exercise.</p>


<h3 class="exercise" id="x-map-eval">Loading functions</h3>

<p>Write a function that reads a file containing single-argument functions like this:</p>

<pre><code class="language-js">addOne: (x) =&gt; x + 1
halve: (x) =&gt; x / 2
array: (x) =&gt; Array(x).fill(0)
</code></pre>

<p class="continue">and returns an object containing callable functions.</p>


<h3 class="exercise" id="x-register-functions">Registering functions</h3>

<p>Write a function that loads one or more files containing function definitions like this:</p>

<pre><code class="language-js">const double = (x) =&gt; {
  return 2 * x
}

EXPORTS.append(double)
</code></pre>

<p class="continue">and returns a list containing all the loaded functions.</p>


<h3 class="exercise" id="x-indent-inclusions">Indenting inclusions</h3>

<p>Modify the file inclusion system
so that inclusions are indented by the same amount as the including comment.
For example,
if the including file is:</p>

<pre><code class="language-js">const withLogging = (args) =&gt; {
  /*+ logging call + logging.js +*/
}

withLogging
</code></pre>

<p class="continue">and the included file is:</p>

<pre><code class="language-js">console.log('first message')
console.log('second message')
</code></pre>

<p class="continue">then the result will be:</p>

<pre><code class="language-js">const withLogging = (args) =&gt; {
  console.log('first message')
  console.log('second message')
}

withLogging
</code></pre>

<p class="continue">i.e., all lines of the inclusion will be indented to match the first.</p>


<h3 class="exercise" id="x-interpolate-anywhere">Interpolating from subdirectories</h3>

<p>Modify the file interpolator so that snippets can be included from sub-directories using relative paths.</p>


<h3 class="exercise" id="x-recursive-search">Recursive search for inclusions</h3>
<ol>
  <li>
    <p>Modify the file interpolator so that it searches recursively
through all subdirectories of the directories on the search path
to find inclusions.</p>
  </li>
  <li>
    <p>Explain why this is a bad idea.</p>
  </li>
</ol>

<h3 class="exercise" id="x-define-variables">Defining variables</h3>

<p>Modify the file inclusion system so that users can pass in a <code>Map</code> containing name-value pairs
and have these interpolated into the text of the files being loaded.
To interpolate a value,
the included file must use <code>@@name@@</code>.</p>


<h3 class="exercise" id="x-specify-markers">Specifying markers</h3>

<p>Modify the file inclusion system so that the user can override the inclusion comment markers.
For example, the user should be able to specify that <code>/*!</code> and <code>!*/</code> be used to mark inclusions.
(This is often used in tutorials that need to show the inclusion markers without them being interpreted.)</p>


<h3 class="exercise" id="x-import-recursive">Recursive inclusions</h3>

<p>Modify the file interpolator to support recursive includes,
i.e.,
to handle inclusion markers in files that are being included.
Be sure to check for the case of infinite includes.</p>


<h3 class="exercise" id="x-slice-files">Slicing files</h3>

<p>Write a function that reads a JavaScript source file
containing specially-formatted comments like the ones shown below
and extracts the indicated section.</p>

<pre><code class="language-js">const toBeLeftOut = (args) =&gt; {
  console.log('this should not appear')
}

// &lt;keepThis&gt;
const toBeKept = (args) =&gt; {
  console.log('only this function should appear')
}
// &lt;/keepThis&gt;
</code></pre>

<p>Users should be able to specify any tag they want,
and if that tag occurs multiple times,
all of the sections marked with that tag should be kept.
(This is the approach we took for this book instead of file interpolation.)</p>




      </main>
      <footer>
  <hr/>
  <small>
    <span class="copyright"><i class="far fa-copyright"></i> <time datetime="2020-01-01">2020</time>-<time datetime="2022-03-14T08:04:08-04:00">2022</time> Greg Wilson</span>
    &middot;
    <span>Powered by <a href="http://jekyllrb.com/">Jekyll</a></span>
    &middot;
    <span>Last built 2022-03-14 08:04:08 -0400</span>
  </small>
  <div class="ftr-links">
    <a href="mailto:gvwilson@third-bit.com" aria-label="Mail the author"><i class="far fa-envelope" aria-hidden="true"></i></a>
    |
    <a href="https://github.com/gvwilson" aria-label="Author's GitHub repository"><i class="fab fa-github" aria-hidden="true"></i></a>
    <a href="https://twitter.com/gvwilson" aria-label="Author's Twitter feed"><i class="fab fa-twitter" aria-hidden="true"></i></a>
    <a href="https://www.linkedin.com/in/greg-wilson-a26510b6/" aria-label="Author's LinkedIn profile"><i class="fab fa-linkedin-in" aria-hidden="true"></i></a>
    |
    <a href="/license/" aria-label="License"><i class="fab fa-creative-commons-by" aria-hidden="true"></i><i class="fab fa-creative-commons-nc" aria-hidden="true"></i><img src="/static/hippocratic.svg" alt="Hippocratic License logo" class="iconlink" /></a>
  </div>
</footer>

    </div>
  </body>
</html>
