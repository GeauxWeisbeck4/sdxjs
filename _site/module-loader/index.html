<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,400italic|Source+Code+Pro:400,700" type="text/css">
  <script src="https://kit.fontawesome.com/fbb4c3a0bc.js" crossorigin="anonymous"></script>
  <script defer data-domain="stjs.tech" src="https://plausible.io/js/plausible.js"></script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" } }
  })
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <title>Software Tools in JavaScript</title>
  <link href="/static/local.css" rel="stylesheet" type="text/css">
  <script src="/static/local.js"></script>
  <script>
  const ENTRIES = {"introduction": { title: "Introduction", label: "Chapter 1" },"systems-programming": { title: "Systems Programming", label: "Chapter 2" },"async-programming": { title: "Asynchronous Programming", label: "Chapter 3" },"unit-test": { title: "Unit Testing", label: "Chapter 4" },"file-backup": { title: "File Backup", label: "Chapter 5" },"data-table": { title: "Data Tables", label: "Chapter 6" },"pattern-matching": { title: "Pattern Matching", label: "Chapter 7" },"regex-parser": { title: "Parsing Expressions", label: "Chapter 8" },"page-templates": { title: "Page Templates", label: "Chapter 9" },"build-manager": { title: "Build Manager", label: "Chapter 10" },"layout-engine": { title: "Layout Engine", label: "Chapter 11" },"file-interpolator": { title: "File Interpolator", label: "Chapter 12" },"module-loader": { title: "Module Loader", label: "Chapter 13" },"style-checker": { title: "Style Checker", label: "Chapter 14" },"code-generator": { title: "Code Generator", label: "Chapter 15" },"doc-generator": { title: "Documentation Generator", label: "Chapter 16" },"module-bundler": { title: "Module Bundler", label: "Chapter 17" },"package-manager": { title: "Package Manager", label: "Chapter 18" },"virtual-machine": { title: "Virtual Machine", label: "Chapter 19" },"debugger": { title: "Debugger", label: "Chapter 20" },"conclusion": { title: "Conclusion", label: "Chapter 21" },"license": { title: "Licensing", label: "Appendix A" },"bibliography": { title: "Bibliography", label: "Appendix B" },"conduct": { title: "Code of Conduct", label: "Appendix C" },"contributing": { title: "Contributing", label: "Appendix D" },"glossary": { title: "Glossary", label: "Appendix E" },"links": { title: "Links", label: "Appendix F" },"authors": { title: "Authors", label: "Appendix G" },"index": { title: "Index", label: "Appendix H" }}
  const FIGURES = {"async-programming-chained": "3.4","async-programming-event-loop": "3.1","async-programming-handling-errors": "3.6","async-programming-resolve": "3.3","async-programming-set-timeout": "3.2","async-programming-temporary-named-fields": "3.5","build-manager-compiling": "10.1","build-manager-dependencies": "10.2","build-manager-pattern-rules": "10.4","build-manager-template-method": "10.3","code-generator-spread": "15.1","data-table-col-ops": "6.4","data-table-conceptual": "6.1","data-table-object-storage": "6.5","data-table-packed-storage": "6.6","data-table-row-ops": "6.3","data-table-storage-order": "6.2","debugger-initialization": "20.1","debugger-test-interact": "20.2","doc-generator-comments": "16.1","doc-generator-fill-in-headers": "16.4","doc-generator-mapping": "16.3","doc-generator-process-plain": "16.2","file-backup-hash-function": "5.1","file-backup-mock-fs": "5.4","file-backup-storage": "5.3","file-backup-streaming": "5.2","file-interpolator-cache": "12.3","file-interpolator-conceptual": "12.1","file-interpolator-eval": "12.2","file-interpolator-search-path": "12.4","layout-engine-coordinate-system": "11.1","layout-engine-draw-over": "11.4","layout-engine-layout": "11.3","layout-engine-sizing": "11.2","layout-engine-wrap": "11.5","module-bundler-bundling": "17.1","module-bundler-complicated": "17.2","module-bundler-head-tail": "17.5","module-bundler-returning-functions": "17.6","module-bundler-structure": "17.4","module-bundler-transitive-closure": "17.3","module-loader-circularity": "13.3","module-loader-closures": "13.1","module-loader-iife": "13.2","package-manager-allowable": "18.1","package-manager-pruning": "18.2","page-templates-comprehension": "9.10","page-templates-options": "9.1","page-templates-output-conditional": "9.8","page-templates-output-loop": "9.9","page-templates-output-multiple-variables": "9.7","page-templates-output-single-constant": "9.5","page-templates-output-single-variable": "9.6","page-templates-output-static-text": "9.4","page-templates-stack": "9.2","page-templates-visitor": "9.3","pattern-matching-dom-tree": "7.1","pattern-matching-greedy-failure": "7.4","pattern-matching-query-selectors": "7.2","pattern-matching-regex-objects": "7.3","pattern-matching-rest": "7.5","regex-parser-expression-tree": "8.1","regex-parser-finite-state-machine": "8.3","regex-parser-mechanics": "8.2","style-checker-iterator": "14.3","style-checker-parse-tree": "14.1","style-checker-walk-tree": "14.2","systems-programming-anonymous-functions": "2.4","systems-programming-array-filter": "2.6","systems-programming-callbacks": "2.2","systems-programming-destructuring-assignment": "2.7","systems-programming-execution-order": "2.3","systems-programming-globbing": "2.5","systems-programming-process-argv": "2.1","systems-programming-triple-callback": "2.8","unit-test-hope-structure": "4.2","unit-test-lifecycle": "4.3","unit-test-mental-model": "4.1","virtual-machine-architecture": "19.1","virtual-machine-count-up": "19.3","virtual-machine-storage-allocation": "19.5","virtual-machine-trace-counter": "19.4","virtual-machine-unpacking": "19.2"}
  const TABLES = {"data-table-performance": "6.1","package-manager-example-dependencies": "18.1","package-manager-example-result": "18.2","package-manager-exclusions": "18.3","pattern-matching-cases": "7.2","pattern-matching-supported": "7.1","regex-parser-grammar-codes": "8.1","systems-programming-times": "2.1","virtual-machine-op-codes": "19.1"}
</script>

  <script>window.onload = () => fixPage()</script>
</head>

  <body >
    <nav class="nav-main">
  <ul>
    <li><a href="/" aria-label="Home"><em>Software Tools in JavaScript</em></a></li>
    <li><div class="dropdown">
<span class="navtitle">▿ Chapters</span>
<div class="dropdown-content" id="Chapters"><a class="dropdown-item" href="/introduction/"><span class="nowrap">Introduction</span></a><br/><a class="dropdown-item" href="/systems-programming/"><span class="nowrap">Systems Programming</span></a><br/><a class="dropdown-item" href="/async-programming/"><span class="nowrap">Asynchronous Programming</span></a><br/><a class="dropdown-item" href="/unit-test/"><span class="nowrap">Unit Testing</span></a><br/><a class="dropdown-item" href="/file-backup/"><span class="nowrap">File Backup</span></a><br/><a class="dropdown-item" href="/data-table/"><span class="nowrap">Data Tables</span></a><br/><a class="dropdown-item" href="/pattern-matching/"><span class="nowrap">Pattern Matching</span></a><br/><a class="dropdown-item" href="/regex-parser/"><span class="nowrap">Parsing Expressions</span></a><br/><a class="dropdown-item" href="/page-templates/"><span class="nowrap">Page Templates</span></a><br/><a class="dropdown-item" href="/build-manager/"><span class="nowrap">Build Manager</span></a><br/><a class="dropdown-item" href="/layout-engine/"><span class="nowrap">Layout Engine</span></a><br/><a class="dropdown-item" href="/file-interpolator/"><span class="nowrap">File Interpolator</span></a><br/><a class="dropdown-item" href="/module-loader/"><span class="nowrap">Module Loader</span></a><br/><a class="dropdown-item" href="/style-checker/"><span class="nowrap">Style Checker</span></a><br/><a class="dropdown-item" href="/code-generator/"><span class="nowrap">Code Generator</span></a><br/><a class="dropdown-item" href="/doc-generator/"><span class="nowrap">Documentation Generator</span></a><br/><a class="dropdown-item" href="/module-bundler/"><span class="nowrap">Module Bundler</span></a><br/><a class="dropdown-item" href="/package-manager/"><span class="nowrap">Package Manager</span></a><br/><a class="dropdown-item" href="/virtual-machine/"><span class="nowrap">Virtual Machine</span></a><br/><a class="dropdown-item" href="/debugger/"><span class="nowrap">Debugger</span></a><br/><a class="dropdown-item" href="/conclusion/"><span class="nowrap">Conclusion</span></a></div>
</div>
</li>
    <li><div class="dropdown">
<span class="navtitle">▿ Appendices</span>
<div class="dropdown-content" id="Appendices"><a class="dropdown-item" href="/license/"><span class="nowrap">Licensing</span></a><br/><a class="dropdown-item" href="/bibliography/"><span class="nowrap">Bibliography</span></a><br/><a class="dropdown-item" href="/conduct/"><span class="nowrap">Code of Conduct</span></a><br/><a class="dropdown-item" href="/contributing/"><span class="nowrap">Contributing</span></a><br/><a class="dropdown-item" href="/glossary/"><span class="nowrap">Glossary</span></a><br/><a class="dropdown-item" href="/links/"><span class="nowrap">Links</span></a><br/><a class="dropdown-item" href="/authors/"><span class="nowrap">Authors</span></a><br/><a class="dropdown-item" href="/index/"><span class="nowrap">Index</span></a></div>
</div>
</li>
  </ul>
</nav>

    <div class="container content">
      
<header>
  <h1 class="page-title" slug="module-loader">Module Loader</h1>
  <h2 class="lede">Loading source files as modules</h2>
</header>


      <main>
        <ul class="toc"></ul>
        <div class="terms"><p><strong>Terms defined:</strong> <span g="absolute_path">absolute path</span>, <span g="alias">alias</span>, <span g="circular_dependency">circular dependency</span>, <span g="closure">closure</span>, <span g="directed_graph">directed graph</span>, <span g="encapsulate">encapsulate</span>, <span g="iife">immediately-invoked function expression</span>, <span g="inner_function">inner function</span>, <span g="namespace">namespace</span>, <span g="plugin_architecture">plugin architecture</span></p>
</div>
        <p><span x="file-interpolator"></span> showed how to use <code>eval</code> to load code dynamically.
We can use this to build our own version of JavaScript's <code>require</code> function.
Our function will take the name of a source file as an argument
and return whatever that file exports.
The key requirement for such a function is to avoid accidentally overwriting things:
if we just <code>eval</code> some code and it happens to assign to a variable called <code>x</code>,
anything called <code>x</code> already in our program might be overwritten.
We therefore need a way to <span g="encapsulate" i="encapsulation; software design!encapsulation">encapsulate</span> the contents of what we're loading.
Our approach is based on <cite>Casciaro2020</cite>,
which contains a lot of other useful information as well.</p>

<h2 id="how-can-we-implement-namespaces">How can we implement namespaces?</h2>

<p>A <span g="namespace" i="namespace">namespace</span> is a collection of names in a program
that are isolated from other namespaces.
Most modern languages provide namespaces as a built-in feature
so that programmers don't accidentally step on each other's toes.
JavaScript doesn't,
so we have to implement them ourselves.</p>

<p>We can do this using <span g="closure" i="closure">closures</span>.
Every function is a namespace:
variables defined inside the function are distinct from variables defined outside it
(<span f="module-loader-closures"></span>).
If we create the variables we want to manage inside a function,
then defined another function inside the first
and return that <span g="inner_function" i="inner function; function!inner">inner function</span>,
that inner function will be the only thing with references to those variables.</p>

<figure id="module-loader-closures" slug="module-loader">
  <img src="figures/closures.svg" alt="How closures work" />
  <figcaption>Using closures to create private variables.</figcaption>
</figure>

<p>For example,
let's create a function that always appends the same string to its argument:</p>

<pre class="language-js" title="manual-namespacing.js"><code class="language-js">const createAppender = (suffix) =&gt; {
  const appender = (text) =&gt; {
    return text + suffix
  }
  return appender
}

const exampleFunction = createAppender(' and that')
console.log(exampleFunction('this'))
console.log('suffix is', suffix)

</code><div class="file-link"><a href="manual-namespacing.js">manual-namespacing.js</a></div></pre>

<p class="continue">When we run it,
the value that was assigned to the parameter <code>suffix</code> still exists
but can only be reached by the inner function:</p>

<pre class="language-out" title="manual-namespacing.out"><code class="language-out">this and that
/u/stjs/module-loader/manual-namespacing.js:10
console.log('suffix is', suffix)
                         ^

ReferenceError: suffix is not defined
    at /u/stjs/module-loader/manual-namespacing.js:10:26
    at ModuleJob.run (internal/modules/esm/module_job.js:152:23)
    at async Loader.import (internal/modules/esm/loader.js:166:24)
    at async Object.loadESM (internal/process/esm_loader.js:68:5)

</code><div class="file-link"><a href="manual-namespacing.out">manual-namespacing.out</a></div></pre>

<p>We could require every module to define a setup function like this for users to call,
but thanks to <code>eval</code> we can wrap the file's contents in a function and call it automatically.
To do this we will create something called
an <span g="iife" i="immediately-invoked function expression">immediately-invoked function expression</span> (IIFE).
The syntax <code>() =&gt; {...}</code> defines a function.
If we put the definition in parentheses and then put another pair of parentheses right after it:</p>

<pre><code class="language-js">(() =&gt; {...})()
</code></pre>

<p class="continue">we have code that defines a function of no arguments and immediately calls it.
We can use this trick to achieve the same effect as the previous example in one step:</p>

<pre class="language-js" title="automatic-namespacing.js"><code class="language-js">const contents = (() =&gt; {
  const privateValue = 'private value' 
  const publicValue = 'public value'
  return { publicValue }
})()

console.log(`contents.publicValue is ${contents.publicValue}`)
console.log(`contents.privateValue is ${contents.privateValue}`)

</code><div class="file-link"><a href="automatic-namespacing.js">automatic-namespacing.js</a></div></pre>
<pre class="language-out" title="automatic-namespacing.out"><code class="language-out">contents.publicValue is public value
contents.privateValue is undefined

</code><div class="file-link"><a href="automatic-namespacing.out">automatic-namespacing.out</a></div></pre>

<div class="callout">

  <h3 id="unconfusing-the-parser">Unconfusing the parser</h3>

  <p>The extra parentheses around the original definition force the parser to evaluate things in the right order;
if we write:</p>

  <pre><code class="language-js">() =&gt; {...}()
</code></pre>

  <p class="continue">then JavaScript interprets it as a function definition followed by an empty expression
rather than an immediate call to the function just defined.</p>

</div>

<h2 id="how-can-we-load-a-module">How can we load a module?</h2>

<p>We want the module we are loading to export names by assigning to <code>module.exports</code> just as <code>require</code> does,
so we need to provide an object called <code>module</code> and create a IIFE.
(We will handle the problem of the module loading other modules later.)
Our <code>loadModule</code> function takes a filename and returns a newly-created module object;
the parameter to the function we build and <code>eval</code> must be called <code>module</code> so that we can assign to <code>module.exports</code>.
For clarity,
we call the object we pass in <code>result</code> in <code>loadModule</code>.</p>

<pre class="language-js" title="load-module-only.js"><code class="language-js">import fs from 'fs'

const loadModule = (filename) =&gt; {
  const source = fs.readFileSync(filename, 'utf-8')
  const result = {}
  const fullText = `((module) =&gt; {${source}})(result)`
  console.log(`full text for eval:\n${fullText}\n`)
  eval(fullText)
  return result.exports
}

export default loadModule

</code><div class="file-link"><a href="load-module-only.js">load-module-only.js</a></div></pre>

<figure id="module-loader-iife" slug="module-loader">
  <img src="figures/iife.svg" alt="Implementing modules with IIFEs" />
  <figcaption>Using IIFEs to encapsulate modules and get their exports.</figcaption>
</figure>

<p><span f="module-loader-iife"></span> shows the structure of our loader so far.
We can use this code as a test:</p>

<pre class="language-js" title="small-module.js"><code class="language-js">const publicValue = 'public value'

const privateValue = 'private value'

const publicFunction = (caller) =&gt; {
  return `publicFunction called from ${caller}`
}

module.exports = { publicValue, publicFunction }

</code><div class="file-link"><a href="small-module.js">small-module.js</a></div></pre>

<p class="continue">and this short program to load the test and check its exports:</p>

<pre class="language-js" title="test-load-module-only.js"><code class="language-js">import loadModule from './load-module-only.js'

const result = loadModule(process.argv[2])
console.log(`result.publicValue is ${result.publicValue}`)
console.log(`result.privateValue is ${result.privateValue}`)
console.log(result.publicFunction('main'))

</code><div class="file-link"><a href="test-load-module-only.js">test-load-module-only.js</a></div></pre>
<pre class="language-sh" title="test-load-module-only.sh"><code class="language-sh">node test-load-module-only.js small-module.js

</code><div class="file-link"><a href="test-load-module-only.sh">test-load-module-only.sh</a></div></pre>
<pre class="language-out" title="test-load-module-only.out"><code class="language-out">full text for eval:
((module) =&gt; {const publicValue = 'public value'

const privateValue = 'private value'

const publicFunction = (caller) =&gt; {
  return `publicFunction called from ${caller}`
}

module.exports = { publicValue, publicFunction }
})(result)

result.publicValue is public value
result.privateValue is undefined
publicFunction called from main

</code><div class="file-link"><a href="test-load-module-only.out">test-load-module-only.out</a></div></pre>

<h2 id="do-we-need-to-handle-circular-dependencies">Do we need to handle circular dependencies?</h2>

<p>What if the code we are loading loads other code?
We can visualize the network of who requires whom as a <span g="directed_graph" i="directed graph">directed graph</span>:
if X requires Y,
we draw an arrow from X to Y.
Unlike the <span i="directed acyclic graph">directed <em>acyclic</em> graphs</span> we met in <span x="build-manager"></span>,
though,
these graphs can contain cycles:
we say a <span g="circular_dependency" i="circular dependency">circular dependency</span> exists
if X depends on Y and Y depends on X
either directly or indirectly.
This may seem nonsensical,
but can easily arise with <span g="plugin_architecture" i="plugin architecture; software design!plugin architecture">plugin architectures</span>:
the file containing the main program loads an extension,
and that extension calls utility functions defined in the file containing the main program.</p>

<p>Most compiled languages can handle circular dependencies easily:
they compile each module into low-level instructions,
then link those to resolve dependencies before running anything
(<span f="module-loader-circularity"></span>).
But interpreted languages usually run code as they're loading it,
so if X is in the process of loading Y and Y tries to call X,
X may not (fully) exist yet.</p>

<figure id="module-loader-circularity" slug="module-loader">
  <img src="figures/circularity.svg" alt="Circularity test case" />
  <figcaption>Testing circular imports.</figcaption>
</figure>

<p>Circular dependencies work in <span i="Python"><a href="https://www.python.org/" title="Python">Python</a></span>,
but only sort of.
Let's create two files called <code>major.py</code> and <code>minor.py</code>:</p>

<pre class="language-py" title="checking/major.py"><code class="language-py"># major.py

import minor

def top():
    print(&quot;top&quot;)
    minor.middle()

def bottom():
    print(&quot;bottom&quot;)

top()

</code><div class="file-link"><a href="checking/major.py">checking/major.py</a></div></pre>

<pre class="language-py" title="checking/minor.py"><code class="language-py"># minor.py

import major

def middle():
    print(&quot;middle&quot;)
    major.bottom()

</code><div class="file-link"><a href="checking/minor.py">checking/minor.py</a></div></pre>

<p>Loading fails when we run <code>major.py</code> from the command line:</p>

<pre class="language-out" title="checking/py-command-line.out"><code class="language-out">top
Traceback (most recent call last):
  File &quot;major.py&quot;, line 3, in &lt;module&gt;
    import minor
  File &quot;/u/stjs/module-loader/checking/minor.py&quot;, line 3, in &lt;module&gt;
    import major
  File &quot;/u/stjs/module-loader/checking/major.py&quot;, line 12, in &lt;module&gt;
    top()
  File &quot;/u/stjs/module-loader/checking/major.py&quot;, line 7, in top
    minor.middle()
AttributeError: module 'minor' has no attribute 'middle'

</code><div class="file-link"><a href="checking/py-command-line.out">checking/py-command-line.out</a></div></pre>

<p class="continue">but works in the interactive interpreter:</p>

<pre class="language-out" title="checking/py-interactive.out"><code class="language-out">$ python
&gt;&gt;&gt; import major
top
middle
bottom

</code><div class="file-link"><a href="checking/py-interactive.out">checking/py-interactive.out</a></div></pre>

<p>The equivalent test in JavaScript also has two files:</p>

<pre class="language-js" title="checking/major.js"><code class="language-js">// major.js
const { middle } = require('./minor')

const top = () =&gt; {
  console.log('top')
  middle()
}

const bottom = () =&gt; {
  console.log('bottom')
}

top()

module.exports = { top, bottom }

</code><div class="file-link"><a href="checking/major.js">checking/major.js</a></div></pre>

<pre class="language-js" title="checking/minor.js"><code class="language-js">// minor.js
const { bottom } = require('./major')

const middle = () =&gt; {
  console.log('middle')
  bottom()
}

module.exports = { middle }

</code><div class="file-link"><a href="checking/minor.js">checking/minor.js</a></div></pre>

<p class="continue">It fails on the command line:</p>

<pre class="language-out" title="checking/js-command-line.out"><code class="language-out">top
middle
/u/stjs/module-loader/checking/minor.js:6
  bottom()
  ^

TypeError: bottom is not a function
    at middle (/u/stjs/module-loader/checking/minor.js:6:3)
    at top (/u/stjs/module-loader/checking/major.js:6:3)
    at Object.&lt;anonymous&gt; (/u/stjs/module-loader/checking/major.js:13:1)
    at Module._compile (internal/modules/cjs/loader.js:1063:30)
    at Object.Module._extensions..js \
 (internal/modules/cjs/loader.js:1092:10)
    at Module.load (internal/modules/cjs/loader.js:928:32)
    at Function.Module._load (internal/modules/cjs/loader.js:769:14)
    at Function.executeUserEntryPoint [as runMain] \
 (internal/modules/run_main.js:72:12)
    at internal/main/run_main_module.js:17:47

</code><div class="file-link"><a href="checking/js-command-line.out">checking/js-command-line.out</a></div></pre>

<p class="continue">and also fails in the interactive interpreter
(which is more consistent):</p>

<pre class="language-out" title="checking/js-interactive.out"><code class="language-out">$ node
&gt; require('./major')
top
middle
/u/stjs/module-loader/checking/minor.js:6
  bottom()
  ^

TypeError: bottom is not a function
    at middle (/u/stjs/module-loader/checking/minor.js:6:3)
    at top (/u/stjs/module-loader/checking/major.js:6:3)
    at Object.&lt;anonymous&gt; (/u/stjs/module-loader/checking/major.js:13:1)
    at Module._compile (internal/modules/cjs/loader.js:1063:30)
    at Object.Module._extensions..js \
 (internal/modules/cjs/loader.js:1092:10)
    at Module.load (internal/modules/cjs/loader.js:928:32)
    at Function.Module._load (internal/modules/cjs/loader.js:769:14)
    at Module.require (internal/modules/cjs/loader.js:952:19)
    at require (internal/modules/cjs/helpers.js:88:18)
    at [stdin]:1:1

</code><div class="file-link"><a href="checking/js-interactive.out">checking/js-interactive.out</a></div></pre>

<p>We therefore won't try to handle circular dependencies.
However,
we will detect them and generate a sensible error message.</p>

<div class="callout">

  <h3 id="import-vs-require"><code>import</code> vs. <code>require</code></h3>

  <p>Circular dependencies work JavaScript's <code>import</code> syntax
because we can analyze files to determine what needs what,
get everything into memory,
and then resolve dependencies.
We can't do this with <code>require</code>-based code
because someone might create an <span g="alias" i="alias!during import; import!alias">alias</span>
and call <code>require</code> through that
or <code>eval</code> a string that contains a <code>require</code> call.
(Of course, they can also do these things with the function version of <code>import</code>.)</p>

</div>

<h2 id="how-can-a-module-load-another-module">How can a module load another module?</h2>

<p>While we're not going to handle circular dependencies,
modules do need to be able to load other modules.
To enable this,
we need to provide the module with a function called <code>require</code>
that it can call as it's loading.
As in <span x="file-interpolator"></span>,
this function checks a <span i="cache!of loaded files">cache</span>
to see if the file being asked for has already been loaded.
If not, it loads it and saves it;
either way, it returns the result.</p>

<p>Our cache needs to be careful about how it identifies files
so that it can detect duplicates loading attempts that use different names.
For example,
suppose that <code>major.js</code> loads <code>subdir/first.js</code> and <code>subdir/second.js</code>.
When <code>subdir/second.js</code> loads <code>./first.js</code>,
our system needs to realize that it already has that file
even though the path looks different.
We will use <span g="absolute_path">absolute paths</span> as cache keys
so that every file has a unique, predictable key.</p>

<p>To reduce confusion,
we will call our function <code>need</code> instead of <code>require</code>.
In order to make the cache available to modules while they're loading,
we will make it a property of <code>need</code>.
(Remember,
a function is just another kind of object in JavaScript;
every function gets several properties automatically,
and we can always add more.)
Since we're using the built-in <code>Map</code> class as a cache,
the entire implementation of <code>need</code> is just 15 lines long:</p>

<pre class="language-js" title="need.js"><code class="language-js">import path from 'path'

import loadModule from './load-module.js'

const need = (name) =&gt; {
  const absPath = path.resolve(name)
  if (!need.cache.has(absPath)) {
    const contents = loadModule(absPath, need)
    need.cache.set(absPath, contents)
  }
  return need.cache.get(absPath)
}
need.cache = new Map()

export default need

</code><div class="file-link"><a href="need.js">need.js</a></div></pre>

<p>We now need to modify <code>loadModule</code> to take our function <code>need</code> as a parameter.
(Again, we'll have our modules call <code>need('something.js')</code> instead of <code>require('something')</code> for clarity.)
Let's test it with the same small module that doesn't need anything else to make sure we haven't broken anything:</p>

<pre class="language-js" title="test-need-small-module.js"><code class="language-js">import need from './need.js'

const small = need('small-module.js')
console.log(`small.publicValue is ${small.publicValue}`)
console.log(`small.privateValue is ${small.privateValue}`)
console.log(small.publicFunction('main'))

</code><div class="file-link"><a href="test-need-small-module.js">test-need-small-module.js</a></div></pre>
<pre class="language-out" title="test-need-small-module.out"><code class="language-out">full text for eval:
((module, need) =&gt; {
const publicValue = 'public value'

const privateValue = 'private value'

const publicFunction = (caller) =&gt; {
  return `publicFunction called from ${caller}`
}

module.exports = { publicValue, publicFunction }

})(result, need)

small.publicValue is public value
small.privateValue is undefined
publicFunction called from main

</code><div class="file-link"><a href="test-need-small-module.out">test-need-small-module.out</a></div></pre>

<p>What if we test it with a module that <em>does</em> load something else?</p>

<pre class="language-js" title="large-module.js"><code class="language-js">import need from './need'

const small = need('small-module.js')

const large = (caller) =&gt; {
  console.log(`large from ${caller}`)
  small.publicFunction(`${caller} to large`)
}

export default large

</code><div class="file-link"><a href="large-module.js">large-module.js</a></div></pre>

<pre class="language-js" title="test-need-large-module.js"><code class="language-js">import need from './need.js'

const large = need('large-module.js')
console.log(large.large('main'))

</code><div class="file-link"><a href="test-need-large-module.js">test-need-large-module.js</a></div></pre>
<pre class="language-out" title="test-need-large-module.out"><code class="language-out">full text for eval:
((module, need) =&gt; {
import need from './need'

const small = need('small-module.js')

const large = (caller) =&gt; {
  console.log(`large from ${caller}`)
  small.publicFunction(`${caller} to large`)
}

export default large

})(result, need)

undefined:2
import need from './need'
^^^^^^

SyntaxError: Cannot use import statement outside a module
    at loadModule (/u/stjs/module-loader/load-module.js:8:8)
    at need (/u/stjs/module-loader/need.js:8:22)
    at /u/stjs/module-loader/test-need-large-module.js:3:15
    at ModuleJob.run (internal/modules/esm/module_job.js:152:23)
    at async Loader.import (internal/modules/esm/loader.js:166:24)
    at async Object.loadESM (internal/process/esm_loader.js:68:5)

</code><div class="file-link"><a href="test-need-large-module.out">test-need-large-module.out</a></div></pre>

<p>This doesn't work because <code>import</code> only works at the top level of a program,
not inside a function.
Our system can therefore only run loaded modules by <code>need</code>ing them:</p>

<pre class="language-js" title="large-needless.js"><code class="language-js">const small = need('small-module.js')

const large = (caller) =&gt; {
  return small.publicFunction(`large called from ${caller}`)
}

module.exports = large

</code><div class="file-link"><a href="large-needless.js">large-needless.js</a></div></pre>

<pre class="language-js" title="test-need-large-needless.js"><code class="language-js">import need from './need.js'

const large = need('large-needless.js')
console.log(large('main'))

</code><div class="file-link"><a href="test-need-large-needless.js">test-need-large-needless.js</a></div></pre>
<pre class="language-out" title="test-need-large-needless.out"><code class="language-out">full text for eval:
((module, need) =&gt; {
const small = need('small-module.js')

const large = (caller) =&gt; {
  return small.publicFunction(`large called from ${caller}`)
}

module.exports = large

})(result, need)

full text for eval:
((module, need) =&gt; {
const publicValue = 'public value'

const privateValue = 'private value'

const publicFunction = (caller) =&gt; {
  return `publicFunction called from ${caller}`
}

module.exports = { publicValue, publicFunction }

})(result, need)

publicFunction called from large called from main

</code><div class="file-link"><a href="test-need-large-needless.out">test-need-large-needless.out</a></div></pre>

<div class="callout">

  <h3 id="its-so-deep-its-meaningless">"It's so deep it's meaningless"</h3>

  <p>The programs we have written in this chapter are harder to understand
than most of the programs in earlier chapters
because they are so abstract.
Reading through them,
it's easy to get the feeling that everything is happening somewhere else.
Programmers' tools are often like this:
there's always a risk of confusing the thing in the program
with the thing the program is working on.
Drawing pictures of data structures can help,
and so can practicing with closures
(which are one of the most powerful ideas in programming),
but a lot of the difficulty is irreducible,
so don't feel bad if it takes you a while to wrap your head around it.</p>

</div>

        
        <h2 id="exercises">Exercises</h2>

<h3 class="exercise" id="x-closure-counter">Counting with closures</h3>

<p>Write a function <code>makeCounter</code> that returns a function
that produces the next integer in sequence starting from zero each time it is called.
Each function returned by <code>makeCounter</code> must count independently, so:</p>

<pre><code class="language-js">left = makeCounter()
right = makeCounter()
console.log(`left ${left()`)
console.log(`right ${right()`)
console.log(`left ${left()`)
console.log(`right ${right()`)
</code></pre>

<p class="continue">must produce:</p>

<pre><code class="language-txt">left 0
right 0
left 1
right `
</code></pre>


<h3 class="exercise" id="x-object-namespace">Objects and namespaces</h3>

<p>A JavaScript object stores key-value pairs,
and the keys in one object are separate from the keys in another.
Why doesn't this provide the same level of safety as a closure?</p>


<h3 class="exercise" id="x-testing-need">Testing module loading</h3>

<p>Write tests for <code>need.js</code> using Mocha and <code>mock-fs</code>.</p>


<h3 class="exercise" id="x-using-module">Using <code>module</code> as a name</h3>

<p>What happens if we define the variable <code>module</code> in <code>loadModule</code>
so that it is in scope when <code>eval</code> is called
rather than creating a variable called <code>result</code> and passing that in:</p>

<pre><code class="language-js">const loadModule = (filename) =&gt; {
  const source = fs.readFileSync(filename, 'utf-8')
  const module = {}
  const fullText = `(() =&gt; {${source}})()`
  eval(fullText)
  return module.exports
}
</code></pre>


<h3 class="exercise" id="x-search-path">Implementing a search path</h3>

<p>Add a search path to <code>need.js</code> so that if a module isn't found locally,
it will be looked for in each directory in the search path in order.</p>


<h3 class="exercise" id="x-setup-function">Using a setup function</h3>

<p>Rewrite the module loader so that every module has a function called <code>setup</code>
that must be called after loading it to create its exports
rather than using <code>module.exports</code>.</p>


<h3 class="exercise" id="x-handling-errors">Handling errors while loading</h3>

<ol>
  <li>
    <p>Modify <code>need.js</code> so that it does something graceful
if an exception is thrown while a module is being loaded.</p>
  </li>
  <li>
    <p>Write unit tests for this using Mocha.</p>
  </li>
</ol>


<h3 class="exercise" id="x-refactoring-circularity">Refactoring circularity</h3>
<p>Suppose that <code>main.js</code> contains this:</p>

<pre class="language-js" title="x-refactoring-circularity/main.js"><code class="language-js">const PLUGINS = []

const plugin = require('./plugin')

const main = () =&gt; {
  PLUGINS.forEach(p =&gt; p())
}

const loadPlugin = (plugin) =&gt; {
  PLUGINS.push(plugin)
}

module.exports = {
  main,
  loadPlugin
}

</code><div class="file-link"><a href="x-refactoring-circularity/main.js">x-refactoring-circularity/main.js</a></div></pre>

<p class="continue">and <code>plugin.js</code> contains this:</p>

<pre class="language-js" title="x-refactoring-circularity/plugin.js"><code class="language-js">const { loadPlugin } = require('./main')

const printMessage = () =&gt; {
  console.log('running plugin')
}

loadPlugin(printMessage)

</code><div class="file-link"><a href="x-refactoring-circularity/plugin.js">x-refactoring-circularity/plugin.js</a></div></pre>

<p class="continue">Refactor this code so that it works correctly while still using <code>require</code> rather than <code>import</code>.</p>

<h3 class="exercise" id="x-lru-cache">An LRU cache</h3>

<p>A <span g="lru_cache">Least Recently Used (LRU) cache</span>
reduces access time while limiting the amount of memory used
by keeping track of the N items that have been used most recently.
For example,
if the cache size is 3 and objects are accessed in the order shown in the first column,
the cache's contents will be as shown in the second column:</p>

<div class="latex" command="\vspace{\baselineskip}" />

<table>
  <thead>
    <tr>
      <th>Item</th>
      <th>Action</th>
      <th>Cache After Access</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>A</td>
      <td>read A</td>
      <td>[A]</td>
    </tr>
    <tr>
      <td>A</td>
      <td>get A from cache</td>
      <td>[A]</td>
    </tr>
    <tr>
      <td>B</td>
      <td>read B</td>
      <td>[B, A]</td>
    </tr>
    <tr>
      <td>A</td>
      <td>get A from cache</td>
      <td>[A, B]</td>
    </tr>
    <tr>
      <td>C</td>
      <td>read C</td>
      <td>[C, A, B]</td>
    </tr>
    <tr>
      <td>D</td>
      <td>read D</td>
      <td>[D, C, A]</td>
    </tr>
    <tr>
      <td>B</td>
      <td>read B</td>
      <td>[B, D, C]</td>
    </tr>
  </tbody>
</table>

<ol>
  <li>
    <p>Implement a function <code>cachedRead</code> that takes the number of entries in the cache as an argument
and returns a function that uses an LRU cache
to either read files or return cached copies.</p>
  </li>
  <li>
    <p>Modify <code>cachedRead</code> so that the number of items in the cache
is determined by their combined size
rather than by the number of files.</p>
  </li>
</ol>


<h3 class="exercise" id="x-need-rename">Make functions safe for renaming</h3>

<p>Our implementation of <code>need</code> implemented the cache as a property of the function itself.</p>

<ol>
  <li>
    <p>How can this go wrong?
(Hint: thing about aliases.)</p>
  </li>
  <li>
    <p>Modify the implementation to solve this problem using a closure.</p>
  </li>
</ol>




      </main>
      <footer>
  <hr/>
  <small>
    <span class="copyright"><i class="far fa-copyright"></i> <time datetime="2020-01-01">2020</time>-<time datetime="2022-03-14T08:04:08-04:00">2022</time> Greg Wilson</span>
    &middot;
    <span>Powered by <a href="http://jekyllrb.com/">Jekyll</a></span>
    &middot;
    <span>Last built 2022-03-14 08:04:08 -0400</span>
  </small>
  <div class="ftr-links">
    <a href="mailto:gvwilson@third-bit.com" aria-label="Mail the author"><i class="far fa-envelope" aria-hidden="true"></i></a>
    |
    <a href="https://github.com/gvwilson" aria-label="Author's GitHub repository"><i class="fab fa-github" aria-hidden="true"></i></a>
    <a href="https://twitter.com/gvwilson" aria-label="Author's Twitter feed"><i class="fab fa-twitter" aria-hidden="true"></i></a>
    <a href="https://www.linkedin.com/in/greg-wilson-a26510b6/" aria-label="Author's LinkedIn profile"><i class="fab fa-linkedin-in" aria-hidden="true"></i></a>
    |
    <a href="/license/" aria-label="License"><i class="fab fa-creative-commons-by" aria-hidden="true"></i><i class="fab fa-creative-commons-nc" aria-hidden="true"></i><img src="/static/hippocratic.svg" alt="Hippocratic License logo" class="iconlink" /></a>
  </div>
</footer>

    </div>
  </body>
</html>
