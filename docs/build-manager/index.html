<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
  <title>Build Manager</title>
  <meta name="toRoot" content="..">
  <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
  <link href="../static/site.css" rel="stylesheet" type="text/css">
  <script src="../static/site.js"></script>
  <script>window.onload = () => fixPage()</script>
</head>
<body id="_top">
<nav>
<div class="row">
<div class="left2">
<a href="http://third-bit.com"><img src="../static/logo.svg" alt="site logo" class="site-logo"/></a>
<a href="../"><em>Software Tools in JavaScript</em></a>
</div>
<div class="right2">
<div class="dropdown">
<span class="navtitle">▿ Sections</span>
<div class="dropdown-content" id="Sections">
</div>
</div>
<div class="dropdown">
<span class="navtitle">▿ Chapters</span>
<div class="dropdown-content" id="Chapters">
<a href="../systems-programming/"><span class="nowrap">Systems Programming</span></a>
<br/><a href="../promises/"><span class="nowrap">Promises</span></a>
<br/><a href="../unit-test/"><span class="nowrap">Unit Testing</span></a>
<br/><a href="../file-backup/"><span class="nowrap">File Backup</span></a>
<br/><a href="../style-checker/"><span class="nowrap">Style Checker</span></a>
<br/><a href="../pattern-matching/"><span class="nowrap">Pattern Matching</span></a>
<br/><a href="../regex-parser/"><span class="nowrap">Parsing Expressions</span></a>
<br/><a href="../code-generator/"><span class="nowrap">Code Generator</span></a>
<br/><a href="../page-templates/"><span class="nowrap">Page Templates</span></a>
<br/><a href="../doc-generator/"><span class="nowrap">Documentation Generator</span></a>
<br/><a href="../file-interpolator/"><span class="nowrap">File Interpolator</span></a>
<br/><a href="../module-loader/"><span class="nowrap">Module Loader</span></a>
<br/><a href="../module-bundler/"><span class="nowrap">Module Bundler</span></a>
<br/><a href="../build-manager/"><span class="nowrap">Build Manager</span></a>
<br/><a href="../layout-engine/"><span class="nowrap">Layout Engine</span></a>
<br/><a href="../text-editor/"><span class="nowrap">Text Editor</span></a>
<br/><a href="../package-manager/"><span class="nowrap">Package Manager</span></a>
<br/><a href="../issue-tracker/"><span class="nowrap">Issue Tracker</span></a>
<br/><a href="../conclusion/"><span class="nowrap">Conclusion</span></a>
</div>
</div>
<div class="dropdown">
<span class="navtitle">▿ Appendices</span>
<div class="dropdown-content" id="Appendices">
<a href="../bib/"><span class="nowrap">Bibliography</span></a>
<br/><a href="../license/"><span class="nowrap">License</span></a>
<br/><a href="../conduct/"><span class="nowrap">Code of Conduct</span></a>
<br/><a href="../contributing/"><span class="nowrap">Contributing</span></a>
<br/><a href="../gloss/"><span class="nowrap">Glossary</span></a>
<br/><a href="../links/"><span class="nowrap">Links</span></a>
<br/><a href="../solutions/"><span class="nowrap">Solutions</span></a>
<br/><a href="../authors/"><span class="nowrap">Authors</span></a>
</div>
</div>
</div>
</div>
</nav>
  <main>
  <h1>Build Manager</h1>
  <p class="lede">Updating files that depend on other files</p>
<ul>
<li>Programs in <g key="compiled_language">compiled languages</g> like C and Java have to be built before they can be run
<ul>
<li>Translate each module into machine instructions</li>
<li><g key="link">Link</g> those modules to each other and to libraries</li>
</ul>
</li>
<li>If a source file hasn't changed, no need to recompile it before linking
<ul>
<li>Unless the interface of something it depends on has changed</li>
</ul>
</li>
<li>A <g key="build_manager">build manager</g>:
<ul>
<li>Takes a description of what depends on what</li>
<li>Figures out what is out of date</li>
<li>Figures out an order in which to rebuild things</li>
<li>Does what's necessary</li>
</ul>
</li>
<li>Not needed for programs in <g key="interpreted_language">interpreted languages</g>
<ul>
<li>But still very useful for managing complex workflows</li>
<li>Like building this book's website and PDF</li>
</ul>
</li>
<li>Based on <a href="https://www.gnu.org/software/make/">Make</a>, <a href="https://www.npmjs.com/package/bajel">Bajel</a>, <a href="https://jakejs.com/">Jake</a>, and <cite>Smith2011</cite></li>
</ul>
<h2 id="whats-in-a-build-manager">What's in a build manager?</h2>
<ul>
<li>Every rule has:
<ul>
<li>A <g key="build_target">target</g></li>
<li><g key="dependency">Dependencies</g></li>
<li><g key="build_recipe">Recipes</g></li>
</ul>
</li>
<li>Forms a <g key="dag">directed acyclic graph</g> (DAG)
<ul>
<li>Acyclic because if something depends on itself we can't ever finish updating it</li>
</ul>
</li>
<li>A target is <g key="build_stale">stale</g> if it is older than any of its dependencies
<ul>
<li>Use the recipes to bring it up to date</li>
</ul>
</li>
<li>So:
<ul>
<li>Read configuration</li>
<li>Construct dependency graph</li>
<li>Find out what nodes are stale</li>
<li>Build everything that depends on them in <g key="topological_order">topological order</g></li>
</ul>
</li>
</ul>
<h2 id="where-should-we-start">Where should we start?</h2>
<ul>
<li>Going to experiment with several of these so write a simple <g key="driver">driver</g>
<ul>
<li>Load a file</li>
<li>Create an instance of whatever class that file exports</li>
<li>Run that instance with the rest of the command-line parameters</li>
</ul>
</li>
</ul>
<pre title="driver.js"><code class="language-js">const BuilderClass = require(process.argv[2])
const builder = new BuilderClass(...process.argv.slice(3))
builder.build()
</code></pre>
<ul>
<li>Build files will look like this</li>
</ul>
<pre title="three-simple-rules.yml"><code class="language-yml">- target: A
  depends:
  - B
  - C
  recipes:
  - "update A from B and C"
- target: B
  depends:
  - C
  recipes:
  - "update B from C"
- target: C
  depends: []
  recipes: []
</code></pre>
<ul>
<li>Our classes must have:
<ul>
<li>A constructor that takes a configuration file as an argument</li>
<li>A <code>build</code> method</li>
</ul>
</li>
<li>The <code>build</code> method
<ul>
<li>Creates a graph from the configuration file</li>
<li>Checks that there are no cycles</li>
<li>Runs whatever commands are needed to update everything</li>
</ul>
</li>
<li>A very simple example of the <g key="template_method_pattern">Template Method</g> pattern
<ul>
<li>Parent class defines the order of the steps</li>
<li>Child class fills them in</li>
</ul>
</li>
</ul>
<pre title="skeleton-builder.js"><code class="language-js">const assert = require('assert')

class SkeletonBuilder {
  constructor (configFile) {
    this.configFile = configFile
  }

  build () {
    this.loadConfig()
    this.buildGraph()
    this.checkCycles()
    this.run()
  }

  loadConfig () {
    assert(false, 'not implemented')
  }

  buildGraph () {
    assert(false, 'not implemented')
  }

  checkCycles () {
    assert(false, 'not implemented')
  }

  run () {
    assert.fail('run method not implemented')
  }
}

module.exports = SkeletonBuilder
</code></pre>
<ul>
<li>Would normally implement all required methods at once
<ul>
<li>For tutorial purposes, do them one at a time to make code evolution more readable</li>
</ul>
</li>
<li>Load the configuration file during construction</li>
</ul>
<pre title="config-loader.js"><code class="language-js">const assert = require('assert')
const fs = require('fs')
const yaml = require('js-yaml')

const SkeletonBuilder = require('./skeleton-builder')

class ConfigLoader extends SkeletonBuilder {
  loadConfig () {
    this.config = yaml.safeLoad(fs.readFileSync(this.configFile, 'utf-8'))
    assert(Array.isArray(this.config),
      'Configuration must be array')
    this.config.forEach(rule =&gt; {
      assert(('target' in rule) &amp;&amp; (typeof rule.target === 'string'),
        `Rule ${JSON.stringify(rule)} does not string as 'target'`)
      assert(('depends' in rule) &amp;&amp;
        Array.isArray(rule.depends) &amp;&amp;
        rule.depends.every(dep =&gt; (typeof dep === 'string')),
        `Rule ${JSON.stringify(rule)} does not have list of strings as 'depends'`)
      assert(('recipes' in rule) &amp;&amp;
        Array.isArray(rule.recipes) &amp;&amp;
        rule.recipes.every(recipe =&gt; (typeof recipe === 'string')),
        `Rule ${JSON.stringify(rule)} does not have list of strings as 'recipes'`)
    })
  }
}

module.exports = ConfigLoader
</code></pre>
<ul>
<li>Turn the configuration into a graph
<ul>
<li>Use <a href="https://www.npmjs.com/package/graphlib">graphlib</a> to manage nodes and links rather than writing our own</li>
<li>Each node stores the recipe to rebuild it</li>
<li>Links go <em>from</em> the dependency <em>to</em> the target</li>
<li><code>setEdge</code> automatically adds a node if it isn't already present</li>
</ul>
</li>
<li>Might as well add the cycle checking here as well</li>
</ul>
<pre title="graph-creator.js"><code class="language-js">const assert = require('assert')
const graphlib = require('@dagrejs/graphlib')

const ConfigLoader = require('./config-loader')

class GraphCreator extends ConfigLoader {
  buildGraph () {
    this.graph = new graphlib.Graph()
    this.config.forEach(rule =&gt; {
      this.graph.setNode(rule.target, {
        recipes: rule.recipes
      })
      rule.depends.forEach(dep =&gt; this.graph.setEdge(dep, rule.target))
    })
  }

  checkCycles () {
    const cycles = graphlib.alg.findCycles(this.graph)
    assert.strictEqual(cycles.length, 0,
      `Dependency graph contains cycles ${cycles}`)
  }
}

module.exports = GraphCreator
</code></pre>
<ul>
<li>Again, would have implemented all of these required methods in one step in a real program</li>
<li>Can now create something that displays our configuration when it runs but does nothing else</li>
</ul>
<pre title="display-only.js"><code class="language-js">const graphlib = require('@dagrejs/graphlib')

const GraphCreator = require('./graph-creator')

class DisplayOnly extends GraphCreator {
  run () {
    console.log('Graph')
    console.log(graphlib.json.write(this.graph))
    console.log('Sorted')
    console.log(graphlib.alg.topsort(this.graph))
  }
}

module.exports = DisplayOnly
</code></pre>
<ul>
<li>Try running it
<ul>
<li>Takes a moment to read the output with its v's and w's</li>
</ul>
</li>
</ul>
<pre title="display-only.sh"><code class="language-sh">node driver.js ./display-only three-simple-rules.yml
</code></pre>
<pre title="display-only.txt"><code class="language-txt">Graph
{
  options: { directed: true, multigraph: false, compound: false },
  nodes: [
    { v: 'A', value: [Object] },
    { v: 'B', value: [Object] },
    { v: 'C', value: [Object] }
  ],
  edges: [ { v: 'B', w: 'A' }, { v: 'C', w: 'A' }, { v: 'C', w: 'B' } ]
}
Sorted
[ 'C', 'B', 'A' ]
</code></pre>
<h2 id="how-can-we-specify-that-a-file-is-out-of-date">How can we specify that a file is out of date?</h2>
<ul>
<li>Classic approach is to compare timestamps</li>
<li>For testing, use another configuration file to specify fake timestamps to nodes</li>
</ul>
<pre title="add-timestamps.yml"><code class="language-yml">A: 2
B: 5
C: 8
</code></pre>
<ul>
<li>Where to add the timestamps?
<ul>
<li>Need the graph so that we can decorate it</li>
<li>So add a step to <code>buildGraph</code></li>
</ul>
</li>
</ul>
<pre title="add-timestamps.js"><code class="language-js">const assert = require('assert')
const fs = require('fs')
const yaml = require('js-yaml')

const GraphCreator = require('./graph-creator')

class AddTimestamps extends GraphCreator {
  constructor (configFile, timestampFile) {
    super(configFile)
    this.timestampFile = timestampFile
  }

  buildGraph () {
    super.buildGraph()
    this.addTimestamps()
  }

  addTimestamps () {
    const times = yaml.safeLoad(fs.readFileSync(this.timestampFile, 'utf-8'))
    for (const node of Object.keys(times)) {
      assert(this.graph.hasNode(node),
             `Graph does not have node ${node}`)
      this.graph.node(node).timestamp = times[node]
    }
    const missing = this.graph.nodes().filter(
      n =&gt; !('timestamp' in this.graph.node(n))
    )
    assert.strictEqual(missing.length, 0,
      `Timestamp missing for node(s) ${missing}`)
  }

  run () {
    console.log(this.graph.nodes().map(
      n =&gt; `${n}: ${JSON.stringify(this.graph.node(n))}`
    ))
  }
}

module.exports = AddTimestamps
</code></pre>
<ul>
<li>The steps defined in <code>SkeletonBuilder.build</code> don't change
<ul>
<li>So people reading the code don't have to change their mental model of what it does overall</li>
<li>If someone ever wants to inject a new step between building the graph and adding timestamps,
they can override <code>addTimestamps</code> and put their step at the top before calling <code>super.addTimestamps</code></li>
<li>This <em>would</em> make the code a lot harder to read</li>
</ul>
</li>
<li>Execution</li>
</ul>
<pre title="add-timestamps.sh"><code class="language-sh">node driver.js ./add-timestamps three-simple-rules.yml add-timestamps.yml
</code></pre>
<pre title="add-timestamps.txt"><code class="language-txt">[
  'A: {"recipes":["update A from B and C"],"timestamp":2}',
  'B: {"recipes":["update B from C"],"timestamp":5}',
  'C: {"recipes":[],"timestamp":8}'
]
</code></pre>
<ul>
<li>Set current time to maximum file time</li>
<li>For each file from the &quot;bottom&quot; to the top:
<ul>
<li>If file is older than any of its dependencies, update it</li>
</ul>
</li>
</ul>
<h2 id="how-can-we-update-outofdate-files">How can we update out-of-date files?</h2>
<ul>
<li>&quot;Current time&quot; must be later than any of the file update times
<ul>
<li>Not guaranteed to be true in a networked world where computers' clocks can fall out of sync, but we'll pretend</li>
</ul>
</li>
<li>Look at files in topological order from oldest to youngest
<ul>
<li>If any file is older than the things it depends on, update it</li>
</ul>
</li>
<li>Pretend for now that updating takes one unit of time, so we advance our fictional clock once for each build</li>
</ul>
<pre title="update-on-timestamps.js"><code class="language-js">const graphlib = require('@dagrejs/graphlib')

const AddTimestamps = require('./add-timestamps')

class UpdateOnTimestamps extends AddTimestamps {
  run () {
    const sorted = graphlib.alg.topsort(this.graph)
    const startTime = 1 + Math.max(...sorted.map(n =&gt; this.graph.node(n).timestamp))
    console.log(`${startTime}: START`)
    const endTime = sorted.reduce((currTime, node) =&gt; {
      if (this.isStale(node)) {
        console.log(`${currTime}: ${node}`)
        this.graph.node(node).recipes.forEach(a =&gt; console.log(`    ${a}`))
        this.graph.node(node).timestamp = currTime
        currTime += 1
      }
      return currTime
    }, startTime)
    console.log(`${endTime}: END`)
  }

  isStale (node) {
    return this.graph.predecessors(node).some(
      other =&gt; this.graph.node(other).timestamp &gt;= this.graph.node(node).timestamp
    )
  }
}

module.exports = UpdateOnTimestamps
</code></pre>
<pre title="update-on-timestamps.sh"><code class="language-sh">node driver.js ./update-on-timestamps three-simple-rules.yml add-timestamps.yml
</code></pre>
<pre title="update-on-timestamps.txt"><code class="language-txt">9: START
9: B
    update B from C
10: A
    update A from B and C
11: END
</code></pre>
<h2 id="how-can-we-add-generic-build-rules">How can we add generic build rules?</h2>
<ul>
<li>We now want to add <g key="build_rule">build rules</g>
<ul>
<li>&quot;Build all things in this set the same way&quot;</li>
</ul>
</li>
<li>Need:
<ul>
<li>A way to define a set of files</li>
<li>A way to specify a generic rule</li>
<li>A way to fill in parts of that rule</li>
</ul>
</li>
<li>Override <code>buildGraph</code> to replace variables in recipes with values
<ul>
<li>Object-oriented programming helps us change only what we need to change</li>
<li>Depends on a good initial division into overridable chunks</li>
</ul>
</li>
<li>Make provides <g key="automatic_variable">automatic variables</g> with names like <code>$&lt;</code> and <code>$@</code></li>
<li>Ours will be more readable
<ul>
<li><code>@TARGET</code> for the target</li>
<li><code>@DEPENDENCIES</code> for all dependencies (in order)</li>
<li><code>@DEP[1]</code>, <code>@DEP[2]</code>, etc., for specific dependencies
<ul>
<li>Count from 1 like humans do</li>
</ul>
</li>
</ul>
</li>
<li>Test that it still handle rules <em>without</em> variables correctly</li>
</ul>
<pre title="variable-expander.js"><code class="language-js">const UpdateOnTimestamps = require('./update-on-timestamps')

class VariableExpander extends UpdateOnTimestamps {
  buildGraph () {
    super.buildGraph()
    this.expandVariables()
  }

  expandVariables () {
    this.graph.nodes().forEach(target =&gt; {
      try {
        const dependencies = this.graph.predecessors(target)
        const recipes = this.graph.node(target).recipes
        this.graph.node(target).recipes = recipes.map(act =&gt; {
          act = act
            .replace('@TARGET', target)
            .replace('@DEPENDENCIES', dependencies.join(' '))
          dependencies.forEach((dep, i) =&gt; {
            act = act.replace(`@DEP[${i}]`, dependencies[i])
          })
          return act
        })
      } catch (error) {
        console.error(`Cannot find ${target} in graph`)
        process.exit(1)
      }
    })
  }
}

module.exports = VariableExpander
</code></pre>
<pre title="variable-expander.txt"><code class="language-txt">9: START
9: B
    update B from C
10: A
    update A from B C
11: END
</code></pre>
<ul>
<li>Now we need <g key="pattern_rule">pattern rules</g></li>
<li>First attempt at rules file looks like this</li>
</ul>
<pre title="pattern-rules.yml"><code class="language-yml">- target: left.out
  depends: []
  recipes: []
  timestamp: 1
- target: left.in
  depends: []
  recipes: []
  timestamp: 2
- target: right.out
  depends: []
  recipes: []
  timestamp: 1
- target: right.in
  depends: []
  recipes: []
  timestamp: 3
- target: "%.out"
  depends:
  - "%.in"
  recipes:
  - "update @TARGET from @DEPENDENCIES"
</code></pre>
<ul>
<li>First attempt at reading it extracts rules before expanding variables
<ul>
<li>But it doesn't work</li>
<li>Didn't actually have the assertion in <code>add-timestamps.js</code> when we first wrote it</li>
<li>Added it once we had and traced this error because every failure should turn into an <code>assert</code></li>
</ul>
</li>
</ul>
<pre title="pattern-user-attempt.js"><code class="language-js">const VariableExpander = require('./variable-expander')

class PatternUserAttempt extends VariableExpander {
  buildGraph () {
    super.buildGraph()
    this.extractRules()
    this.expandVariables()
  }

  extractRules () {
    this.rules = new Map()
    this.graph.nodes().forEach(target =&gt; {
      if (target.includes('%')) {
        const data = {
          recipes: this.graph.node(target).recipes
        }
        this.rules.set(target, data)
      }
    })
    this.rules.forEach((value, key) =&gt; {
      this.graph.removeNode(key)
    })
  }
}

module.exports = PatternUserAttempt
</code></pre>
<pre title="pattern-user-attempt.sh"><code class="language-sh">node driver.js ./pattern-user-attempt pattern-rules.yml add-timestamps.yml &gt;&amp; pattern-user-attempt.txt
exit 0
</code></pre>
<pre title="pattern-user-attempt.txt"><code class="language-txt">assert.js:386
    throw err;
    ^

AssertionError [ERR_ASSERTION]: Graph does not have node A
    at PatternUserAttempt.addTimestamps (/stjs/build-manager/add-timestamps.js:21:7)
    at PatternUserAttempt.buildGraph (/stjs/build-manager/add-timestamps.js:15:10)
    at PatternUserAttempt.buildGraph (/stjs/build-manager/variable-expander.js:5:11)
    at PatternUserAttempt.buildGraph (/stjs/build-manager/pattern-user-attempt.js:5:11)
    at PatternUserAttempt.build (/stjs/build-manager/skeleton-builder.js:10:10)
    at Object.&lt;anonymous&gt; (/stjs/build-manager/driver.js:3:9)
    at Module._compile (internal/modules/cjs/loader.js:1151:30)
    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1171:10)
    at Module.load (internal/modules/cjs/loader.js:1000:32)
    at Function.Module._load (internal/modules/cjs/loader.js:899:14) {
  generatedMessage: false,
  code: 'ERR_ASSERTION',
  actual: false,
  expected: true,
  operator: '=='
}
</code></pre>
<ul>
<li>Our simple graph loader creates nodes for dependencies even if they aren't targets</li>
<li>So we wind up tripping over the lack of a node for <code>%.in</code> before we get to extracting rules</li>
<li>Rewrite the rule loader to separate pattern rules from simple rules
<ul>
<li>Check that simple rules' dependencies don't include <code>%</code></li>
<li>And add timestamps as an optional field to rules for testing purposes rather than having them in a separate file</li>
</ul>
</li>
</ul>
<pre title="pattern-user-read.js"><code class="language-js">const assert = require('assert')
const graphlib = require('@dagrejs/graphlib')

const VariableExpander = require('./variable-expander')

class PatternUserRead extends VariableExpander {
  buildGraph () {
    this.buildGraphAndRules()
    this.expandVariables()
  }

  buildGraphAndRules () {
    this.graph = new graphlib.Graph()
    this.rules = new Map()
    this.config.forEach(rule =&gt; {
      if (rule.target.includes('%')) {
        const data = {
          recipes: rule.recipes,
          depends: rule.depends
        }
        this.rules.set(rule.target, data)
      } else {
        const timestamp = ('timestamp' in rule)
          ? rule.timestamp
          : null
        this.graph.setNode(rule.target, {
          recipes: rule.recipes,
          timestamp: timestamp
        })
        rule.depends.forEach(dep =&gt; {
          assert(!dep.includes('%'),
            'Cannot have "%" in a non-pattern rule')
          this.graph.setEdge(dep, rule.target)
        })
      }
    })
  }
}

module.exports = PatternUserRead
</code></pre>
<ul>
<li>Before we trying running this, let's add methods to show the state of the internal data structures
<ul>
<li>Since we now have two of them</li>
</ul>
</li>
</ul>
<pre title="pattern-user-show.js"><code class="language-js">const graphlib = require('@dagrejs/graphlib')

const PatternUserRead = require('./pattern-user-read')

class PatternUserShow extends PatternUserRead {
  run () {
    console.log(JSON.stringify(this.toJSON(), null, 2))
  }

  toJSON () {
    return {
      graph: graphlib.json.write(this.graph),
      rules: Array.from(this.rules.keys()).map(key =&gt; {
        return { k: key, v: this.rules.get(key) }
      })
    }
  }
}

module.exports = PatternUserShow
</code></pre>
<pre title="pattern-user-show.sh"><code class="language-sh">node driver.js ./pattern-user-show pattern-rules.yml
</code></pre>
<pre title="pattern-user-show.txt"><code class="language-txt">{
  "graph": {
    "options": {
      "directed": true,
      "multigraph": false,
      "compound": false
    },
    "nodes": [
      {
        "v": "left.out",
        "value": {
          "recipes": [],
          "timestamp": 1
        }
      },
      {
        "v": "left.in",
        "value": {
          "recipes": [],
          "timestamp": 2
        }
      },
      {
        "v": "right.out",
        "value": {
          "recipes": [],
          "timestamp": 1
        }
      },
      {
        "v": "right.in",
        "value": {
          "recipes": [],
          "timestamp": 3
        }
      }
    ],
    "edges": []
  },
  "rules": [
    {
      "k": "%.out",
      "v": {
        "recipes": [
          "update @TARGET from @DEPENDENCIES"
        ],
        "depends": [
          "%.in"
        ]
      }
    }
  ]
}
</code></pre>
<ul>
<li>That seems to be right</li>
<li>So let's try expanding rules
<ul>
<li>Do it after building the graph and rules, but before expanding variables</li>
</ul>
</li>
</ul>
<pre title="pattern-user-run.js"><code class="language-js">const PatternUserRead = require('./pattern-user-read')

class PatternUserRun extends PatternUserRead {
  buildGraph () {
    this.buildGraphAndRules()
    this.expandAllRules()
    this.expandVariables()
  }

  expandAllRules () {
    this.graph.nodes().forEach(target =&gt; {
      if (this.graph.predecessors(target).length &gt; 0) {
        return
      }
      const data = this.graph.node(target)
      if (data.recipes.length &gt; 0) {
        return
      }
      const rule = this.findRule(target)
      if (!rule) {
        return
      }
      this.expandRule(target, rule)
    })
  }

  findRule (target) {
    const pattern = `%.${target.split('.')[1]}`
    return this.rules.has(pattern)
      ? this.rules.get(pattern)
      : null
  }

  expandRule (target, rule) {
    const stem = target.split('.')[0]
    rule.depends
      .map(dep =&gt; dep.replace('%', stem))
      .forEach(dep =&gt; this.graph.setEdge(dep, target))
    const recipes = rule.recipes.map(act =&gt; act.replace('%', stem))
    const timestamp = this.graph.node(target).timestamp
    this.graph.setNode(target, {
      recipes: recipes,
      timestamp: timestamp
    })
  }
}

module.exports = PatternUserRun
</code></pre>
<pre title="pattern-user-run.txt"><code class="language-txt">4: START
4: left.out
    update left.out from left.in
5: right.out
    update right.out from right.in
6: END
</code></pre>
<ul>
<li>We have added a lot of steps to our original template method
<ul>
<li>Which makes it a bit of a stretch to claim that the overall operation hasn't changed</li>
</ul>
</li>
<li>Knowing what we know now, we could go back and modify the original <code>SkeletonBuilder.build</code> method
to include those extra steps and provide do-nothing implementations
<ul>
<li>After enough examples, the template settles down</li>
<li>We learn from our code as we write it</li>
</ul>
</li>
</ul>
</main>
<footer>
<div class="row">
<div class="left3">
<a href="../module-bundler/"><em>&laquo; Module Bundler</em></a>
</div>
<div class="middle3">
<a href="../license/"><img class="footer" src="../static/cc-by.svg" alt="License" /></a>
<a href="https://github.com/gvwilson/e/"><img class="footer" src="../static/github.svg" alt="Repository" /></a>
© 2020 <a href="../authors/">The Authors</a>
</div>
<div class="right3">
<a href="../layout-engine/"><em>Layout Engine &raquo;</em></a>
</div>
</div>
</footer>
</body>
</html>
