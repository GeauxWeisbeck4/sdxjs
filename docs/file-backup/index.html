<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
  <title>File Backup</title>
  <meta name="toRoot" content="..">
  <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
  <link href="../static/site.css" rel="stylesheet" type="text/css">
  <script src="../static/site.js"></script>
  <script>window.onload = () => fixPage()</script>
</head>
<body id="_top">
<nav>
<div class="row">
<div class="left2">
<a href="http://third-bit.com"><img src="../static/logo.svg" alt="site logo" class="site-logo"/></a>
<a href="../"><em>Software Tools in JavaScript</em></a>
</div>
<div class="right2">
<div class="dropdown">
<span class="navtitle">▿ Sections</span>
<div class="dropdown-content" id="Sections">
</div>
</div>
<div class="dropdown">
<span class="navtitle">▿ Chapters</span>
<div class="dropdown-content" id="Chapters">
<a href="../systems-programming/"><span class="nowrap">Systems Programming</span></a>
<br/><a href="../promises/"><span class="nowrap">Promises</span></a>
<br/><a href="../unit-test/"><span class="nowrap">Unit Testing</span></a>
<br/><a href="../file-backup/"><span class="nowrap">File Backup</span></a>
<br/><a href="../data-table/"><span class="nowrap">Data Tables</span></a>
<br/><a href="../pattern-matching/"><span class="nowrap">Pattern Matching</span></a>
<br/><a href="../regex-parser/"><span class="nowrap">Parsing Expressions</span></a>
<br/><a href="../page-templates/"><span class="nowrap">Page Templates</span></a>
<br/><a href="../build-manager/"><span class="nowrap">Build Manager</span></a>
<br/><a href="../layout-engine/"><span class="nowrap">Layout Engine</span></a>
<br/><a href="../text-editor/"><span class="nowrap">Text Editor</span></a>
<br/><a href="../file-interpolator/"><span class="nowrap">File Interpolator</span></a>
<br/><a href="../module-loader/"><span class="nowrap">Module Loader</span></a>
<br/><a href="../module-bundler/"><span class="nowrap">Module Bundler</span></a>
<br/><a href="../package-manager/"><span class="nowrap">Package Manager</span></a>
<br/><a href="../style-checker/"><span class="nowrap">Style Checker</span></a>
<br/><a href="../code-generator/"><span class="nowrap">Code Generator</span></a>
<br/><a href="../doc-generator/"><span class="nowrap">Documentation Generator</span></a>
<br/><a href="../virtual-machine/"><span class="nowrap">Virtual Machine</span></a>
<br/><a href="../debugger/"><span class="nowrap">Debugger</span></a>
<br/><a href="../code-analyzer/"><span class="nowrap">Code Analyzer</span></a>
<br/><a href="../conclusion/"><span class="nowrap">Conclusion</span></a>
</div>
</div>
<div class="dropdown">
<span class="navtitle">▿ Appendices</span>
<div class="dropdown-content" id="Appendices">
<a href="../bib/"><span class="nowrap">Bibliography</span></a>
<br/><a href="../license/"><span class="nowrap">License</span></a>
<br/><a href="../conduct/"><span class="nowrap">Code of Conduct</span></a>
<br/><a href="../contributing/"><span class="nowrap">Contributing</span></a>
<br/><a href="../gloss/"><span class="nowrap">Glossary</span></a>
<br/><a href="../links/"><span class="nowrap">Links</span></a>
<br/><a href="../authors/"><span class="nowrap">Authors</span></a>
</div>
</div>
</div>
</div>
</nav>
  <main>
  <h1>File Backup</h1>
  <h2 class="lede">Archiving files with directory structure</h2>
<ul>
<li>Goal: archiving files with an index that identifies each version so that we don't store redundant data</li>
<li>The basis of <a href="https://git-scm.com/">Git</a></li>
</ul>
<h2 id="what-is-a-hash-code-and-how-can-we-create-one-for-a-file">What is a hash code and how can we create one for a file?</h2>
<ul>
<li>A <g key="hash_function">hash function</g> turns arbitrary data into a fixed-length string of bits
<ul>
<li>That bit string can then be used to place the object in a predictable place in a table</li>
<li>Gives reasonably fast lookup for arbitrary keys</li>
</ul>
</li>
<li>A <g key="cryptographic_hash_function">cryptographic hash function</g> produces keys that appear random
<ul>
<li>Leads to the fastest possible lookup on average</li>
</ul>
</li>
<li>Easy to write a bad hash function but hard to write a strong one
<ul>
<li>Use a library to calculate a 160-bit [SHA-1] hash</li>
<li>Not strong enough to deter a well-funded attacker, but that's not what we're using it for</li>
</ul>
</li>
</ul>
<pre title="hash-text.js"><code class="language-js">import crypto from 'crypto'

// create a SHA1 hasher
const hash = crypto.createHash('sha1')

// encode as hex (rather than binary)
hash.setEncoding('hex')

// send it some text
const text = process.argv[2]
hash.write(text)

// signal end of text
hash.end()

// display the result
const sha1sum = hash.read()
console.log(`SHA1 of "${text}" is ${sha1sum}`)
</code></pre>
<pre title="hash-text.sh"><code class="language-sh">node hash-text.js something
</code></pre>
<pre title="hash-text.txt"><code class="language-txt">SHA1 of "something" is 1af17e73721dbe0c40011b82ed4bb1a7dbe3ce29
</code></pre>
<ul>
<li>The hash code for a file:
<ul>
<li>Will always be the same for the same content</li>
<li>Is almost certain to be different if even a single byte differs</li>
</ul>
</li>
</ul>
<pre title="hash-file.js"><code class="language-js">import fs from 'fs'
import crypto from 'crypto'

const filename = process.argv[2]
const data = fs.readFileSync(filename, 'utf-8')

const hash = crypto.createHash('sha1').setEncoding('hex')
hash.write(data)
hash.end()
const sha1sum = hash.read()

console.log(`SHA1 of "${filename}" is ${sha1sum}`)
</code></pre>
<pre title="hash-file.sh"><code class="language-sh">node hash-file.js hash-file.js
</code></pre>
<pre title="hash-file.txt"><code class="language-txt">SHA1 of "hash-file.js" is c54c8ee3e576770d29ae2d0d73568e5a5c49eac0
</code></pre>
<div class="callout">
<h3 id="the-birthday-problem">The Birthday Problem</h3>
<p>The odds that two people share a birthday are 1/365 (ignoring February 29).
The odds that they <em>don't</em> are therefore 364/365.
When we add a third person,
the odds that they don't share a birthday with either of the preceding two people are 363/365,
so the overall odds that nobody shares a birthday are (365/365)×(364/365)×(363/365).
If we keep calculating, there's a 50% chance of two people sharing a birthday in a group of just 23 people,
and a 99.9% chance with 70 people.</p>
<p>We can use the same math to calculate how many files we need to hash before there's a 50% chance of a collision.
Instead of 365, we use 2<sup>160</sup> (the number of values that are 160 bits long),
and quickly get into &quot;if every atom in the universe was a file there still wouldn't be collisions&quot; territory.</p>
</div>
<ul>
<li>More efficient to process the file as a <g key="stream">stream</g>
<ul>
<li>Read the file in chunks</li>
<li>Pass each chunk to an object containing a hashing function, which accumulates a result</li>
<li>Tell the hashing object what to do when the stream finishes</li>
<li>Another example of <g key="asynchronous">asynchronous</g> execution</li>
</ul>
</li>
</ul>
<pre title="hash-stream.js"><code class="language-js">import fs from 'fs'
import crypto from 'crypto'

const filename = process.argv[2]
const hash = crypto.createHash('sha1').setEncoding('hex')
fs.createReadStream(filename).pipe(hash)
hash.on('finish', () =&gt; {
  const final = hash.read()
  console.log('final', final)
})
console.log('program ends')
</code></pre>
<pre title="hash-stream.sh"><code class="language-sh">node hash-stream.js hash-stream.js
</code></pre>
<pre title="hash-stream.txt"><code class="language-txt">program ends
final dc9e6c231e243860dace2dbf52845b121062b60e
</code></pre>
<ul>
<li>Many files don't change after they're created, or only change very slowly</li>
<li>Wasteful to copy them every time a backup is done</li>
<li>Instead:
<ul>
<li>Copy each file to something like <code>abcd1234.bck</code> where <code>abcd1234</code> is a hash of the file's contents</li>
<li>Store a data structure that records filenames and hash keys at a particular instant</li>
<li>To restore from a particular date, copy saved files to where they need to be</li>
</ul>
</li>
</ul>
<h2 id="how-can-async-and-await-simplify-code">How can async and await simplify code?</h2>
<ul>
<li>Step 1: find all files and calculate their hashes</li>
</ul>
<pre title="hash-existing-promise.js"><code class="language-js">import fs from 'fs-extra-promise'
import glob from 'glob-promise'
import crypto from 'crypto'

const statPath = (path) =&gt; {
  return new Promise((resolve, reject) =&gt; {
    fs.statAsync(path)
      .then(stat =&gt; resolve([path, stat]))
      .catch(err =&gt; reject(err))
  })
}

const readPath = (path) =&gt; {
  return new Promise((resolve, reject) =&gt; {
    fs.readFileAsync(path, 'utf-8')
      .then(content =&gt; resolve([path, content]))
      .catch(err =&gt; reject(err))
  })
}

const hashPath = (path, content) =&gt; {
  const hasher = crypto.createHash('sha1').setEncoding('hex')
  hasher.write(content)
  hasher.end()
  return [path, hasher.read()]
}

const hashExisting = (rootDir) =&gt; {
  const pattern = `${rootDir}/**/*`
  const options = {}
  return new Promise((resolve, reject) =&gt; {
    glob(pattern, options)
      .then(matches =&gt; Promise.all(
        matches.map(path =&gt; statPath(path))))
      .then(pairs =&gt; pairs.filter(
        ([path, stat]) =&gt; stat.isFile()))
      .then(pairs =&gt; Promise.all(
        pairs.map(([path, stat]) =&gt; readPath(path))))
      .then(pairs =&gt; Promise.all(
        pairs.map(([path, content]) =&gt; hashPath(path, content))))
      .then(pairs =&gt; resolve(pairs))
      .catch(err =&gt; reject(err))
  })
}

export default hashExisting
</code></pre>
<pre title="run-hash-existing-promise.js"><code class="language-js">import hashExisting from './hash-existing-promise.js'

const root = process.argv[2]
hashExisting(root).then(pairs =&gt; pairs.forEach(
  ([path, hash]) =&gt; console.log(path, hash)
))
</code></pre>
<pre title="run-hash-existing-promise.sh"><code class="language-sh">node run-hash-existing-promise.js . | fgrep -v test/ | fgrep -v '~'
</code></pre>
<pre title="run-hash-existing-promise.txt"><code class="language-txt">./backup.js 11422489e11be3d8ff76278503457665f6152ebe
./check-existing-files.js 66b933cf9e792e9a9204171d04e0f8b530ec3f4f
./hash-existing-async.js 38518660463a80367f9719a870916eeab2933a8d
./hash-existing-promise.js 2b022a50294697eef84689b63ab46f0b899d14db
./hash-file.js c54c8ee3e576770d29ae2d0d73568e5a5c49eac0
./hash-file.sh ff2f263c71ce98338adf4a8a65c297c9361e3e16
./hash-file.txt 7d5014143474e733daf263a94d4d43df30ba91cf
./hash-stream.js dc9e6c231e243860dace2dbf52845b121062b60e
./hash-stream.sh 0dd6064f3005e832fef580f3de7fa0980fd81dee
./hash-stream.txt af7195be4585e588f301cbfbddd5a47966cb704c
./hash-text.js 069b19412fb9c3c8489f85f1c45d8821c220185f
./hash-text.sh 4e85b91c9254c77cf887d2ca92ea0a8ed60c14b7
./hash-text.txt 4ae882fbcd46e408c9a0548f6547158bc982b40a
./index.md d89d5dbcabe1e147fed9af5a806e1d89e90daa35
./Makefile b96c8f89ba7d0f8af0edcfc70221d24032d805a7
./run-hash-existing-async.js 6ded15d613e349bfaf0fea8562166ccb3a82d3a6
./run-hash-existing-async.sh 77ef1cf657fc61f6b47b5313e69973830225cb1d
./run-hash-existing-async.txt 41a4436467c43e91fbd9eec1c96c56b4d7aaafeb
./run-hash-existing-promise.js 877f1a5b3d4e2c18580a7360595ab3362e5b553d
./run-hash-existing-promise.sh 7d7470ac520fc1f368d97fd0d061e17caacea83b
./run-hash-existing-promise.txt da39a3ee5e6b4b0d3255bfef95601890afd80709
./test-backup.sh 7ab530fdf93cf27e199eac259925502bad55e08b
./test-backup.txt 93bf3ecb44e177dd907f5164a7af5aef2503608d
./test-check-filesystem.sh d3621575780a3bd2ed97fb8d703555c8ea667b80
./test-check-filesystem.txt 93b1a654b2759f33558e6254b26b6fce207e7938
./tree-test.sh 0947bbdf779e1ebb8919e94b556da6b62114c114
./tree-test.txt 12540e510055a7f826591c5d045f63e80836c7e2
</code></pre>
<ul>
<li>This code is clearer than it would be with callbacks, but the layer of promises around everything still obscures meaning</li>
<li>Let's rewrite it using <code>async</code> and <code>await</code></li>
</ul>
<pre title="hash-existing-async.js"><code class="language-js">import fs from 'fs-extra-promise'
import glob from 'glob-promise'
import crypto from 'crypto'

const statPath = async (path) =&gt; {
  const stat = await fs.statAsync(path)
  return [path, stat]
}

const readPath = async (path) =&gt; {
  const content = await fs.readFileAsync(path, 'utf-8')
  return [path, content]
}

const hashPath = (path, content) =&gt; {
  const hasher = crypto.createHash('sha1').setEncoding('hex')
  hasher.write(content)
  hasher.end()
  return [path, hasher.read()]
}

const hashExisting = async (rootDir) =&gt; {
  const pattern = `${rootDir}/**/*`
  const options = {}
  const matches = await glob(pattern, options)
  const stats = await Promise.all(matches.map(path =&gt; statPath(path)))
  const files = stats.filter(([path, stat]) =&gt; stat.isFile())
  const contents = await Promise.all(
    files.map(([path, stat]) =&gt; readPath(path)))
  const hashes = contents.map(
    ([path, content]) =&gt; hashPath(path, content))
  return hashes
}

export default hashExisting
</code></pre>
<pre title="run-hash-existing-async.js"><code class="language-js">import hashExisting from './hash-existing-async.js'

const root = process.argv[2]
hashExisting(root).then(
  pairs =&gt; pairs.forEach(([path, hash]) =&gt; console.log(path, hash)))
</code></pre>
<pre title="run-hash-existing-async.sh"><code class="language-sh">node run-hash-existing-async.js . | fgrep -v test/ | fgrep -v '~'
</code></pre>
<pre title="run-hash-existing-async.txt"><code class="language-txt">./backup.js 11422489e11be3d8ff76278503457665f6152ebe
./check-existing-files.js 66b933cf9e792e9a9204171d04e0f8b530ec3f4f
./hash-existing-async.js 38518660463a80367f9719a870916eeab2933a8d
./hash-existing-promise.js 2b022a50294697eef84689b63ab46f0b899d14db
./hash-file.js c54c8ee3e576770d29ae2d0d73568e5a5c49eac0
./hash-file.sh ff2f263c71ce98338adf4a8a65c297c9361e3e16
./hash-file.txt 7d5014143474e733daf263a94d4d43df30ba91cf
./hash-stream.js dc9e6c231e243860dace2dbf52845b121062b60e
./hash-stream.sh 0dd6064f3005e832fef580f3de7fa0980fd81dee
./hash-stream.txt af7195be4585e588f301cbfbddd5a47966cb704c
./hash-text.js 069b19412fb9c3c8489f85f1c45d8821c220185f
./hash-text.sh 4e85b91c9254c77cf887d2ca92ea0a8ed60c14b7
./hash-text.txt 4ae882fbcd46e408c9a0548f6547158bc982b40a
./index.md d89d5dbcabe1e147fed9af5a806e1d89e90daa35
./Makefile b96c8f89ba7d0f8af0edcfc70221d24032d805a7
./run-hash-existing-async.js 6ded15d613e349bfaf0fea8562166ccb3a82d3a6
./run-hash-existing-async.sh 77ef1cf657fc61f6b47b5313e69973830225cb1d
./run-hash-existing-async.txt da39a3ee5e6b4b0d3255bfef95601890afd80709
./run-hash-existing-promise.js 877f1a5b3d4e2c18580a7360595ab3362e5b553d
./run-hash-existing-promise.sh 7d7470ac520fc1f368d97fd0d061e17caacea83b
./run-hash-existing-promise.txt 05e82df44a6a179d275f452e93052b3b5888e626
./test-backup.sh 7ab530fdf93cf27e199eac259925502bad55e08b
./test-backup.txt 93bf3ecb44e177dd907f5164a7af5aef2503608d
./test-check-filesystem.sh d3621575780a3bd2ed97fb8d703555c8ea667b80
./test-check-filesystem.txt 93b1a654b2759f33558e6254b26b6fce207e7938
./tree-test.sh 0947bbdf779e1ebb8919e94b556da6b62114c114
./tree-test.txt 12540e510055a7f826591c5d045f63e80836c7e2
</code></pre>
<h2 id="how-can-we-test-javascript">How can we test JavaScript?</h2>
<ul>
<li>Step 2: see which files have and haven't been backed up already
<ul>
<li>Backup directory contains <code>abcd1234.bck</code> (backup files) and <code>ssssssssss.csv</code> (manifest files),
where <code>ssssssssss</code> is the <g key="utc">UTC</g> <g key="timestamp">timestamp</g> of the backup's creation</li>
<li>We assume no more than one backup per second (which is unsafe in practice)</li>
</ul>
</li>
</ul>
<pre title="check-existing-files.js"><code class="language-js">import glob from 'glob-promise'
import path from 'path'

const findNewFiles = async (rootDir, pathHashPairs) =&gt; {
  const hashToPath = pathHashPairs.reduce((obj, [path, hash]) =&gt; {
    obj[hash] = path
    return obj
  }, {})

  const pattern = `${rootDir}/*.bck`
  const options = {}
  const existingFiles = await glob(pattern, options)

  existingFiles.forEach(filename =&gt; {
    const stripped = path.basename(filename).replace(/\.bck$/, '')
    delete hashToPath[stripped]
  })

  return hashToPath
}

export default findNewFiles
</code></pre>
<ul>
<li>Manually create testing directories with manufactured (shortened) hashes</li>
</ul>
<pre title="tree-test.sh"><code class="language-sh">tree --charset unicode test
</code></pre>
<pre title="tree-test.txt"><code class="language-txt">test
|-- bck-0-csv-0
|-- bck-1-csv-1
|   |-- 0001.csv
|   `-- abcd1234.bck
|-- bck-4-csv-2
|   |-- 0001.csv
|   |-- 3028.csv
|   |-- 3456cdef.bck
|   |-- abcd1234.bck
|   `-- bcde2345.bck
|-- test-backup.js
|-- test-find-mock.js
`-- test-find.js

3 directories, 10 files
</code></pre>
<ul>
<li>Use <a href="https://mochajs.org/">Mocha</a> for testing
<ul>
<li>All tests are written using <code>async</code></li>
<li>Mocha will automatically wait for them to complete before reporting results</li>
<li>Add <code>&quot;test&quot;: &quot;mocha */test/test-*.js&quot;</code> to the <code>scripts</code> key of <code>package.json</code>,
since we may add tests for other things later</li>
</ul>
</li>
</ul>
<pre title="test/test-find.js"><code class="language-js">import assert from 'assert'

import findNewFiles from '../check-existing-files.js'

describe('pre-existing hashes and actual filesystem', () =&gt; {
  it('finds no pre-existing files when none given or exist', async () =&gt; {
    const expected = {}
    const actual = await findNewFiles('file-backup/test/bck-0-csv-0', [])
    assert.deepStrictEqual(expected, actual,
      'Expected no files')
  })

  it('finds some files when one file is given and none exist', async () =&gt; {
    const check = [['somefile.txt', '9876fedc']]
    const expected = { '9876fedc': 'somefile.txt' }
    const actual = await findNewFiles('file-backup/test/bck-0-csv-0', check)
    assert.deepStrictEqual(expected, actual,
      'Expected one file')
  })

  it('finds nothing needs backup when there is a match', async () =&gt; {
    const check = [['alpha.js', 'abcd1234']]
    const expected = {}
    const actual = await findNewFiles('file-backup/test/bck-1-csv-1', check)
    assert.deepStrictEqual(expected, actual,
      'Expected no files')
  })

  it('finds something needs backup when there is a mismatch', async () =&gt; {
    const check = [['alpha.js', 'a1b2c3d4']]
    const expected = { a1b2c3d4: 'alpha.js' }
    const actual = await findNewFiles('file-backup/test/bck-1-csv-1', check)
    assert.deepStrictEqual(expected, actual,
      'Expected one file')
  })

  it('finds mixed matches', async () =&gt; {
    const check = [
      ['matches.js', '3456cdef'],
      ['matches.txt', 'abcd1234'],
      ['mismatch.txt', '12345678']
    ]
    const expected = { 12345678: 'mismatch.txt' }
    const actual = await findNewFiles('file-backup/test/bck-4-csv-2', check)
    assert.deepStrictEqual(expected, actual,
      'Expected one file')
  })
})
</code></pre>
<pre title="test-check-filesystem.txt"><code class="language-txt">&gt; stjs@1.0.0 test /u/stjs
&gt; mocha */test/test-*.js "-g" "pre-existing hashes"

ReferenceError: require is not defined
    at file:///u/stjs/layout-engine/test/test-easy-mode.js:1:16
    at ModuleJob.run (internal/modules/esm/module_job.js:146:23)
    at async Loader.import (internal/modules/esm/loader.js:165:24)
    at async Object.exports.loadFilesAsync (/u/stjs/node_modules/mocha/lib/esm-utils.js:33:20)
    at async singleRun (/u/stjs/node_modules/mocha/lib/cli/run-helpers.js:156:3)
    at async Object.exports.handler (/u/stjs/node_modules/mocha/lib/cli/run.js:366:5)
npm ERR! code ELIFECYCLE
npm ERR! errno 1
npm ERR! stjs@1.0.0 test: `mocha */test/test-*.js "-g" "pre-existing hashes"`
npm ERR! Exit status 1
npm ERR! 
npm ERR! Failed at the stjs@1.0.0 test script.
npm ERR! This is probably not a problem with npm. There is likely additional logging output above.

npm ERR! A complete log of this run can be found in:
npm ERR!     /Users/gvwilson/.npm/_logs/2020-11-24T12_59_52_921Z-debug.log
</code></pre>
<h2 id="how-can-we-test-code-that-modifies-files">How can we test code that modifies files?</h2>
<ul>
<li>Step 3: copy the files that need copying and create a new timestamped <g key="csv">CSV</g> file
<ul>
<li>Could use JSON, but CSV is easier for humans to read</li>
</ul>
</li>
<li>The code itself will be relatively simple, but setup and cleanup will be annoying</li>
<li>Better solution: use a <g key="mock_object">mock object</g> instead of the real filesystem
<ul>
<li>Has the same interface as the real function/object/class/library</li>
<li>But works differently for testing purposes</li>
</ul>
</li>
<li>Install <a href="https://www.npmjs.com/package/mock-fs"><code>mock-fs</code></a></li>
<li>Create a mock filesystem with a JSON description of files and their contents</li>
<li>Repeat previous tests using mock
<ul>
<li>Results stay the same</li>
</ul>
</li>
</ul>
<pre title="test/test-find-mock.js"><code class="language-js">import assert from 'assert'
import mock from 'mock-fs'

import findNewFiles from '../check-existing-files.js'

describe('checks for pre-existing hashes using mock filesystem', () =&gt; {
  beforeEach(() =&gt; {
    mock({
      'bck-0-csv-0': {},
      'bck-1-csv-1': {
        '0001.csv': 'alpha.js,abcd1234',
        'abcd1234.bck': 'alpha.js content'
      },
      'bck-4-csv-2': {
        '0001.csv': ['alpha.js,abcd1234',
          'beta.txt,bcde2345'].join('\n'),
        '3024.csv': ['alpha.js,abcd1234',
          'gamma.png,3456cdef',
          'subdir/renamed.txt,bcde2345'].join('\n'),
        '3456cdef.bck': 'gamma.png content',
        'abcd1234.bck': 'alpha content',
        'bcde2345.bck': 'beta.txt became subdir/renamed.txt'
      }
    })
  })

  afterEach(() =&gt; {
    mock.restore()
  })

  it('finds no pre-existing files when none given or exist', async () =&gt; {
    const expected = {}
    const actual = await findNewFiles('bck-0-csv-0', [])
    assert.deepStrictEqual(expected, actual,
      'Expected no files')
  })

  it('finds some files when one file is given and none exist', async () =&gt; {
    const candidates = [['somefile.txt', '9876fedc']]
    const expected = { '9876fedc': 'somefile.txt' }
    const actual = await findNewFiles('bck-0-csv-0', candidates)
    assert.deepStrictEqual(expected, actual,
      'Expected one file')
  })

  it('finds nothing needs backup when there is a match', async () =&gt; {
    const candidates = [['alpha.js', 'abcd1234']]
    const expected = {}
    const actual = await findNewFiles('bck-1-csv-1', candidates)
    assert.deepStrictEqual(expected, actual,
      'Expected no files')
  })

  it('finds something needs backup when there is a mismatch', async () =&gt; {
    const candidates = [['alpha.js', 'a1b2c3d4']]
    const expected = { a1b2c3d4: 'alpha.js' }
    const actual = await findNewFiles('bck-1-csv-1', candidates)
    assert.deepStrictEqual(expected, actual,
      'Expected one file')
  })

  it('finds mixed matches', async () =&gt; {
    const candidates = [['matches.js', '3456cdef'],
      ['matches.txt', 'abcd1234'],
      ['mismatch.txt', '12345678']]
    const expected = { 12345678: 'mismatch.txt' }
    const actual = await findNewFiles('bck-4-csv-2', candidates)
    assert.deepStrictEqual(expected, actual,
      'Expected one file')
  })
})
</code></pre>
<ul>
<li>Now write the code that does the file copying</li>
</ul>
<pre title="backup.js"><code class="language-js">import fs from 'fs-extra-promise'

import hashExisting from './hash-existing-async.js'
import findNewFiles from './check-existing-files.js'

const backup = async (src, dst, timestamp = null) =&gt; {
  if (timestamp === null) {
    timestamp = Math.round((new Date()).getTime() / 1000)
  }
  timestamp = String(timestamp).padStart(10, '0')

  const existing = await hashExisting(src)
  const needToCopy = await findNewFiles(dst, existing)
  await copyFiles(dst, needToCopy)
  await saveManifest(dst, timestamp, existing)
}

const copyFiles = async (dst, needToCopy) =&gt; {
  const promises = Object.keys(needToCopy).map(hash =&gt; {
    const srcPath = needToCopy[hash]
    const dstPath = `${dst}/${hash}.bck`
    fs.copyFileAsync(srcPath, dstPath)
  })
  return Promise.all(promises)
}

const saveManifest = async (dst, timestamp, pathHash) =&gt; {
  pathHash = pathHash.sort()
  const content = pathHash.map(
    ([path, hash]) =&gt; `${path},${hash}`).join('\n')
  const manifest = `${dst}/${timestamp}.csv`
  fs.writeFileAsync(manifest, content, 'utf-8')
}

export default backup
</code></pre>
<ul>
<li>And some tests
<ul>
<li>Which are quite involved, since we want to check with actual file hashes</li>
</ul>
</li>
<li>Set up some fixtures</li>
</ul>
<pre title="test/test-backup.js"><code class="language-js">import backup from '../backup.js'

const hashString = (data) =&gt; {
  const hasher = crypto.createHash('sha1').setEncoding('hex')
  hasher.write(data)
  hasher.end()
  return hasher.read()
}

const Contents = {
  aaa: 'AAA',
  bbb: 'BBB',
  ccc: 'CCC'
}

const Hashes = Object.keys(Contents).reduce((obj, key) =&gt; {
  obj[key] = hashString(Contents[key])
  return obj
}, {})

const Fixture = {
  source: {
    'alpha.txt': Contents.aaa,
    'beta.txt': Contents.bbb,
    gamma: {
      'delta.txt': Contents.ccc
    }
  },
  backup: {}
}

const InitialBackups = Object.keys(Hashes).reduce((set, filename) =&gt; {
  set.add(`backup/${Hashes[filename]}.bck`)
  return set
}, new Set())</code></pre>
<ul>
<li>And then run some tests</li>
</ul>
<pre title="test/test-backup.js"><code class="language-js">describe('check entire backup process', () =&gt; {
  beforeEach(() =&gt; {
    mock(Fixture)
  })

  afterEach(() =&gt; {
    mock.restore()
  })

  it('creates an initial CSV manifest', async () =&gt; {
    await backup('source', 'backup', 0)

    assert.strictEqual((await glob('backup/*')).length, 4,
      'Expected 4 files')

    const actualBackups = new Set(await glob('backup/*.bck'))
    assert.deepStrictEqual(actualBackups, InitialBackups,
      'Expected 3 backup files')

    const actualManifests = await glob('backup/*.csv')
    assert.deepStrictEqual(actualManifests, ['backup/0000000000.csv'],
      'Expected one manifest')
  })

  it('does not duplicate files unnecessarily', async () =&gt; {
    await backup('source', 'backup', 0)
    assert.strictEqual((await glob('backup/*')).length, 4,
      'Expected 4 files after first backup')

    await backup('source', 'backup', 1)
    assert.strictEqual((await glob('backup/*')).length, 5,
      'Expected 5 files after second backup')
    const actualBackups = new Set(await glob('backup/*.bck'))
    assert.deepStrictEqual(actualBackups, InitialBackups,
      'Expected 3 backup files after second backup')

    const actualManifests = (await glob('backup/*.csv')).sort()
    assert.deepStrictEqual(actualManifests,
      ['backup/0000000000.csv', 'backup/0000000001.csv'],
      'Expected two manifests')
  })

  it('adds a file as needed', async () =&gt; {
    await backup('source', 'backup', 0)
    assert.strictEqual((await glob('backup/*')).length, 4,
      'Expected 4 files after first backup')

    await fs.writeFileAsync('source/newfile.txt', 'NNN')
    const hashOfNewFile = hashString('NNN')

    await backup('source', 'backup', 1)
    assert.strictEqual((await glob('backup/*')).length, 6,
      'Expected 6 files after second backup')
    const expected = new Set(InitialBackups)
      .add(`backup/${hashOfNewFile}.bck`)
    const actualBackups = new Set(await glob('backup/*.bck'))
    assert.deepStrictEqual(actualBackups, expected,
      'Expected 4 backup files after second backup')

    const actualManifests = (await glob('backup/*.csv')).sort()
    assert.deepStrictEqual(actualManifests,
      ['backup/0000000000.csv', 'backup/0000000001.csv'],
      'Expected two manifests')
  })
})</code></pre>
<pre title="test-backup.txt"><code class="language-txt">&gt; stjs@1.0.0 test /u/stjs
&gt; mocha */test/test-*.js "-g" "check entire backup process"

ReferenceError: require is not defined
    at file:///u/stjs/layout-engine/test/test-easy-mode.js:1:16
    at ModuleJob.run (internal/modules/esm/module_job.js:146:23)
    at async Loader.import (internal/modules/esm/loader.js:165:24)
    at async Object.exports.loadFilesAsync (/u/stjs/node_modules/mocha/lib/esm-utils.js:33:20)
    at async singleRun (/u/stjs/node_modules/mocha/lib/cli/run-helpers.js:156:3)
    at async Object.exports.handler (/u/stjs/node_modules/mocha/lib/cli/run.js:366:5)
npm ERR! code ELIFECYCLE
npm ERR! errno 1
npm ERR! stjs@1.0.0 test: `mocha */test/test-*.js "-g" "check entire backup process"`
npm ERR! Exit status 1
npm ERR! 
npm ERR! Failed at the stjs@1.0.0 test script.
npm ERR! This is probably not a problem with npm. There is likely additional logging output above.

npm ERR! A complete log of this run can be found in:
npm ERR!     /Users/gvwilson/.npm/_logs/2020-11-24T12_59_52_253Z-debug.log
</code></pre>
</main>
<footer>
<div class="row">
<div class="left3">
<a href="../unit-test/"><em>&laquo; Unit Testing</em></a>
</div>
<div class="middle3">
<a href="../license/"><img class="footer" src="../static/cc-by.svg" alt="License" /></a>
<a href="https://github.com/software-tools-in-javascript/stjs/"><img class="footer" src="../static/github.svg" alt="Repository" /></a>
© 2020 <a href="../authors/">The Authors</a>
</div>
<div class="right3">
<a href="../data-table/"><em>Data Tables &raquo;</em></a>
</div>
</div>
</footer>
</body>
</html>
