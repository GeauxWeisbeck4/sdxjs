<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
  <title>File Backup</title>
  <meta name="toRoot" content="..">
  <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
  <link href="../static/site.css" rel="stylesheet" type="text/css">
  <script src="../static/site.js"></script>
  <script>window.onload = () => fixPage()</script>
</head>
<body id="_top">
<nav>
<div class="row">
<div class="left2">
<a href="http://third-bit.com"><img src="../static/logo.svg" alt="site logo" class="site-logo"/></a>
<a href="../"><em>Software Tools in JavaScript</em></a>
</div>
<div class="right2">
<div class="dropdown">
<span class="navtitle">▿ Sections</span>
<div class="dropdown-content" id="Sections">
</div>
</div>
<div class="dropdown">
<span class="navtitle">▿ Chapters</span>
<div class="dropdown-content" id="Chapters">
<a href="../systems-programming/"><span class="nowrap">Systems Programming</span></a>
<br/><a href="../promises/"><span class="nowrap">Promises</span></a>
<br/><a href="../unit-test/"><span class="nowrap">Unit Testing</span></a>
<br/><a href="../file-backup/"><span class="nowrap">File Backup</span></a>
<br/><a href="../data-table/"><span class="nowrap">Data Tables</span></a>
<br/><a href="../pattern-matching/"><span class="nowrap">Pattern Matching</span></a>
<br/><a href="../regex-parser/"><span class="nowrap">Parsing Expressions</span></a>
<br/><a href="../page-templates/"><span class="nowrap">Page Templates</span></a>
<br/><a href="../build-manager/"><span class="nowrap">Build Manager</span></a>
<br/><a href="../layout-engine/"><span class="nowrap">Layout Engine</span></a>
<br/><a href="../text-editor/"><span class="nowrap">Text Editor</span></a>
<br/><a href="../file-interpolator/"><span class="nowrap">File Interpolator</span></a>
<br/><a href="../module-loader/"><span class="nowrap">Module Loader</span></a>
<br/><a href="../module-bundler/"><span class="nowrap">Module Bundler</span></a>
<br/><a href="../package-manager/"><span class="nowrap">Package Manager</span></a>
<br/><a href="../style-checker/"><span class="nowrap">Style Checker</span></a>
<br/><a href="../code-generator/"><span class="nowrap">Code Generator</span></a>
<br/><a href="../doc-generator/"><span class="nowrap">Documentation Generator</span></a>
<br/><a href="../conclusion/"><span class="nowrap">Conclusion</span></a>
</div>
</div>
<div class="dropdown">
<span class="navtitle">▿ Appendices</span>
<div class="dropdown-content" id="Appendices">
<a href="../bib/"><span class="nowrap">Bibliography</span></a>
<br/><a href="../license/"><span class="nowrap">License</span></a>
<br/><a href="../conduct/"><span class="nowrap">Code of Conduct</span></a>
<br/><a href="../contributing/"><span class="nowrap">Contributing</span></a>
<br/><a href="../gloss/"><span class="nowrap">Glossary</span></a>
<br/><a href="../links/"><span class="nowrap">Links</span></a>
<br/><a href="../solutions/"><span class="nowrap">Solutions</span></a>
<br/><a href="../authors/"><span class="nowrap">Authors</span></a>
</div>
</div>
</div>
</div>
</nav>
  <main>
  <h1>File Backup</h1>
  <h2 class="lede">Archiving files with directory structure</h2>
<ul>
<li>Goal: archiving files with an index that identifies each version so that we don't store redundant data</li>
<li>The basis of <a href="https://git-scm.com/">Git</a></li>
</ul>
<h2 id="what-is-a-hash-code-and-how-can-we-create-one-for-a-file">What is a hash code and how can we create one for a file?</h2>
<ul>
<li>A <g key="hash_function">hash function</g> turns arbitrary data into a fixed-length string of bits
<ul>
<li>That bit string can then be used to place the object in a predictable place in a table</li>
<li>Gives reasonably fast lookup for arbitrary keys</li>
</ul>
</li>
<li>A <g key="cryptographic_hash_function">cryptographic hash function</g> produces keys that appear random
<ul>
<li>Leads to the fastest possible lookup on average</li>
</ul>
</li>
<li>Easy to write a bad hash function but hard to write a strong one
<ul>
<li>Use a library to calculate a 160-bit [SHA-1] hash</li>
<li>Not strong enough to deter a well-funded attacker, but that's not what we're using it for</li>
</ul>
</li>
</ul>
<pre title="hash-text.js"><code class="language-js">const crypto = require('crypto')

// create a SHA1 hasher
const hash = crypto.createHash('sha1')

// encode as hex (rather than binary)
hash.setEncoding('hex')

// send it some text
const text = process.argv[2]
hash.write(text)

// signal end of text
hash.end()

// display the result
const sha1sum = hash.read()
console.log(`SHA1 of "${text}" is ${sha1sum}`)
</code></pre>
<pre title="hash-text.sh"><code class="language-sh">node hash-text.js something
</code></pre>
<pre title="hash-text.txt"><code class="language-txt">SHA1 of "something" is 1af17e73721dbe0c40011b82ed4bb1a7dbe3ce29
</code></pre>
<ul>
<li>The hash code for a file:
<ul>
<li>Will always be the same for the same content</li>
<li>Is almost certain to be different if even a single byte differs</li>
</ul>
</li>
</ul>
<pre title="hash-file.js"><code class="language-js">const fs = require('fs')
const crypto = require('crypto')

const filename = process.argv[2]
const data = fs.readFileSync(filename, 'utf-8')

const hash = crypto.createHash('sha1').setEncoding('hex')
hash.write(data)
hash.end()
const sha1sum = hash.read()

console.log(`SHA1 of "${filename}" is ${sha1sum}`)
</code></pre>
<pre title="hash-file.sh"><code class="language-sh">node hash-file.js hash-file.js
</code></pre>
<pre title="hash-file.txt"><code class="language-txt">SHA1 of "hash-file.js" is fc020f5cfb4620e6a45bea19d9960c901e73645e
</code></pre>
<div class="callout">
<h3 id="the-birthday-problem">The Birthday Problem</h3>
<p>The odds that two people share a birthday are 1/365 (ignoring February 29).
The odds that they <em>don't</em> are therefore 364/365.
When we add a third person,
the odds that they don't share a birthday with either of the preceding two people are 363/365,
so the overall odds that nobody shares a birthday are (365/365)×(364/365)×(363/365).
If we keep calculating, there's a 50% chance of two people sharing a birthday in a group of just 23 people,
and a 99.9% chance with 70 people.</p>
<p>We can use the same math to calculate how many files we need to hash before there's a 50% chance of a collision.
Instead of 365, we use 2<sup>160</sup> (the number of values that are 160 bits long),
and quickly get into &quot;if every atom in the universe was a file there still wouldn't be collisions&quot; territory.</p>
</div>
<ul>
<li>More efficient to process the file as a <g key="stream">stream</g>
<ul>
<li>Read the file in chunks</li>
<li>Pass each chunk to an object containing a hashing function, which accumulates a result</li>
<li>Tell the hashing object what to do when the stream finishes</li>
<li>Another example of <g key="asynchronous">asynchronous</g> execution</li>
</ul>
</li>
</ul>
<pre title="hash-stream.js"><code class="language-js">const fs = require('fs')
const crypto = require('crypto')

const filename = process.argv[2]
const hash = crypto.createHash('sha1').setEncoding('hex')
fs.createReadStream(filename).pipe(hash)
hash.on('finish', () =&gt; {
  const final = hash.read()
  console.log('final', final)
})
console.log('program ends')
</code></pre>
<pre title="hash-stream.sh"><code class="language-sh">node hash-stream.js hash-stream.js
</code></pre>
<pre title="hash-stream.txt"><code class="language-txt">program ends
final 52f49aaf0f17fc5236571aeb045866f44ce5c31c
</code></pre>
<ul>
<li>Many files don't change after they're created, or only change very slowly</li>
<li>Wasteful to copy them every time a backup is done</li>
<li>Instead:
<ul>
<li>Copy each file to something like <code>abcd1234.bck</code> where <code>abcd1234</code> is a hash of the file's contents</li>
<li>Store a data structure that records filenames and hash keys at a particular instant</li>
<li>To restore from a particular date, copy saved files to where they need to be</li>
</ul>
</li>
</ul>
<h2 id="how-can-async-and-await-simplify-code">How can async and await simplify code?</h2>
<ul>
<li>Step 1: find all files and calculate their hashes</li>
</ul>
<pre title="hash-existing-promise.js"><code class="language-js">const fs = require('fs-extra-promise')
const glob = require('glob-promise')
const crypto = require('crypto')

const statPath = (path) =&gt; {
  return new Promise((resolve, reject) =&gt; {
    fs.statAsync(path)
      .then(stat =&gt; resolve([path, stat]))
      .catch(err =&gt; reject(err))
  })
}

const readPath = (path) =&gt; {
  return new Promise((resolve, reject) =&gt; {
    fs.readFileAsync(path, 'utf-8')
      .then(content =&gt; resolve([path, content]))
      .catch(err =&gt; reject(err))
  })
}

const hashPath = (path, content) =&gt; {
  const hasher = crypto.createHash('sha1').setEncoding('hex')
  hasher.write(content)
  hasher.end()
  return [path, hasher.read()]
}

const hashExisting = (rootDir) =&gt; {
  const pattern = `${rootDir}/**/*`
  const options = {}
  return new Promise((resolve, reject) =&gt; {
    glob(pattern, options)
      .then(matches =&gt; Promise.all(
        matches.map(path =&gt; statPath(path))))
      .then(pairs =&gt; pairs.filter(
        ([path, stat]) =&gt; stat.isFile()))
      .then(pairs =&gt; Promise.all(
        pairs.map(([path, stat]) =&gt; readPath(path))))
      .then(pairs =&gt; Promise.all(
        pairs.map(([path, content]) =&gt; hashPath(path, content))))
      .then(pairs =&gt; resolve(pairs))
      .catch(err =&gt; reject(err))
  })
}

module.exports = hashExisting
</code></pre>
<pre title="run-hash-existing-promise.js"><code class="language-js">const hashExisting = require('./hash-existing-promise')

const root = process.argv[2]
hashExisting(root).then(pairs =&gt; pairs.forEach(
  ([path, hash]) =&gt; console.log(path, hash)
))
</code></pre>
<pre title="run-hash-existing-promise.sh"><code class="language-sh">node run-hash-existing-promise.js . | fgrep -v test/ | fgrep -v '~'
</code></pre>
<pre title="run-hash-existing-promise.txt"><code class="language-txt">./backup.js d84c7745903487e6c78a66d57c844fab4ca4f466
./check-existing-files.js f5eb035281ecdb102a04de63825b09e281906fe1
./hash-existing-async.js f4c6d88d454d2f9bb934895d7b9b49ea4f499e31
./hash-existing-promise.js 93be774fccb0a158ac9717a2b42f2f0e4d2dd348
./hash-file.js fc020f5cfb4620e6a45bea19d9960c901e73645e
./hash-file.sh ff2f263c71ce98338adf4a8a65c297c9361e3e16
./hash-file.txt 5389eabe373934cff3e6ff46b38f0b537cd4327c
./hash-stream.js 52f49aaf0f17fc5236571aeb045866f44ce5c31c
./hash-stream.sh 0dd6064f3005e832fef580f3de7fa0980fd81dee
./hash-stream.txt 6e9d457a11045ae45648f1304dfc475812a9999c
./hash-text.js a24ffa3e38e2fde2bffe00d5f64e3c5e52de58c5
./hash-text.sh 4e85b91c9254c77cf887d2ca92ea0a8ed60c14b7
./hash-text.txt 4ae882fbcd46e408c9a0548f6547158bc982b40a
./index.md 3e25837fa6ab9ca4edd87397a15d0938f12809aa
./Makefile b96c8f89ba7d0f8af0edcfc70221d24032d805a7
./run-hash-existing-async.js 631b64d887b3cb61c75b97a80cf2111c1ac0c023
./run-hash-existing-async.sh 77ef1cf657fc61f6b47b5313e69973830225cb1d
./run-hash-existing-async.txt da29228a695898632fc3d20c7006881a244a42b2
./run-hash-existing-promise.js 49ff10453c0d12f1936d7045df069ffd2c9090b8
./run-hash-existing-promise.sh 7d7470ac520fc1f368d97fd0d061e17caacea83b
./run-hash-existing-promise.txt da39a3ee5e6b4b0d3255bfef95601890afd80709
./test-backup.sh 7ab530fdf93cf27e199eac259925502bad55e08b
./test-check-filesystem.sh d3621575780a3bd2ed97fb8d703555c8ea667b80
./tree-test.sh 0947bbdf779e1ebb8919e94b556da6b62114c114
</code></pre>
<ul>
<li>This code is clearer than it would be with callbacks, but the layer of promises around everything still obscures meaning</li>
<li>Let's rewrite it using <code>async</code> and <code>await</code></li>
</ul>
<pre title="hash-existing-async.js"><code class="language-js">const fs = require('fs-extra-promise')
const glob = require('glob-promise')
const crypto = require('crypto')

const statPath = async (path) =&gt; {
  const stat = await fs.statAsync(path)
  return [path, stat]
}

const readPath = async (path) =&gt; {
  const content = await fs.readFileAsync(path, 'utf-8')
  return [path, content]
}

const hashPath = (path, content) =&gt; {
  const hasher = crypto.createHash('sha1').setEncoding('hex')
  hasher.write(content)
  hasher.end()
  return [path, hasher.read()]
}

const hashExisting = async (rootDir) =&gt; {
  const pattern = `${rootDir}/**/*`
  const options = {}
  const matches = await glob(pattern, options)
  const stats = await Promise.all(matches.map(path =&gt; statPath(path)))
  const files = stats.filter(([path, stat]) =&gt; stat.isFile())
  const contents = await Promise.all(
    files.map(([path, stat]) =&gt; readPath(path)))
  const hashes = contents.map(
    ([path, content]) =&gt; hashPath(path, content))
  return hashes
}

module.exports = hashExisting
</code></pre>
<pre title="run-hash-existing-async.js"><code class="language-js">const hashExisting = require('./hash-existing-async')

const root = process.argv[2]
hashExisting(root).then(
  pairs =&gt; pairs.forEach(([path, hash]) =&gt; console.log(path, hash)))
</code></pre>
<pre title="run-hash-existing-async.sh"><code class="language-sh">node run-hash-existing-async.js . | fgrep -v test/ | fgrep -v '~'
</code></pre>
<pre title="run-hash-existing-async.txt"><code class="language-txt">./backup.js d84c7745903487e6c78a66d57c844fab4ca4f466
./check-existing-files.js f5eb035281ecdb102a04de63825b09e281906fe1
./hash-existing-async.js f4c6d88d454d2f9bb934895d7b9b49ea4f499e31
./hash-existing-promise.js 93be774fccb0a158ac9717a2b42f2f0e4d2dd348
./hash-file.js fc020f5cfb4620e6a45bea19d9960c901e73645e
./hash-file.sh ff2f263c71ce98338adf4a8a65c297c9361e3e16
./hash-file.txt 5389eabe373934cff3e6ff46b38f0b537cd4327c
./hash-stream.js 52f49aaf0f17fc5236571aeb045866f44ce5c31c
./hash-stream.sh 0dd6064f3005e832fef580f3de7fa0980fd81dee
./hash-stream.txt 6e9d457a11045ae45648f1304dfc475812a9999c
./hash-text.js a24ffa3e38e2fde2bffe00d5f64e3c5e52de58c5
./hash-text.sh 4e85b91c9254c77cf887d2ca92ea0a8ed60c14b7
./hash-text.txt 4ae882fbcd46e408c9a0548f6547158bc982b40a
./index.md 3e25837fa6ab9ca4edd87397a15d0938f12809aa
./Makefile b96c8f89ba7d0f8af0edcfc70221d24032d805a7
./run-hash-existing-async.js 631b64d887b3cb61c75b97a80cf2111c1ac0c023
./run-hash-existing-async.sh 77ef1cf657fc61f6b47b5313e69973830225cb1d
./run-hash-existing-async.txt da39a3ee5e6b4b0d3255bfef95601890afd80709
./run-hash-existing-promise.js 49ff10453c0d12f1936d7045df069ffd2c9090b8
./run-hash-existing-promise.sh 7d7470ac520fc1f368d97fd0d061e17caacea83b
./test-backup.sh 7ab530fdf93cf27e199eac259925502bad55e08b
./test-check-filesystem.sh d3621575780a3bd2ed97fb8d703555c8ea667b80
./tree-test.sh 0947bbdf779e1ebb8919e94b556da6b62114c114
</code></pre>
<h2 id="how-can-we-test-javascript">How can we test JavaScript?</h2>
<ul>
<li>Step 2: see which files have and haven't been backed up already
<ul>
<li>Backup directory contains <code>abcd1234.bck</code> (backup files) and <code>ssssssssss.csv</code> (manifest files),
where <code>ssssssssss</code> is the <g key="utc">UTC</g> <g key="timestamp">timestamp</g> of the backup's creation</li>
<li>We assume no more than one backup per second (which is unsafe in practice)</li>
</ul>
</li>
</ul>
<pre title="check-existing-files.js"><code class="language-js">const glob = require('glob-promise')
const path = require('path')

const findNewFiles = async (rootDir, pathHashPairs) =&gt; {
  const hashToPath = pathHashPairs.reduce((obj, [path, hash]) =&gt; {
    obj[hash] = path
    return obj
  }, {})

  const pattern = `${rootDir}/*.bck`
  const options = {}
  const existingFiles = await glob(pattern, options)

  existingFiles.forEach(filename =&gt; {
    const stripped = path.basename(filename).replace(/\.bck$/, '')
    delete hashToPath[stripped]
  })

  return hashToPath
}

module.exports = findNewFiles
</code></pre>
<ul>
<li>Manually create testing directories with manufactured (shortened) hashes</li>
</ul>
<pre title="tree-test.sh"><code class="language-sh">tree --charset unicode test
</code></pre>
<pre title="tree-test.txt"><code class="language-txt">test
|-- bck-0-csv-0
|-- bck-1-csv-1
|   |-- 0001.csv
|   `-- abcd1234.bck
|-- bck-4-csv-2
|   |-- 0001.csv
|   |-- 3028.csv
|   |-- 3456cdef.bck
|   |-- abcd1234.bck
|   `-- bcde2345.bck
|-- test-backup.js
|-- test-find-mock.js
`-- test-find.js

3 directories, 10 files
</code></pre>
<ul>
<li>Use <a href="https://mochajs.org/">Mocha</a> for testing
<ul>
<li>All tests are written using <code>async</code></li>
<li>Mocha will automatically wait for them to complete before reporting results</li>
<li>Add <code>&quot;test&quot;: &quot;mocha */test/test-*.js&quot;</code> to the <code>scripts</code> key of <code>package.json</code>,
since we may add tests for other things later</li>
</ul>
</li>
</ul>
<pre title="test/test-find.js"><code class="language-js">const assert = require('assert')

const findNewFiles = require('../check-existing-files')

describe('checks for pre-existing hashes using actual filesystem', () =&gt; {
  it('finds no pre-existing files when none given and none exist', async () =&gt; {
    const expected = {}
    const actual = await findNewFiles('file-backup/test/bck-0-csv-0', [])
    assert.deepStrictEqual(expected, actual,
      'Expected no files')
  })

  it('finds some files when one file is given and none exist', async () =&gt; {
    const candidates = [['somefile.txt', '9876fedc']]
    const expected = { '9876fedc': 'somefile.txt' }
    const actual = await findNewFiles('file-backup/test/bck-0-csv-0', candidates)
    assert.deepStrictEqual(expected, actual,
      'Expected one file')
  })

  it('finds nothing needs backup when there is a match', async () =&gt; {
    const candidates = [['alpha.js', 'abcd1234']]
    const expected = {}
    const actual = await findNewFiles('file-backup/test/bck-1-csv-1', candidates)
    assert.deepStrictEqual(expected, actual,
      'Expected no files')
  })

  it('finds something needs backup when there is a mismatch', async () =&gt; {
    const candidates = [['alpha.js', 'a1b2c3d4']]
    const expected = { a1b2c3d4: 'alpha.js' }
    const actual = await findNewFiles('file-backup/test/bck-1-csv-1', candidates)
    assert.deepStrictEqual(expected, actual,
      'Expected one file')
  })

  it('finds mixed matches', async () =&gt; {
    const candidates = [
      ['matches.js', '3456cdef'],
      ['matches.txt', 'abcd1234'],
      ['mismatch.txt', '12345678']
    ]
    const expected = { 12345678: 'mismatch.txt' }
    const actual = await findNewFiles('file-backup/test/bck-4-csv-2', candidates)
    assert.deepStrictEqual(expected, actual,
      'Expected one file')
  })
})
</code></pre>
<pre title="test-check-filesystem.txt"><code class="language-txt">&gt; e@1.0.0 test /u/stjs
&gt; mocha */test/test-*.js "-g" "pre-existing hashes"
  checks for pre-existing hashes using mock filesystem
    ✓ finds no pre-existing files when none given and none exist
    ✓ finds some files when one file is given and none exist
    ✓ finds nothing needs backup when there is a match
    ✓ finds something needs backup when there is a mismatch
    ✓ finds mixed matches
  checks for pre-existing hashes using actual filesystem
    ✓ finds no pre-existing files when none given and none exist
    ✓ finds some files when one file is given and none exist
    ✓ finds nothing needs backup when there is a match
    ✓ finds something needs backup when there is a mismatch
    ✓ finds mixed matches
  10 passing (27ms)
</code></pre>
<h2 id="how-can-we-test-code-that-modifies-files">How can we test code that modifies files?</h2>
<ul>
<li>Step 3: copy the files that need copying and create a new timestamped <g key="csv">CSV</g> file
<ul>
<li>Could use JSON, but CSV is easier for humans to read</li>
</ul>
</li>
<li>The code itself will be relatively simple, but setup and cleanup will be annoying</li>
<li>Better solution: use a <g key="mock_object">mock object</g> instead of the real filesystem
<ul>
<li>Has the same interface as the real function/object/class/library</li>
<li>But works differently for testing purposes</li>
</ul>
</li>
<li>Install <a href="https://www.npmjs.com/package/mock-fs"><code>mock-fs</code></a></li>
<li>Create a mock filesystem with a JSON description of files and their contents</li>
<li>Repeat previous tests using mock
<ul>
<li>Results stay the same</li>
</ul>
</li>
</ul>
<pre title="test/test-find-mock.js"><code class="language-js">const assert = require('assert')
const mock = require('mock-fs')

const findNewFiles = require('../check-existing-files')

describe('checks for pre-existing hashes using mock filesystem', () =&gt; {
  beforeEach(() =&gt; {
    mock({
      'bck-0-csv-0': {},
      'bck-1-csv-1': {
        '0001.csv': 'alpha.js,abcd1234',
        'abcd1234.bck': 'alpha.js content'
      },
      'bck-4-csv-2': {
        '0001.csv': ['alpha.js,abcd1234',
          'beta.txt,bcde2345'].join('\n'),
        '3024.csv': ['alpha.js,abcd1234',
          'gamma.png,3456cdef',
          'subdir/renamed.txt,bcde2345'].join('\n'),
        '3456cdef.bck': 'gamma.png content',
        'abcd1234.bck': 'alpha content',
        'bcde2345.bck': 'beta.txt became subdir/renamed.txt'
      }
    })
  })

  afterEach(() =&gt; {
    mock.restore()
  })

  it('finds no pre-existing files when none given and none exist', async () =&gt; {
    const expected = {}
    const actual = await findNewFiles('bck-0-csv-0', [])
    assert.deepStrictEqual(expected, actual,
      'Expected no files')
  })

  it('finds some files when one file is given and none exist', async () =&gt; {
    const candidates = [['somefile.txt', '9876fedc']]
    const expected = { '9876fedc': 'somefile.txt' }
    const actual = await findNewFiles('bck-0-csv-0', candidates)
    assert.deepStrictEqual(expected, actual,
      'Expected one file')
  })

  it('finds nothing needs backup when there is a match', async () =&gt; {
    const candidates = [['alpha.js', 'abcd1234']]
    const expected = {}
    const actual = await findNewFiles('bck-1-csv-1', candidates)
    assert.deepStrictEqual(expected, actual,
      'Expected no files')
  })

  it('finds something needs backup when there is a mismatch', async () =&gt; {
    const candidates = [['alpha.js', 'a1b2c3d4']]
    const expected = { a1b2c3d4: 'alpha.js' }
    const actual = await findNewFiles('bck-1-csv-1', candidates)
    assert.deepStrictEqual(expected, actual,
      'Expected one file')
  })

  it('finds mixed matches', async () =&gt; {
    const candidates = [['matches.js', '3456cdef'],
      ['matches.txt', 'abcd1234'],
      ['mismatch.txt', '12345678']]
    const expected = { 12345678: 'mismatch.txt' }
    const actual = await findNewFiles('bck-4-csv-2', candidates)
    assert.deepStrictEqual(expected, actual,
      'Expected one file')
  })
})
</code></pre>
<ul>
<li>Now write the code that does the file copying</li>
</ul>
<pre title="backup.js"><code class="language-js">const fs = require('fs-extra-promise')

const hashExisting = require('./hash-existing-async')
const findNewFiles = require('./check-existing-files')

const backup = async (src, dst, timestamp = null) =&gt; {
  if (timestamp === null) {
    timestamp = Math.round((new Date()).getTime() / 1000)
  }
  timestamp = String(timestamp).padStart(10, '0')

  const existing = await hashExisting(src)
  const needToCopy = await findNewFiles(dst, existing)
  await copyFiles(dst, needToCopy)
  await saveManifest(dst, timestamp, existing)
}

const copyFiles = async (dst, needToCopy) =&gt; {
  const promises = Object.keys(needToCopy).map(hash =&gt; {
    const srcPath = needToCopy[hash]
    const dstPath = `${dst}/${hash}.bck`
    fs.copyFileAsync(srcPath, dstPath)
  })
  return Promise.all(promises)
}

const saveManifest = async (dst, timestamp, pathHash) =&gt; {
  pathHash = pathHash.sort()
  const content = pathHash.map(
    ([path, hash]) =&gt; `${path},${hash}`).join('\n')
  const manifest = `${dst}/${timestamp}.csv`
  fs.writeFileAsync(manifest, content, 'utf-8')
}

module.exports = backup
</code></pre>
<ul>
<li>And some tests
<ul>
<li>Which are quite involved, since we want to check with actual file hashes</li>
</ul>
</li>
<li>Set up some fixtures</li>
</ul>
<pre title="test/test-backup.js"><code class="language-js">const backup = require('../backup')

const hashString = (data) =&gt; {
  const hasher = crypto.createHash('sha1').setEncoding('hex')
  hasher.write(data)
  hasher.end()
  return hasher.read()
}

const Contents = {
  aaa: 'AAA',
  bbb: 'BBB',
  ccc: 'CCC'
}

const Hashes = Object.keys(Contents).reduce((obj, key) =&gt; {
  obj[key] = hashString(Contents[key])
  return obj
}, {})

const Fixture = {
  source: {
    'alpha.txt': Contents.aaa,
    'beta.txt': Contents.bbb,
    gamma: {
      'delta.txt': Contents.ccc
    }
  },
  backup: {}
}

const InitialBackups = Object.keys(Hashes).reduce((set, filename) =&gt; {
  set.add(`backup/${Hashes[filename]}.bck`)
  return set
}, new Set())</code></pre>
<ul>
<li>And then run some tests</li>
</ul>
<pre title="test/test-backup.js"><code class="language-js">describe('check entire backup process', () =&gt; {
  beforeEach(() =&gt; {
    mock(Fixture)
  })

  afterEach(() =&gt; {
    mock.restore()
  })

  it('creates an initial CSV manifest', async () =&gt; {
    await backup('source', 'backup', 0)

    assert.strictEqual((await glob('backup/*')).length, 4,
      'Expected 4 files')

    const actualBackups = new Set(await glob('backup/*.bck'))
    assert.deepStrictEqual(actualBackups, InitialBackups,
      'Expected 3 backup files')

    const actualManifests = await glob('backup/*.csv')
    assert.deepStrictEqual(actualManifests, ['backup/0000000000.csv'],
      'Expected one manifest')
  })

  it('does not duplicate files unnecessarily', async () =&gt; {
    await backup('source', 'backup', 0)
    assert.strictEqual((await glob('backup/*')).length, 4,
      'Expected 4 files after first backup')

    await backup('source', 'backup', 1)
    assert.strictEqual((await glob('backup/*')).length, 5,
      'Expected 5 files after second backup')
    const actualBackups = new Set(await glob('backup/*.bck'))
    assert.deepStrictEqual(actualBackups, InitialBackups,
      'Expected 3 backup files after second backup')

    const actualManifests = (await glob('backup/*.csv')).sort()
    assert.deepStrictEqual(actualManifests,
      ['backup/0000000000.csv', 'backup/0000000001.csv'],
      'Expected two manifests')
  })

  it('adds a file as needed', async () =&gt; {
    await backup('source', 'backup', 0)
    assert.strictEqual((await glob('backup/*')).length, 4,
      'Expected 4 files after first backup')

    await fs.writeFileAsync('source/newfile.txt', 'NNN')
    const hashOfNewFile = hashString('NNN')

    await backup('source', 'backup', 1)
    assert.strictEqual((await glob('backup/*')).length, 6,
      'Expected 6 files after second backup')
    const expected = new Set(InitialBackups).add(`backup/${hashOfNewFile}.bck`)
    const actualBackups = new Set(await glob('backup/*.bck'))
    assert.deepStrictEqual(actualBackups, expected,
      'Expected 4 backup files after second backup')

    const actualManifests = (await glob('backup/*.csv')).sort()
    assert.deepStrictEqual(actualManifests,
      ['backup/0000000000.csv', 'backup/0000000001.csv'],
      'Expected two manifests')
  })
})</code></pre>
<pre title="test-backup.txt"><code class="language-txt">&gt; e@1.0.0 test /u/stjs
&gt; mocha */test/test-*.js "-g" "check entire backup process"
  check entire backup process
    ✓ creates an initial CSV manifest
    ✓ does not duplicate files unnecessarily
    ✓ adds a file as needed
  3 passing (43ms)
</code></pre>
</main>
<footer>
<div class="row">
<div class="left3">
<a href="../unit-test/"><em>&laquo; Unit Testing</em></a>
</div>
<div class="middle3">
<a href="../license/"><img class="footer" src="../static/cc-by.svg" alt="License" /></a>
<a href="https://github.com/software-tools-in-javascript/stjs/"><img class="footer" src="../static/github.svg" alt="Repository" /></a>
© 2020 <a href="../authors/">The Authors</a>
</div>
<div class="right3">
<a href="../data-table/"><em>Data Tables &raquo;</em></a>
</div>
</div>
</footer>
</body>
</html>
