<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
  <title>HTTP Server</title>
  <meta name="toRoot" content="..">
  <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
  <link href="../static/site.css" rel="stylesheet" type="text/css">
  <script src="../static/site.js"></script>
  <script>window.onload = () => fixPage()</script>
</head>
<body id="_top">
<nav>
<div class="row">
<div class="left2">
<a href="http://third-bit.com"><img src="../static/logo.svg" alt="site logo" class="site-logo"/></a>
<a href="../"><em>Software Tools in JavaScript</em></a>
</div>
<div class="right2">
<div class="dropdown">
<span class="navtitle">▿ Sections</span>
<div class="dropdown-content" id="Sections">
</div>
</div>
<div class="dropdown">
<span class="navtitle">▿ Chapters</span>
<div class="dropdown-content" id="Chapters">
<a href="../systems-programming/"><span class="nowrap">Systems Programming</span></a>
<br/><a href="../promises/"><span class="nowrap">Promises</span></a>
<br/><a href="../unit-test/"><span class="nowrap">Unit Testing</span></a>
<br/><a href="../file-backup/"><span class="nowrap">File Backup</span></a>
<br/><a href="../style-checker/"><span class="nowrap">Style Checker</span></a>
<br/><a href="../pattern-matching/"><span class="nowrap">Pattern Matching</span></a>
<br/><a href="../regex-parser/"><span class="nowrap">Parsing Expressions</span></a>
<br/><a href="../code-generator/"><span class="nowrap">Code Generator</span></a>
<br/><a href="../page-templates/"><span class="nowrap">Page Templates</span></a>
<br/><a href="../doc-generator/"><span class="nowrap">Documentation Generator</span></a>
<br/><a href="../file-interpolator/"><span class="nowrap">File Interpolator</span></a>
<br/><a href="../module-loader/"><span class="nowrap">Module Loader</span></a>
<br/><a href="../module-bundler/"><span class="nowrap">Module Bundler</span></a>
<br/><a href="../layout-engine/"><span class="nowrap">Layout Engine</span></a>
<br/><a href="../text-editor/"><span class="nowrap">Text Editor</span></a>
<br/><a href="../http-server/"><span class="nowrap">HTTP Server</span></a>
<br/><a href="../build-manager/"><span class="nowrap">Build Manager</span></a>
<br/><a href="../package-manager/"><span class="nowrap">Package Manager</span></a>
<br/><a href="../issue-tracker/"><span class="nowrap">Issue Tracker</span></a>
<br/><a href="../conclusion/"><span class="nowrap">Conclusion</span></a>
</div>
</div>
<div class="dropdown">
<span class="navtitle">▿ Appendices</span>
<div class="dropdown-content" id="Appendices">
<a href="../bib/"><span class="nowrap">Bibliography</span></a>
<br/><a href="../license/"><span class="nowrap">License</span></a>
<br/><a href="../conduct/"><span class="nowrap">Code of Conduct</span></a>
<br/><a href="../contributing/"><span class="nowrap">Contributing</span></a>
<br/><a href="../gloss/"><span class="nowrap">Glossary</span></a>
<br/><a href="../links/"><span class="nowrap">Links</span></a>
<br/><a href="../solutions/"><span class="nowrap">Solutions</span></a>
<br/><a href="../authors/"><span class="nowrap">Authors</span></a>
</div>
</div>
</div>
</div>
</nav>
  <main>
  <h1>HTTP Server</h1>
  <p class="lede">Serving files and data</p>
<p>An HTTP server similar to <a href="https://expressjs.com/">Express</a>
modeled on <a href="http://aosabook.org/en/500L/a-simple-web-server.html">this one in Python</a>.</p>
<h2 id="how-can-we-send-messages-via-sockets">How can we send messages via sockets?</h2>
<ul>
<li>A simple socket client</li>
</ul>
<pre title="simple-socket-client.js"><code class="language-js">const net = require('net')

const client = new net.Socket()
client.connect(8080, '127.0.0.1', () =&gt; {
  console.log('client connected')
  client.write('message from client')
})

client.on('data', (data) =&gt; {
  console.log(`client received ${data}`)
  client.destroy()
})

client.on('close', () =&gt; {
  console.log('client connection closed')
})
</code></pre>
<ul>
<li>A very simple socket server</li>
</ul>
<pre title="simple-socket-server.js"><code class="language-js">const Net = require('net')

const port = 8080

const server = new Net.Server()

server.listen(port, () =&gt; {
  console.log(`server listening on localhost:${port}`)
})

server.on('connection', (socket) =&gt; {
  console.log('server new connection')

  socket.write('message from server')

  socket.on('data', (data) =&gt; {
    console.log(`server received from client: ${data.toString()}`)
  })

  socket.on('end', () =&gt; {
    console.log('server ending connection')
  })

  socket.on('close', () =&gt; {
    console.log('server closing socket')
  })

  socket.on('error', (err) =&gt; {
    console.log(`server error: ${err}`)
  })
})
</code></pre>
<ul>
<li>Displaying what happens when they run is tricky, since events are interleaved</li>
<li>When developing, run in separate windows</li>
<li>For this tutorial:
<ul>
<li>Run the server</li>
<li>Wait one second to make sure it's listening
<ul>
<li>Which isn't &quot;sure&quot;</li>
</ul>
</li>
<li>Run the client</li>
<li>Kill the server</li>
</ul>
</li>
</ul>
<pre title="run-simple-socket.sh"><code class="language-sh">node simple-socket-server.js &amp;
sleep 1
node simple-socket-client.js
kill %1
</code></pre>
<pre title="run-simple-socket.txt"><code class="language-txt">server listening on localhost:8080
server new connection
client connected
server received from client: message from client
client received message from server
client connection closed
server ending connection
server closing socket
</code></pre>
<ul>
<li>Most of this stays the same from example to example
<ul>
<li>So allow user to specify the name of a data handler from the command line</li>
</ul>
</li>
<li>What stays the same:</li>
</ul>
<pre title="socket-server.js"><code class="language-js">const Net = require('net')

const handlerName = process.argv[2]
const handlerFactory = require(handlerName)

const port = 8080

const server = new Net.Server()

let numRequests = 0

server.listen(port, () =&gt; {
  console.log(`server listening on localhost:${port}`)
})

server.on('connection', (socket) =&gt; {
  numRequests += 1
  console.log(`server new connection ${numRequests}`)

  socket.on('data', handlerFactory(socket))

  socket.on('end', () =&gt; {
    console.log('server ending connection')
  })

  socket.on('close', () =&gt; {
    console.log('server closing socket')
  })

  socket.on('error', (err) =&gt; {
    console.log(`server error: ${err}`)
  })
})
</code></pre>
<h2 id="how-can-we-decompose-the-server">How can we decompose the server?</h2>
<ul>
<li>The handler needs to know the socket, but the callback only takes the data
<ul>
<li>So the handler takes a socket as an argument and returns a function that takes data</li>
<li>Call it <code>handlerFactory</code> to make clear that it creates a function</li>
</ul>
</li>
</ul>
<pre title="always-send-success.js"><code class="language-js">const handlerFactory = (socket) =&gt; (data) =&gt; {
  console.log(`server received from client: ${data.toString()}`)
  socket.write('SUCCESS')
}

module.exports = handlerFactory
</code></pre>
<ul>
<li>Try running</li>
</ul>
<pre title="always-send-success.sh"><code class="language-sh">node socket-server.js ./always-send-success &amp;
sleep 1
node simple-socket-client.js
kill %1
</code></pre>
<pre title="always-send-success.txt"><code class="language-txt">server listening on localhost:8080
server new connection 1
client connected
server received from client: message from client
client received SUCCESS
client connection closed
server ending connection
server closing socket
</code></pre>
<h2 id="how-do-http-requests-and-responses-work">How do HTTP requests and responses work?</h2>
<ul>
<li>Now try constructing an HTTP response
<ul>
<li>Ignore the incoming path</li>
</ul>
</li>
</ul>
<pre title="http-response-success.js"><code class="language-js">const Header = `HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 7

`

const handlerFactory = (socket) =&gt; (data) =&gt; {
  console.log(`server received from client: ${data.toString()}`)
  socket.write(Header + 'SUCCESS')
}

module.exports = handlerFactory
</code></pre>
<ul>
<li>Go to <code>http://localhost:8080</code> with a browser
<ul>
<li>Browser sends two requests: one for <code>/</code> and one for <code>/favicon.ico</code></li>
<li>Includes <code>User-Agent</code>, <code>Accept</code>, <code>Accept-Language</code>, and other headers</li>
</ul>
</li>
</ul>
<pre title="http-response-browser.txt"><code class="language-txt">server listening on localhost:8080
server new connection 1
server received from client: GET / HTTP/1.1
Host: localhost:8080
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:75.0) Gecko/20100101 Firefox/75.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: keep-alive


server received from client: GET /favicon.ico HTTP/1.1
Host: localhost:8080
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:75.0) Gecko/20100101 Firefox/75.0
Accept: image/webp,*/*
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: keep-alive

</code></pre>
<ul>
<li>Now construct an HTTP request
<ul>
<li>Line separators in header must be <code>\r\n</code>, not just <code>\n</code></li>
<li>Header must end with double blank line (to separate it from posted info)</li>
<li>Must convert result data from byte butter to string</li>
<li>Allow user to specify</li>
</ul>
</li>
</ul>
<pre title="http-request-client.js"><code class="language-js">const net = require('net')

const path = (process.argv.length &gt; 2)
  ? process.argv[2]
  : '/'

const request = `GET ${path} HTTP/1.1

`

const client = new net.Socket()
client.connect(8080, '127.0.0.1', () =&gt; {
  client.write(request)
  client.end()
})

client.on('data', (data) =&gt; {
  console.log('client receives:')
  console.log(data.toString())
})

client.on('close', () =&gt; {
})
</code></pre>
<ul>
<li>Run the server and the client
<ul>
<li>Server only sees what we send</li>
</ul>
</li>
</ul>
<pre title="http-response-success.txt"><code class="language-txt">server listening on localhost:8080
server new connection 1
server received from client: GET / HTTP/1.1


client receives:
HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 7

SUCCESS
server ending connection
server closing socket
</code></pre>
<h2 id="how-can-we-test-this">How can we test this?</h2>
<ul>
<li>Unit testing this doesn't have to be hard
<ul>
<li>We have a function that takes something with a <code>.write</code> method and produces a function</li>
<li>That takes some data and writes some text</li>
<li>We can provide a <g key="mock_object">mock object</g> to free our tests from concurrency</li>
</ul>
</li>
<li>Replacement for the socket</li>
</ul>
<pre title="test/socket.js"><code class="language-js">class Socket {
  constructor () {
    this.text = ''
  }

  write (data) {
    this.text += data
  }
}

module.exports = Socket
</code></pre>
<ul>
<li>Unit test</li>
</ul>
<pre title="test/test-http-response-success.js"><code class="language-js">const assert = require('assert')

const Socket = require('./socket')
const handlerFactory = require('../http-response-success')

const REQUEST_HEADER = `GET @path HTTP/1.1

`.replace('\n', '\r\n')

const RESPONSE_HEADER = `HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 7

`.replace('\n', '\r\n')

describe('checks a constant HTTP response', () =&gt; {
  it('constructs a handler and gets a response', async () =&gt; {
    const socket = new Socket()
    const handler = handlerFactory(socket)
    const request = REQUEST_HEADER.replace('@path', '/')
    handler(request)
    const result = socket.text
    assert.strictEqual(result, RESPONSE_HEADER + 'SUCCESS',
      'Wrong response from server')
  })
})
</code></pre>
<ul>
<li>Parse the HTTP request and return text files</li>
</ul>
<pre title="http-response-parse.js"><code class="language-js">const fs = require('fs')

const Header = `HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: @LENGTH

`

const PathPattern = /^GET\s+(.+)\s+HTTP\/1.1/

const handlerFactory = (socket) =&gt; (data) =&gt; {
  let path = data.toString().match(PathPattern)[1]
  if (path.startsWith('/')) {
    path = `.${path}`
  }
  const content = fs.readFileSync(path).toString()
  const header = Header.replace('@LENGTH', content.length)
  socket.write(header)
  socket.write(content)
}

module.exports = handlerFactory
</code></pre>
<pre title="http-response-parse.txt"><code class="language-txt">server listening on localhost:8080
server new connection 1
client receives:
HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 19


client receives:
Contents of File A

server ending connection
server closing socket
</code></pre>
<ul>
<li>But there are three problems
<ol>
<li>Synchronous operation</li>
<li>Not everything is text</li>
<li>Security: if we use the path provided, we can potentially return any file on the system</li>
</ol>
</li>
</ul>
<pre title="breaking-sandbox.sh"><code class="language-sh">node socket-server.js ./http-response-parse &amp;
sleep 1
node http-request-client.js ../files/private.txt
kill %1
</code></pre>
<pre title="breaking-sandbox.txt"><code class="language-txt">server listening on localhost:8080
server new connection 1
client receives:
HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 37


client receives:
This is supposed to be private data.

server ending connection
server closing socket
</code></pre>
<h2 id="how-can-we-make-servers-easier-to-create">How can we make servers easier to create?</h2>
<ul>
<li>Define a base class to wrap up the socket handling and request parsing
<ul>
<li>Sequence is:
<ul>
<li>Parse request to create request object</li>
<li>Initialize response object using values from request</li>
<li>Call a user-defined method to do something useful</li>
<li>Finalize the response object</li>
<li>Send the header and body</li>
</ul>
</li>
<li>A <g key="protocol">protocol</g> for handling requests</li>
<li>A simple example of the <g key="template_method_pattern">Template Method</g> pattern</li>
</ul>
</li>
<li>Use the <a href="https://nodejs.org/docs/latest/api/url.html">url</a> package to parse the request target</li>
</ul>
<pre title="base-http-server.js"><code class="language-js">const Net = require('net')
const url = require('url')

class BaseHttpServer {
  constructor (port = BaseHttpServer.DEFAULT_PORT) {
    this.port = port
    this.server = new Net.Server()
  }

  run () {
    this.server.listen(this.port, () =&gt; {
      console.log(`server listening on localhost:${this.port}`)
    })
    this.server.on('connection', (socket) =&gt; {
      socket.on('data', this.handlerFactory(socket))
      socket.on('error', (err) =&gt; {
        console.log(`server error: ${err}`)
      })
    })
  }

  handlerFactory (socket) {
    return (data) =&gt; {
      const request = this.parseRequest(data.toString())
      const response = this.initializeResponse(request)
      this.handle(request, response)
      this.finalizeResponse(response)
      socket.write(response.header)
      if (response.body) {
        socket.write(response.body)
      }
    }
  }

  parseRequest (data) {
    const raw = data.toString().match(BaseHttpServer.TARGET_PATTERN)[1]
    return {
      url: new url.URL(raw, BaseHttpServer.DEFAULT_HOST)
    }
  }

  initializeResponse (request) {
    return {
      status_code: 200,
      status_message: 'OK',
      content_type: 'text/plain',
      length: null,
      header: null,
      body: null
    }
  }

  finalizeResponse (response) {
    response.length = response.body
      ? response.body.length
      : 0
    response.header = BaseHttpServer.HEADER
    for (const key of BaseHttpServer.KEYS) {
      response.header = response.header.replace(`@${key}`, response[key])
    }
  }

  handle (request, response) {
    response.body = `SUCCESS: ${request.url.pathname}`
  }
}

BaseHttpServer.DEFAULT_HOST = 'http://localhost'
BaseHttpServer.DEFAULT_PORT = 8080

BaseHttpServer.TARGET_PATTERN = /^GET\s+(.+)\s+HTTP\/1.1/

BaseHttpServer.KEYS = [
  'status_code',
  'status_message',
  'content_type',
  'length'
]

BaseHttpServer.HEADER = `HTTP/1.1 @status_code @status_message
Content-Type: @content_type
Content-Length: @length

`

module.exports = BaseHttpServer
</code></pre>
<pre title="test-base-http-server.js"><code class="language-js">const BaseHttpServer = require('./base-http-server')

const server = new BaseHttpServer()
server.run()
</code></pre>
<pre title="test-base-http-server.sh"><code class="language-sh">node test-base-http-server.js &amp;
sleep 1
node http-request-client.js
kill %1
</code></pre>
<pre title="test-base-http-server.txt"><code class="language-txt">server listening on localhost:8080
client receives:
HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 10


client receives:
SUCCESS: /
</code></pre>
<ul>
<li>Serve files</li>
</ul>
<pre title="http-file-server.js"><code class="language-js">const fs = require('fs')
const path = require('path')

const BaseHttpServer = require('./base-http-server')

class HttpFileServer extends BaseHttpServer {
  constructor (rootDir) {
    super()
    this.rootDir = path.resolve(rootDir)
  }

  handle (request, response) {
    let filePath = request.url.pathname
    if (filePath.startsWith('/')) {
      filePath = `./${filePath}`
    }
    if (filePath.endsWith('/')) {
      filePath = `${filePath}index.html`
    }
    filePath = path.resolve(filePath)
    if (!filePath.startsWith(this.rootDir)) {
      response.status_code = 403
      response.status_message = 'Forbidden'
      response.body = 'Requested file is out of bounds'
    } else if (!fs.existsSync(filePath)) {
      response.status_code = 404
      response.status_message = 'Not Found'
      response.body = 'Requested file does not exist'
    } else {
      response.body = fs.readFileSync(filePath)
    }
  }
}

const server = new HttpFileServer(process.argv[2])
server.run()
</code></pre>
<pre title="test-http-file-server.sh"><code class="language-sh">node http-file-server.js . &amp;
sleep 1
echo '- - - - - - - - - - - - - - - - - - - -'
node http-request-client.js /files/a.txt
echo '- - - - - - - - - - - - - - - - - - - -'
node http-request-client.js ../files/private.txt
kill %1
</code></pre>
<pre title="test-http-file-server.txt"><code class="language-txt">server listening on localhost:8080
- - - - - - - - - - - - - - - - - - - -
client receives:
HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 19


client receives:
Contents of File A

- - - - - - - - - - - - - - - - - - - -
client receives:
HTTP/1.1 404 Not Found
Content-Type: text/plain
Content-Length: 29

Requested file does not exist
</code></pre>
<h2 id="how-can-we-parameterize-requests">How can we parameterize requests?</h2>
<ul>
<li>The classic approach uses a <g key="query_string">query string</g>
<ul>
<li><code>http://some.domain/some/path/?firstKey=firstValue&amp;secondKey=secondValue</code></li>
<li>Keys can be repeated</li>
<li>Lands in the <code>.searchParams</code> object of the parsed URL</li>
</ul>
</li>
<li>Server extracts parameters and uses them
<ul>
<li>Should do more checking than this…</li>
</ul>
</li>
</ul>
<pre title="http-params-server.js"><code class="language-js">const BaseHttpServer = require('./base-http-server')

class HttpParamsServer extends BaseHttpServer {
  constructor () {
    super()
    this.messages = new Map([
      ['low', 'LOW'],
      ['moderate', 'MODERATE'],
      ['high', 'HIGH']
    ])
  }

  handle (request, response) {
    const level = request.url.searchParams.get('level') || 'low'
    const message = this.messages.get(level) || `unknown level: ${level}`
    response.body = message
  }
}

const server = new HttpParamsServer()
server.run()
</code></pre>
<ul>
<li>Client builds a query string
<ul>
<li>Should use a library (there are many)</li>
</ul>
</li>
</ul>
<pre title="http-params-client.js"><code class="language-js">const net = require('net')

const query = (process.argv.length &gt; 2)
  ? '?' + process.argv.slice(2)
  : ''

const request = `GET /${query} HTTP/1.1

`

const client = new net.Socket()
client.connect(8080, '127.0.0.1', () =&gt; {
  client.write(request)
  client.end()
})

client.on('data', (data) =&gt; {
  console.log('client receives:')
  console.log(data.toString())
})

client.on('close', () =&gt; {
})
</code></pre>
<ul>
<li>Testing</li>
</ul>
<pre title="test-http-params-server.sh"><code class="language-sh">node http-params-server.js &amp;
sleep 1
echo '- - - - - - - - - - - - - - - - - - - -'
node http-params-client.js level=moderate
echo '- - - - - - - - - - - - - - - - - - - -'
node http-params-client.js unknown=something
kill %1
</code></pre>
<pre title="test-http-params-server.txt"><code class="language-txt">server listening on localhost:8080
- - - - - - - - - - - - - - - - - - - -
client receives:
HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 8


client receives:
MODERATE
- - - - - - - - - - - - - - - - - - - -
client receives:
HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 3

LOW
</code></pre>
<ul>
<li>More modern approach is to send <g key="json">JSON</g>
<ul>
<li>Unlimited [sic] size</li>
<li>Structured data</li>
</ul>
</li>
<li>Use <a href="https://www.npmjs.com/package/got">got</a> to construct request including URL and JSON</li>
</ul>
<pre title="got-json-client.js"><code class="language-js">const got = require('got')

const getter = async (url, word) =&gt; {
  const { body } = await got.post(url, {
    json: { key: word },
    responseType: 'json'
  })
  console.log(body)
}

const url = process.argv[2]
const word = process.argv[3]

getter(url, word)
</code></pre>
<ul>
<li>Finally need to get the <g key="http_header">HTTP headers</g> to check <g key="mime_type">MIME type</g>
<ul>
<li>Convert body of request from text to JSON if the type is <code>application/json</code></li>
</ul>
</li>
</ul>
<pre title="http-json-server.js"><code class="language-js">const url = require('url')

const BaseHttpServer = require('./base-http-server')

class HttpJsonServer extends BaseHttpServer {
  parseRequest (data) {
    data = data.toString()
    const { body } = this.getHeadAndBody(data)
    const [verb, raw, headers] = this.parseHead(data)
    return {
      url: new url.URL(raw, BaseHttpServer.DEFAULT_HOST),
      verb: verb,
      headers: headers,
      body: this.convertBody(headers, body)
    }
  }

  getHeadAndBody (data) {
    const separators = ['\r\n\r\n', '\n\n']
    for (const sep of separators) {
      const loc = data.indexOf(sep)
      if (loc &gt;= 0) {
        const head = data.slice(0, loc)
        const body = data.slice(loc + sep.length)
        return { head, body }
      }
    }
    return ''
  }

  parseHead (head) {
    const lines = head.split('\n')
      .map(line =&gt; line.trim())
      .filter(line =&gt; line.length &gt; 0)
    const parts = lines[0].match(HttpJsonServer.TARGET_PATTERN)
    const verb = parts[1]
    const raw = parts[2]
    const headers = lines.slice(1).reduce((soFar, line) =&gt; {
      const match = line.match(/^\s*(.+?)\s*:\s*(.+)\s*$/)
      const key = match[1].toLowerCase()
      const value = match[2]
      if (!soFar.has(key)) {
        soFar.set(key, [])
      }
      soFar.get(key).push(value)
      return soFar
    }, new Map())
    return [verb, raw, headers]
  }

  convertBody (headers, body) {
    if (headers.get('content-type').includes('application/json')) {
      body = JSON.parse(body)
    }
    return body
  }

  handle (request, response) {
    const value = request.body.key
    response.body = JSON.stringify({ result: value })
  }
}

HttpJsonServer.TARGET_PATTERN = /^(.+?)\s+(.+)\s+HTTP\/1.1/

const server = new HttpJsonServer()
server.run()
</code></pre>
<ul>
<li>After all that, echoing a value back seems like small potatoes
<ul>
<li>We will do more sophisticated things in chapters to come</li>
</ul>
</li>
</ul>
<pre title="test-http-json-server.sh"><code class="language-sh">node http-json-server.js &amp;
sleep 1
echo '- - - - - - - - - - - - - - - - - - - -'
node got-json-client.js http://localhost:8080/ testing
kill %1
</code></pre>
<pre title="test-http-json-server.txt"><code class="language-txt">server listening on localhost:8080
- - - - - - - - - - - - - - - - - - - -
{ result: 'testing' }
</code></pre>
</main>
<footer>
<div class="row">
<div class="left3">
<a href="../text-editor/"><em>&laquo; Text Editor</em></a>
</div>
<div class="middle3">
<a href="../license/"><img class="footer" src="../static/cc-by.svg" alt="License" /></a>
<a href="https://github.com/gvwilson/e/"><img class="footer" src="../static/github.svg" alt="Repository" /></a>
© 2020 <a href="../authors/">The Authors</a>
</div>
<div class="right3">
<a href="../build-manager/"><em>Build Manager &raquo;</em></a>
</div>
</div>
</footer>
</body>
</html>
