<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
  <title>Module Bundler</title>
  <meta name="toRoot" content="..">
  <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
  <link href="../static/site.css" rel="stylesheet" type="text/css">
  <script src="../static/site.js"></script>
  <script>window.onload = () => fixPage()</script>
</head>
<body id="_top">
<nav>
<div class="row">
<div class="left2">
<a href="http://third-bit.com"><img src="../static/logo.svg" alt="site logo" class="site-logo"/></a>
<a href="../"><em>Software Tools in JavaScript</em></a>
</div>
<div class="right2">
<div class="dropdown">
<span class="navtitle">▿ Sections</span>
<div class="dropdown-content" id="Sections">
</div>
</div>
<div class="dropdown">
<span class="navtitle">▿ Chapters</span>
<div class="dropdown-content" id="Chapters">
<a href="../systems-programming/"><span class="nowrap">Systems Programming</span></a>
<br/><a href="../promises/"><span class="nowrap">Promises</span></a>
<br/><a href="../unit-test/"><span class="nowrap">Unit Testing</span></a>
<br/><a href="../file-backup/"><span class="nowrap">File Backup</span></a>
<br/><a href="../data-table/"><span class="nowrap">Data Tables</span></a>
<br/><a href="../pattern-matching/"><span class="nowrap">Pattern Matching</span></a>
<br/><a href="../regex-parser/"><span class="nowrap">Parsing Expressions</span></a>
<br/><a href="../page-templates/"><span class="nowrap">Page Templates</span></a>
<br/><a href="../build-manager/"><span class="nowrap">Build Manager</span></a>
<br/><a href="../layout-engine/"><span class="nowrap">Layout Engine</span></a>
<br/><a href="../text-editor/"><span class="nowrap">Text Editor</span></a>
<br/><a href="../file-interpolator/"><span class="nowrap">File Interpolator</span></a>
<br/><a href="../module-loader/"><span class="nowrap">Module Loader</span></a>
<br/><a href="../module-bundler/"><span class="nowrap">Module Bundler</span></a>
<br/><a href="../package-manager/"><span class="nowrap">Package Manager</span></a>
<br/><a href="../style-checker/"><span class="nowrap">Style Checker</span></a>
<br/><a href="../code-generator/"><span class="nowrap">Code Generator</span></a>
<br/><a href="../doc-generator/"><span class="nowrap">Documentation Generator</span></a>
<br/><a href="../virtual-machine/"><span class="nowrap">Virtual Machine</span></a>
<br/><a href="../conclusion/"><span class="nowrap">Conclusion</span></a>
</div>
</div>
<div class="dropdown">
<span class="navtitle">▿ Appendices</span>
<div class="dropdown-content" id="Appendices">
<a href="../bib/"><span class="nowrap">Bibliography</span></a>
<br/><a href="../license/"><span class="nowrap">License</span></a>
<br/><a href="../conduct/"><span class="nowrap">Code of Conduct</span></a>
<br/><a href="../contributing/"><span class="nowrap">Contributing</span></a>
<br/><a href="../gloss/"><span class="nowrap">Glossary</span></a>
<br/><a href="../links/"><span class="nowrap">Links</span></a>
<br/><a href="../solutions/"><span class="nowrap">Solutions</span></a>
<br/><a href="../authors/"><span class="nowrap">Authors</span></a>
</div>
</div>
</div>
</div>
</nav>
  <main>
  <h1>Module Bundler</h1>
  <h2 class="lede">Turning many files into one</h2>
<ul>
<li>JavaScript was designed in a hurry 25 years ago to make pages interactive
<ul>
<li>Nobody realized it would become one of the most popular programming languages in the world</li>
<li>Which means it didn't include support for things that large programs need</li>
<li>Like creating multi-module bundles so that browsers could load a single file
rather than making dozens or hundreds of requests</li>
</ul>
</li>
<li>A <g key="module_bundler">module bundler</g> finds all the files that a set of source files depend on
and combines them into a single loadable file
<ul>
<li>Much more efficient to load</li>
<li>Ensures that dependencies actually resolve</li>
</ul>
</li>
<li>Requires an <g key="entry_point">entry point</g>
<ul>
<li>Where processing starts</li>
<li>Equivalently, the top level</li>
</ul>
</li>
<li>Need to:
<ul>
<li>Find all dependencies</li>
<li>Combine them into one file</li>
<li>Ensure they can find each other correctly once loaded</li>
</ul>
</li>
<li>Think of test cases before starting to write code
<ul>
<li><g key="tdd">Test-driven development</g> (TDD)</li>
<li>Research doesn't support claims that it makes programmers significantly more productive,
but it helps give direction to this chapter</li>
</ul>
</li>
<li>Case 1: a single file that doesn't require anything else
<ul>
<li>Because if this doesn't work, nothing else will</li>
</ul>
</li>
<li>Case 2: <code>main.js</code> requires <code>other.js</code>, which doesn't require anything
<ul>
<li>First test of dependencies</li>
</ul>
</li>
</ul>
<pre title="expected-simple.txt"><code class="language-txt">other called from main
</code></pre>
<ul>
<li>Case 3: best described with a diagram
<ul>
<li><code>./main</code> requires all four of the files below</li>
<li><code>./top-left</code> doesn't require anything</li>
<li><code>./top-right</code> requires <code>top-left</code> and <code>bottom-right</code></li>
<li><code>./subdir/bottom-left</code> also requires <code>top-left</code> and <code>bottom-right</code></li>
<li><code>./subdir/bottom-right</code> doesn't require anything</li>
</ul>
</li>
</ul>
<pre title="expected-full.txt"><code class="language-txt">topLeft from main
topRight from main with topLeft from topRight and bottomRight from \
 topRight
bottomLeft from main with topLeft from bottomLeft and bottomRight from \
 bottomLeft
bottomRight from main
</code></pre>
<ul>
<li>We do not handle <g key="circular_dependency">circular dependencies</g>
<ul>
<li>Because <code>require</code> itself doesn't (<xref key="module-loader"></xref>)</li>
</ul>
</li>
</ul>
<h2 id="how-can-we-find-all-the-dependencies">How can we find all the dependencies?</h2>
<ul>
<li>To get dependencies for one file, parse it and extract all the <code>require</code> calls
<ul>
<li>Relatively straightforward given what we know about <a href="https://github.com/acornjs/acorn">Acorn</a></li>
</ul>
</li>
</ul>
<pre title="get-requires.js"><code class="language-js">const acorn = require('acorn')
const fs = require('fs')
const walk = require('acorn-walk')

const getRequires = (filename) =&gt; {
  const entryPointFile = filename
  const text = fs.readFileSync(entryPointFile, 'utf-8')
  const ast = acorn.parse(text)
  const requires = []
  walk.simple(ast, {
    CallExpression: (node, state) =&gt; {
      if ((node.callee.type === 'Identifier') &amp;&amp;
          (node.callee.name === 'require')) {
        state.push(node.arguments[0].value)
      }
    }
  }, null, requires)
  return requires
}

module.exports = getRequires
</code></pre>
<pre title="test-get-requires.js"><code class="language-js">const getRequires = require('./get-requires')

const result = getRequires(process.argv[2])
console.log(result)
</code></pre>
<pre title="test-get-requires.sh"><code class="language-sh">node test-get-requires.js get-requires.js
</code></pre>
<pre title="test-get-requires.txt"><code class="language-txt">[ 'acorn', 'fs', 'acorn-walk' ]
</code></pre>
<ul>
<li>To get all dependencies, need to find <g key="transitive_closure">transitive closure</g>
<ul>
<li>Requirements of requirements of requirements of...</li>
</ul>
</li>
<li>Algorithm uses two sets
<ul>
<li>Things we have seen (initially empty)</li>
<li>Things we haven't looked at yet (initially the first file)</li>
</ul>
</li>
<li>Keep taking items from <code>pending</code> until it is empty
<ul>
<li>If the current thing is already in <code>seen</code>, do nothing</li>
<li>Otherwise get its dependencies and add them to either <code>seen</code> or <code>pending</code></li>
</ul>
</li>
<li>Complicated by the fact that we can load something under different names
<ul>
<li><code>./subdir/bottom-left</code> from <code>main</code>, but <code>./bottom-left</code> from <code>./subdir/bottom-right</code></li>
<li>We will use <g key="absolute_path">absolute paths</g> as unique identifiers</li>
</ul>
</li>
<li>Also complicated by the fact that JavaScript's <code>Set</code> doesn't have an equivalent of <code>Array.pop</code>
<ul>
<li>So we will maintain the &quot;set&quot; of pending items as a list</li>
</ul>
</li>
</ul>
<pre title="transitive-closure-only.js"><code class="language-js">const path = require('path')

const getRequires = require('./get-requires')

const transitiveClosure = (entryPointPath) =&gt; {
  const pending = [path.resolve(entryPointPath)]
  const filenames = new Set()
  while (pending.length &gt; 0) {
    const candidate = path.resolve(pending.pop())
    if (filenames.has(candidate)) {
      continue
    }
    filenames.add(candidate)
    const candidateDir = path.dirname(candidate)
    getRequires(candidate)
      .map(raw =&gt; path.resolve(path.join(candidateDir, `${raw}.js`)))
      .filter(cooked =&gt; !filenames.has(cooked))
      .forEach(cooked =&gt; pending.push(cooked))
  }
  return [...filenames]
}

module.exports = transitiveClosure
</code></pre>
<pre title="test-transitive-closure-only.js"><code class="language-js">const transitiveClosure = require('./transitive-closure-only')

const result = transitiveClosure(process.argv[2])
console.log(JSON.stringify(result, null, 2))
</code></pre>
<pre title="test-transitive-closure-only.sh"><code class="language-sh">node test-transitive-closure-only.js full/main.js
</code></pre>
<pre title="test-transitive-closure-only.txt"><code class="language-txt">[
  "/u/stjs/module-bundler/full/main.js",
  "/u/stjs/module-bundler/full/subdir/bottom-right.js",
  "/u/stjs/module-bundler/full/subdir/bottom-left.js",
  "/u/stjs/module-bundler/full/top-left.js",
  "/u/stjs/module-bundler/full/top-right.js"
]
</code></pre>
<ul>
<li>This works...</li>
<li>...but we're not keeping track of the mapping from required names within files to absolute paths</li>
<li>So modify transitive closure to construct and return a two-level structure
<ul>
<li>Primary keys are the absolute paths to the files being required</li>
<li>Sub-keys are the paths they refer to when loading things</li>
<li>Values are top-level keys</li>
</ul>
</li>
</ul>
<pre title="transitive-closure.js"><code class="language-js">const path = require('path')

const getRequires = require('./get-requires')

const transitiveClosure = (entryPointPath) =&gt; {
  const mapping = {}
  const pending = [path.resolve(entryPointPath)]
  const filenames = new Set()
  while (pending.length &gt; 0) {
    const candidate = path.resolve(pending.pop())
    if (filenames.has(candidate)) {
      continue
    }
    filenames.add(candidate)
    mapping[candidate] = {}
    const candidateDir = path.dirname(candidate)
    getRequires(candidate)
      .map(raw =&gt; {
        mapping[candidate][raw] =
          path.resolve(path.join(candidateDir, `${raw}.js`))
        return mapping[candidate][raw]
      })
      .filter(cooked =&gt; cooked !== null)
      .forEach(cooked =&gt; pending.push(cooked))
  }
  return mapping
}

module.exports = transitiveClosure
</code></pre>
<pre title="test-transitive-closure.js"><code class="language-js">const transitiveClosure = require('./transitive-closure')

const result = transitiveClosure(process.argv[2])
console.log(JSON.stringify(result, null, 2))
</code></pre>
<pre title="test-transitive-closure.sh"><code class="language-sh">node test-transitive-closure.js full/main.js | ../_tools/wrap.js
</code></pre>
<pre title="test-transitive-closure.txt"><code class="language-txt">{
  "/u/stjs/module-bundler/full/main.js": {
    "./top-left": "/u/stjs/module-bundler/full/top-left.js",
    "./top-right": "/u/stjs/module-bundler/full/top-right.js",
    "./subdir/bottom-left": \
 "/u/stjs/module-bundler/full/subdir/bottom-left.js",
    "./subdir/bottom-right": \
 "/u/stjs/module-bundler/full/subdir/bottom-right.js"
  },
  "/u/stjs/module-bundler/full/subdir/bottom-right.js": {},
  "/u/stjs/module-bundler/full/subdir/bottom-left.js": {
    "../top-left": "/u/stjs/module-bundler/full/top-left.js",
    "./bottom-right": \
 "/u/stjs/module-bundler/full/subdir/bottom-right.js"
  },
  "/u/stjs/module-bundler/full/top-left.js": {},
  "/u/stjs/module-bundler/full/top-right.js": {
    "./top-left": "/u/stjs/module-bundler/full/top-left.js",
    "./subdir/bottom-right": \
 "/u/stjs/module-bundler/full/subdir/bottom-right.js"
  }
}
</code></pre>
<h2 id="how-can-we-safely-combine-several-files-into-one">How can we safely combine several files into one?</h2>
<ul>
<li>Use the same method as in <xref key="module-loader"></xref>
<ul>
<li>Wrap the source code in an <g key="iife">IIFE</g></li>
<li>Give it a <code>module</code> object to fill in</li>
<li>And an implementation of <code>require</code> to resolve dependencies <em>within the same file</em></li>
</ul>
</li>
<li>For example, suppose we have this file</li>
</ul>
<pre title="sanity-check-unwrapped.js"><code class="language-js">const main = () =&gt; {
  console.log('in main')
}

module.exports = main
</code></pre>
<ul>
<li>The wrapped version will look like this:</li>
</ul>
<pre title="sanity-check-wrapped.js"><code class="language-js">const wrapper = (module, require) =&gt; {
  const main = () =&gt; {
    console.log('in main')
  }

  module.exports = main
}
</code></pre>
<ul>
<li>And we can test it like this</li>
</ul>
<pre title="sanity-check-test.js"><code class="language-js">const wrapper = (module, require) =&gt; {
  const main = () =&gt; {
    console.log('in main')
  }

  module.exports = main
}

const need = (name) =&gt; null
const temp = {}
wrapper(temp, need)
temp.exports()
</code></pre>
<pre title="sanity-check-test.txt"><code class="language-txt">in main
</code></pre>
<ul>
<li>But we want to do this for multiple files</li>
<li>So we will create a map of these functions with absolute paths as keys</li>
<li>And wrap the loading in a function so that we don't accidentally step on anyone else's toys</li>
</ul>
<pre title="combine-files.js"><code class="language-js">const fs = require('fs')
const path = require('path')

const HEAD = `const initialize = (creators) =&gt; {
`

const TAIL = `
}
`

const combineFiles = (allFilenames) =&gt; {
  const body = allFilenames
    .map(filename =&gt; {
      const key = path.resolve(filename)
      const source = fs.readFileSync(filename, 'utf-8')
      const func = `(module, require) =&gt; {${source}}`
      const entry = `creators.set('${key}',\n${func})`
      return `// ${key}\n${entry}\n`
    })
    .join('\n')
  const func = `${HEAD}\n${body}\n${TAIL}`
  return func
}

module.exports = combineFiles
</code></pre>
<ul>
<li>Breaking it down
<ul>
<li><code>HEAD</code> creates a function of no arguments and a lookup table</li>
<li><code>TAIL</code> returns the lookup table from that function</li>
<li>In between, <code>combineFiles</code> adds an entry to the lookup table for each file</li>
</ul>
</li>
<li>Test it with our intermediate two-file case</li>
</ul>
<pre title="test-combine-files.js"><code class="language-js">const combineFiles = require('./combine-files')

console.log(combineFiles(process.argv.slice(2)))
</code></pre>
<pre title="test-combine-files-simple.js"><code class="language-js">
const initialize = (creators) =&gt; {

// /u/stjs/module-bundler/simple/main.js
creators.set('/u/stjs/module-bundler/simple/main.js',
(module, require) =&gt; {const other = require('./other')

const main = () =&gt; {
  console.log(other('main'))
}

module.exports = main
})

// /u/stjs/module-bundler/simple/other.js
creators.set('/u/stjs/module-bundler/simple/other.js',
(module, require) =&gt; {const other = (caller) =&gt; {
  return `other called from ${caller}`
}

module.exports = other
})


}

</code></pre>
<ul>
<li>We can check that this works by loading the file and calling <code>initialize</code></li>
</ul>
<pre title="show-combine-files-simple.txt"><code class="language-txt">Map(2) {
  '/u/stjs/module-bundler/simple/main.js' =&gt; [Function (anonymous)],
  '/u/stjs/module-bundler/simple/other.js' =&gt; [Function (anonymous)]
}
</code></pre>
<ul>
<li>This has not created our exports yet</li>
<li>Instead, it has created a lookup table of functions that can create what we asked for</li>
</ul>
<h2 id="how-can-files-access-each-other">How can files access each other?</h2>
<ul>
<li>We have:
<ul>
<li>A map from absolute filenames to functions that create the exports for those modules</li>
<li>A map from absolute filenames to pairs of (written import name, absolute filename)</li>
<li>An entry point</li>
</ul>
</li>
<li>So we:
<ul>
<li>Look up the function associated with the entry point</li>
<li>Run it, giving it an empty module object and a <code>require</code> function (more below)</li>
<li>Get the <code>exports</code> from the module object</li>
</ul>
</li>
<li>Our replacement for <code>require</code> is only allowed to take one argument</li>
<li>But it actually needs four things
<ul>
<li>The argument to the user's <code>require</code> call</li>
<li>The absolute path of the file making the call</li>
<li>The two lookup tables</li>
</ul>
</li>
<li>The lookup tables can't be global variables because of possible name collisions</li>
<li>So we will use <g key="closure">closures</g>
<ul>
<li>A function that takes the two tables as arguments...</li>
<li>...and returns a function that takes an absolute path identifying this module...</li>
<li>...and returns a function that takes a local path inside a module and returns the exports</li>
<li>Each layer of wrappers remembers more information</li>
</ul>
</li>
<li>We're also going to need a third structure: a cache for the modules we've already loaded</li>
<li>To prove it works, we will look up the function <code>main</code> in the first file and call it
<ul>
<li>If we were loading in the browser, we'd capture the exports in a variable for later use</li>
</ul>
</li>
</ul>
<pre title="create-bundle.js"><code class="language-js">const fs = require('fs')
const path = require('path')

const transitiveClosure = require('./transitive-closure')

const HEAD = `const creators = new Map()
const cache = new Map()

const makeRequire = (absPath) =&gt; {
  return (localPath) =&gt; {
    const actualKey = translate[absPath][localPath]
    if (!cache.has(actualKey)) {
      const m = {}
      creators.get(actualKey)(m)
      cache.set(actualKey, m.exports)
    }
    return cache.get(actualKey)
  }
}

const initialize = (creators) =&gt; {
`

const TAIL = `
}

initialize(creators)
`

const makeProof = (entryPoint) =&gt; `
const start = creators.get('${entryPoint}')
const m = {}
start(m)
m.exports()
`

const createBundle = (entryPoint) =&gt; {
  entryPoint = path.resolve(entryPoint)
  const table = transitiveClosure(entryPoint)
  const translate = `const translate = ${JSON.stringify(table, null, 2)}`
  const creators = Object.keys(table).map(filename =&gt; makeCreator(filename))
  const proof = makeProof(entryPoint)
  return [
    translate,
    HEAD,
    ...creators,
    TAIL,
    proof
  ].join('\n')
}

const makeCreator = (filename) =&gt; {
  const key = path.resolve(filename)
  const source = fs.readFileSync(filename, 'utf-8')
  const func = `(module, require = makeRequire('${key}')) =&gt;\n{${source}}`
  const entry = `creators.set('${key}',\n${func})`
  return `// ${key}\n${entry}\n`
}

module.exports = createBundle
</code></pre>
<ul>
<li>This code is really hard to read
<ul>
<li>What is being printed in the output vs. what is being executed right now</li>
<li>The levels of nesting needed to capture variables safely</li>
<li>Took much more time per line of finished code than anything except the promises in <xref key="promises"></xref></li>
</ul>
</li>
<li>Run this to create a bundled version of the single file</li>
</ul>
<pre title="test-create-bundle-single.sh"><code class="language-sh">echo '/* eslint-disable */' &gt; bundle-single.js
node test-create-bundle.js single/main.js &gt;&gt; bundle-single.js
</code></pre>
<pre title="bundle-single.js"><code class="language-js">
const translate = {
  "/u/stjs/module-bundler/single/main.js": {}
}
const creators = new Map()
const cache = new Map()

const makeRequire = (absPath) =&gt; {
  return (localPath) =&gt; {
    const actualKey = translate[absPath][localPath]
    if (!cache.has(actualKey)) {
      const m = {}
      creators.get(actualKey)(m)
      cache.set(actualKey, m.exports)
    }
    return cache.get(actualKey)
  }
}

const initialize = (creators) =&gt; {

// /u/stjs/module-bundler/single/main.js
creators.set('/u/stjs/module-bundler/single/main.js',
(module, require = makeRequire('/u/stjs/module-bundler/single/main.js')) =&gt;
{const main = () =&gt; {
  console.log('in main')
}

module.exports = main
})


}

initialize(creators)


const start = creators.get('/u/stjs/module-bundler/single/main.js')
const m = {}
start(m)
m.exports()

</code></pre>
<ul>
<li>And when we run it</li>
</ul>
<pre title="test-bundle-single.txt"><code class="language-txt">in main
</code></pre>
<ul>
<li>That was a lot of work to print one line
<ul>
<li>But it should work for other files</li>
</ul>
</li>
<li>Make and run a bundle for the simple case (<code>main</code> and <code>other</code>)</li>
</ul>
<pre title="bundle-simple.js"><code class="language-js">
const translate = {
  "/u/stjs/module-bundler/simple/main.js": {
    "./other": "/u/stjs/module-bundler/simple/other.js"
  },
  "/u/stjs/module-bundler/simple/other.js": {}
}
const creators = new Map()
const cache = new Map()

const makeRequire = (absPath) =&gt; {
  return (localPath) =&gt; {
    const actualKey = translate[absPath][localPath]
    if (!cache.has(actualKey)) {
      const m = {}
      creators.get(actualKey)(m)
      cache.set(actualKey, m.exports)
    }
    return cache.get(actualKey)
  }
}

const initialize = (creators) =&gt; {

// /u/stjs/module-bundler/simple/main.js
creators.set('/u/stjs/module-bundler/simple/main.js',
(module, require = makeRequire('/u/stjs/module-bundler/simple/main.js')) =&gt;
{const other = require('./other')

const main = () =&gt; {
  console.log(other('main'))
}

module.exports = main
})

// /u/stjs/module-bundler/simple/other.js
creators.set('/u/stjs/module-bundler/simple/other.js',
(module, require = makeRequire('/u/stjs/module-bundler/simple/other.js')) =&gt;
{const other = (caller) =&gt; {
  return `other called from ${caller}`
}

module.exports = other
})


}

initialize(creators)


const start = creators.get('/u/stjs/module-bundler/simple/main.js')
const m = {}
start(m)
m.exports()

</code></pre>
<pre title="test-bundle-simple.txt"><code class="language-txt">other called from main
</code></pre>
<ul>
<li>And for the full case (<code>main</code> plus four other files)</li>
</ul>
<pre title="test-bundle-full.txt"><code class="language-txt">topLeft from main
topRight from main with topLeft from topRight and bottomRight from \
 topRight
bottomLeft from main with topLeft from bottomLeft and bottomRight from \
 bottomLeft
bottomRight from main
</code></pre>
</main>
<footer>
<div class="row">
<div class="left3">
<a href="../module-loader/"><em>&laquo; Module Loader</em></a>
</div>
<div class="middle3">
<a href="../license/"><img class="footer" src="../static/cc-by.svg" alt="License" /></a>
<a href="https://github.com/software-tools-in-javascript/stjs/"><img class="footer" src="../static/github.svg" alt="Repository" /></a>
© 2020 <a href="../authors/">The Authors</a>
</div>
<div class="right3">
<a href="../package-manager/"><em>Package Manager &raquo;</em></a>
</div>
</div>
</footer>
</body>
</html>
