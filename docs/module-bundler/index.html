<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
  <title>Module Bundler</title>
  <meta name="toRoot" content="..">
  <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
  <link href="../static/site.css" rel="stylesheet" type="text/css">
  <script src="../static/site.js"></script>
  <script>window.onload = () => fixPage()</script>
</head>
<body id="_top">
<nav>
<div class="row">
<div class="left2">
<a href="http://third-bit.com"><img src="../static/logo.svg" alt="site logo" class="site-logo"/></a>
<a href="../"><em>Software Tools in JavaScript</em></a>
</div>
<div class="right2">
<div class="dropdown">
<span class="navtitle">▿ Sections</span>
<div class="dropdown-content" id="Sections">
</div>
</div>
<div class="dropdown">
<span class="navtitle">▿ Chapters</span>
<div class="dropdown-content" id="Chapters">
<a href="../systems-programming/"><span class="nowrap">Systems Programming</span></a>
<br/><a href="../promises/"><span class="nowrap">Promises</span></a>
<br/><a href="../unit-test/"><span class="nowrap">Unit Testing</span></a>
<br/><a href="../file-backup/"><span class="nowrap">File Backup</span></a>
<br/><a href="../style-checker/"><span class="nowrap">Style Checker</span></a>
<br/><a href="../code-generator/"><span class="nowrap">Code Generator</span></a>
<br/><a href="../page-templates/"><span class="nowrap">Page Templates</span></a>
<br/><a href="../doc-generator/"><span class="nowrap">Documentation Generator</span></a>
<br/><a href="../module-loader/"><span class="nowrap">Module Loader</span></a>
<br/><a href="../module-bundler/"><span class="nowrap">Module Bundler</span></a>
<br/><a href="../layout-engine/"><span class="nowrap">Layout Engine</span></a>
<br/><a href="../text-editor/"><span class="nowrap">Text Editor</span></a>
<br/><a href="../http-server/"><span class="nowrap">HTTP Server</span></a>
<br/><a href="../build-manager/"><span class="nowrap">Build Manager</span></a>
<br/><a href="../package-manager/"><span class="nowrap">Package Manager</span></a>
<br/><a href="../conclusion/"><span class="nowrap">Conclusion</span></a>
</div>
</div>
<div class="dropdown">
<span class="navtitle">▿ Appendices</span>
<div class="dropdown-content" id="Appendices">
<a href="../license/"><span class="nowrap">License</span></a>
<br/><a href="../conduct/"><span class="nowrap">Code of Conduct</span></a>
<br/><a href="../contributing/"><span class="nowrap">Contributing</span></a>
<br/><a href="../bib/"><span class="nowrap">Bibliography</span></a>
<br/><a href="../gloss/"><span class="nowrap">Glossary</span></a>
<br/><a href="../links/"><span class="nowrap">Links</span></a>
<br/><a href="../solutions/"><span class="nowrap">Solutions</span></a>
<br/><a href="../authors/"><span class="nowrap">Authors</span></a>
</div>
</div>
</div>
</div>
</nav>
  <main>
  <h1>Module Bundler</h1>
  <p class="lede">Turning many files into one</p>
<ul>
<li>JavaScript was designed in a hurry 25 years ago to make pages interactive
<ul>
<li>Nobody realized it would become one of the most popular programming languages in the world</li>
<li>Which means it didn't include support for things that large programs need</li>
<li>Like creating multi-module bundles so that browsers could load a single file
rather than making dozens or hundreds of requests</li>
</ul>
</li>
<li>A <g key="module_bundler">module bundler</g> finds all the files that a set of source files depend on
and combines them into a single loadable file
<ul>
<li>Much more efficient to load</li>
<li>Ensures that dependencies actually resolve</li>
</ul>
</li>
<li>Need to:
<ul>
<li>Find all dependencies</li>
<li>Combine them into one file</li>
<li>Ensure they can find each other correctly once loaded</li>
</ul>
</li>
<li>Our approach is based on <a href="https://www.freecodecamp.org/news/lets-learn-how-module-bundlers-work-and-then-write-one-ourselves-b2e3fe6c88ae/">Adam Kelly's tutorial</a></li>
</ul>
<h2 id="what-should-our-test-case-include">What should our test case include?</h2>
<ul>
<li>Use <g key="tdd">test-driven development</g> (TDD)
<ul>
<li>Create the test cases <em>before</em> writing the code to define what the code is supposed to do</li>
<li>Studies don't support the claim that it makes programmers more productive,
but it doesn't seem to do any harm either</li>
</ul>
</li>
<li>Four cases
<ul>
<li>File A requires File B</li>
<li>Files A and B both require File C, and only one copy of File C is included in the bundle</li>
<li>Files A and B require File C using different paths</li>
<li>Files A and B require each other (a <g key="circular_dependency">circular dependency</g>)</li>
</ul>
</li>
<li>Create a file <code>main.js</code> as an <g key="entry_point">entry point</g>
<ul>
<li>Name the other files geometrically to help keep them straight</li>
</ul>
</li>
</ul>
<pre title="example/main.js"><code class="language-js">// main.js

const topLeft = require('./top-left')
const topRight = require('./top-right') // requires 'top-left'
const bottomLeft = require('./subdir/bottom-left') // requires 'top-left' and 'bottom-right'
const bottomRight = require('./subdir/bottom-right') // requires 'bottom-left'

const main = () =&gt; {
  const functions = [topLeft, topRight, bottomLeft, bottomRight]
  functions.forEach(func =&gt; {
    console.log(`${func('main')}`)
  })
}

main()
</code></pre>
<pre title="example/top-left.js"><code class="language-js">// top-left.js

const topLeft = (caller) =&gt; {
  return `topLeft from ${caller}`
}

module.exports = topLeft
</code></pre>
<pre title="example/top-right.js"><code class="language-js">// top-right.js

const topLeft = require('./top-left')

const topRight = (caller) =&gt; {
  const first = topLeft('topRight')
  return `topRight from ${caller} with ${first}`
}

module.exports = topRight
</code></pre>
<pre title="example/subdir/bottom-left.js"><code class="language-js">// subdir/bottom-left.js

const topLeft = require('../top-left')
const bottomRight = require('./bottom-right')

const bottomLeft = (caller) =&gt; {
  const first = topLeft('bottomLeft')
  const second = bottomRight('bottomLeft')
  return `bottomLeft from ${caller} with ${first} and ${second}`
}

module.exports = bottomLeft
</code></pre>
<pre title="example/subdir/bottom-right.js"><code class="language-js">// subdir/bottom-right.js

const bottomLeft = require('./bottom-left')

const bottomRight = (caller) =&gt; {
  return `bottomRight from ${caller}`
}

module.exports = bottomRight
</code></pre>
<p>FIXME: diagram</p>
<ul>
<li>Run <code>main.js</code> directly</li>
<li>When we're done, we should have a single <code>.js</code> file that produces exactly the same output</li>
</ul>
<pre title="example-directly.sh"><code class="language-sh">node example/main.js
</code></pre>
<pre title="example-directly.text"><code class="language-text">topLeft from main
topRight from main with topLeft from topRight
bottomLeft from main with topLeft from bottomLeft and bottomRight from bottomLeft
bottomRight from main
</code></pre>
<h2 id="how-can-we-find-all-the-dependencies">How can we find all the dependencies?</h2>
<ul>
<li>To get dependencies for one file, parse it and extract all the <code>require</code> calls
<ul>
<li>Relatively straightforward given what we know about <a href="https://github.com/acornjs/acorn">Acorn</a></li>
<li>Though notice how we build the module so that it can be run from the command line <em>or</em> loaded</li>
</ul>
</li>
</ul>
<pre title="extract-require.js"><code class="language-js">const acorn = require('acorn')
const fs = require('fs')
const walk = require('acorn-walk')

const getRequires = (filename) =&gt; {
  const entryPointFile = filename
  const text = fs.readFileSync(entryPointFile)
  const ast = acorn.parse(text)
  const requires = []
  walk.simple(ast, {
    CallExpression: (node, state) =&gt; {
      if ((node.callee.type === 'Identifier') &amp;&amp;
          (node.callee.name === 'require')) {
        state.push(node.arguments[0].value)
      }
    }
  }, null, requires)
  return requires
}

if (require.main === module) {
  const result = getRequires(process.argv[2])
  console.log(result)
}
else {
  module.exports = getRequires
}
</code></pre>
<pre title="extract-require.sh"><code class="language-sh">node extract-require.js example/main.js
</code></pre>
<pre title="extract-require.text"><code class="language-text">[
  './top-left',
  './top-right',
  './subdir/bottom-left',
  './subdir/bottom-right'
]
</code></pre>
<ul>
<li>To get all dependencies, need to find <g key="transitive_closure">transitive closure</g>
<ul>
<li>Requirements of requirements of requirements of...</li>
<li>But allow for the case of X and Y requiring each other</li>
</ul>
</li>
<li>Algorithm uses two sets
<ul>
<li>Things we have seen (initially empty)</li>
<li>Things we haven't looked at yet (initially the first file)</li>
</ul>
</li>
<li>Keep taking items from <code>pending</code> until it is empty
<ul>
<li>If the current thing is already in <code>seen</code>, do nothing</li>
<li>Otherwise get its dependencies and add them to either <code>seen</code> or <code>pending</code></li>
</ul>
</li>
<li>Complicated by the fact that we can load something under different names
<ul>
<li><code>./subdir/bottom-left</code> from <code>main</code>, but <code>./bottom-left</code> from <code>./subdir/bottom-right</code></li>
<li>We will use <g key="absolute_path">absolute paths</a> as unique identifiers</li>
</ul>
</li>
<li>Also complicated by the fact that JavaScript's <code>Set</code> doesn't have an equivalent of <code>Array.pop</code>
<ul>
<li>So we will maintain the &quot;set&quot; of pending items as a list</li>
</ul>
</li>
</ul>
<pre title="transitive-closure-only.js"><code class="language-js">const path = require('path')

const getRequires = require('./extract-require')

const transitiveClosure = (entryPointPath) =&gt; {
  const pending = [path.resolve(entryPointPath)]
  const seen = new Set()
  while (pending.length &gt; 0) {
    const candidate = path.resolve(pending.pop())
    if (seen.has(candidate)) {
      continue
    }
    seen.add(candidate)
    const candidateDir = path.dirname(candidate)
    getRequires(candidate)
      .map(raw =&gt; path.resolve(path.join(candidateDir, `${raw}.js`)))
      .filter(cooked =&gt; !seen.has(cooked))
      .forEach(cooked =&gt; pending.push(cooked))
  }
  return [...seen]
}

if (module.loaded) {
  module.exports = transitiveClosure
}
else {
  const result = transitiveClosure(process.argv[2])
  console.log(JSON.stringify(result, null, 2))
}
</code></pre>
<pre title="transitive-closure-only.sh"><code class="language-sh">node transitive-closure-only.js example/main.js
</code></pre>
<pre title="transitive-closure-only.text"><code class="language-text">[
  "/Users/gvwilson/stjs/module-bundler/example/main.js",
  "/Users/gvwilson/stjs/module-bundler/example/subdir/bottom-right.js",
  "/Users/gvwilson/stjs/module-bundler/example/subdir/bottom-left.js",
  "/Users/gvwilson/stjs/module-bundler/example/top-left.js",
  "/Users/gvwilson/stjs/module-bundler/example/top-right.js"
]
</code></pre>
<ul>
<li>This works...</li>
<li>...but we're not keeping track of the mapping from required names within files to absolute paths</li>
<li>So modify transitive closure to construct and return a second structure
<ul>
<li>Primary keys are the absolute paths to the files being required</li>
<li>Sub-keys are the paths actually used for loading</li>
<li>Values are primary keys</li>
</ul>
</li>
</ul>
<pre title="transitive-closure.js"><code class="language-js">const path = require('path')

const getRequires = require('./extract-require')

const transitiveClosure = (entryPointPath) =&gt; {
  const mapping = {}
  const pending = [path.resolve(entryPointPath)]
  const seen = new Set()
  while (pending.length &gt; 0) {
    const candidate = path.resolve(pending.pop())
    if (seen.has(candidate)) {
      continue
    }
    seen.add(candidate)
    mapping[candidate] = {}
    const candidateDir = path.dirname(candidate)
    getRequires(candidate)
      .map(raw =&gt; {
        mapping[candidate][raw] = 
          path.resolve(path.join(candidateDir, `${raw}.js`))
        return mapping[candidate][raw]
      })
      .filter(cooked =&gt; cooked !== null)
      .forEach(cooked =&gt; pending.push(cooked))
  }
  return {filenames: [...seen], mapping}
}

if (require.main === module) {
  const result = transitiveClosure(process.argv[2])
  console.log(JSON.stringify(result, null, 2))
}
else {
  module.exports = transitiveClosure
}
</code></pre>
<pre title="transitive-closure.sh"><code class="language-sh">node transitive-closure.js example/main.js
</code></pre>
<pre title="transitive-closure.text"><code class="language-text">{
  "seen": [
    "/Users/gvwilson/stjs/module-bundler/example/main.js",
    "/Users/gvwilson/stjs/module-bundler/example/subdir/bottom-right.js",
    "/Users/gvwilson/stjs/module-bundler/example/subdir/bottom-left.js",
    "/Users/gvwilson/stjs/module-bundler/example/top-left.js",
    "/Users/gvwilson/stjs/module-bundler/example/top-right.js"
  ],
  "mapping": {
    "/Users/gvwilson/stjs/module-bundler/example/main.js": {
      "./top-left": "/Users/gvwilson/stjs/module-bundler/example/top-left.js",
      "./top-right": "/Users/gvwilson/stjs/module-bundler/example/top-right.js",
      "./subdir/bottom-left": "/Users/gvwilson/stjs/module-bundler/example/subdir/bottom-left.js",
      "./subdir/bottom-right": "/Users/gvwilson/stjs/module-bundler/example/subdir/bottom-right.js"
    },
    "/Users/gvwilson/stjs/module-bundler/example/subdir/bottom-right.js": {
      "./bottom-left": "/Users/gvwilson/stjs/module-bundler/example/subdir/bottom-left.js"
    },
    "/Users/gvwilson/stjs/module-bundler/example/subdir/bottom-left.js": {
      "../top-left": "/Users/gvwilson/stjs/module-bundler/example/top-left.js",
      "./bottom-right": "/Users/gvwilson/stjs/module-bundler/example/subdir/bottom-right.js"
    },
    "/Users/gvwilson/stjs/module-bundler/example/top-left.js": {},
    "/Users/gvwilson/stjs/module-bundler/example/top-right.js": {
      "./top-left": "/Users/gvwilson/stjs/module-bundler/example/top-left.js"
    }
  }
}
</code></pre>
<h2 id="how-can-we-combine-multiple-files-into-one-file">How can we combine multiple files into one file?</h2>
<ul>
<li>We could concatenate all of the files into one...
<ul>
<li>...but we would have name collisions...</li>
<li>...and <code>requires</code> and <code>module.exports</code> wouldn't work</li>
</ul>
</li>
<li>So read the source file...
<ul>
<li>...and eval it with our own <code>requires</code> and <code>module.exports</code> in place</li>
</ul>
</li>
<li>Our <code>requires</code> will use the absolute path of the file calling it and the path given to <code>require</code>
and look up the absolute path of the file to load</li>
<li>We will create a <code>modules</code> object so that code can assign to <code>module.exports</code>,
then take whatever is assigned to it and save it for future <code>require</code> calls</li>
<li>It's a lot of bookkeeping, but unavoidable</li>
</ul>
<p>FIXME: diagram</p>
<ul>
<li>First step is to load all the code and signal that we don't have its exports yet</li>
</ul>
<pre title="load-code.js"><code class="language-js">const fs = require('fs')

const loadCode = (allFilenames) =&gt; {
  return allFilenames.reduce((soFar, filename) =&gt; {
    soFar[filename] = fs.readFileSync(filename, 'utf-8')
    return soFar
  }, {})
}

module.exports = loadCode
</code></pre>
<ul>
<li>Next is to get things to work without worrying about circular dependencies</li>
</ul>
</main>
<footer>
<div class="row">
<div class="left3">
<a href="../module-loader/"><em>&laquo; Module Loader</em></a>
</div>
<div class="middle3">
<a href="../license/"><img class="footer" src="../static/cc-by.svg" alt="License" /></a>
<a href="https://github.com/gvwilson/e/"><img class="footer" src="../static/github.svg" alt="Repository" /></a>
© 2020 <a href="../authors/">The Authors</a>
</div>
<div class="right3">
<a href="../layout-engine/"><em>Layout Engine &raquo;</em></a>
</div>
</div>
</footer>
</body>
</html>
