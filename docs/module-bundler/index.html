<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
  <title>Module Bundler</title>
  <meta name="toRoot" content="..">
  <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
  <link href="../static/site.css" rel="stylesheet" type="text/css">
  <script src="../static/site.js"></script>
  <script>window.onload = () => fixPage()</script>
</head>
<body id="_top">
<nav>
<div class="row">
<div class="left2">
<a href="http://third-bit.com"><img src="../static/logo.svg" alt="site logo" class="site-logo"/></a>
<a href="../"><em>Software Tools in JavaScript</em></a>
</div>
<div class="right2">
<div class="dropdown">
<span class="navtitle">▿ Sections</span>
<div class="dropdown-content" id="Sections">
</div>
</div>
<div class="dropdown">
<span class="navtitle">▿ Chapters</span>
<div class="dropdown-content" id="Chapters">
<a href="../systems-programming/"><span class="nowrap">Systems Programming</span></a>
<br/><a href="../promises/"><span class="nowrap">Promises</span></a>
<br/><a href="../unit-test/"><span class="nowrap">Unit Testing</span></a>
<br/><a href="../file-backup/"><span class="nowrap">File Backup</span></a>
<br/><a href="../style-checker/"><span class="nowrap">Style Checker</span></a>
<br/><a href="../pattern-matching/"><span class="nowrap">Pattern Matching</span></a>
<br/><a href="../regex-parser/"><span class="nowrap">Parsing Expressions</span></a>
<br/><a href="../code-generator/"><span class="nowrap">Code Generator</span></a>
<br/><a href="../page-templates/"><span class="nowrap">Page Templates</span></a>
<br/><a href="../doc-generator/"><span class="nowrap">Documentation Generator</span></a>
<br/><a href="../module-loader/"><span class="nowrap">Module Loader</span></a>
<br/><a href="../module-bundler/"><span class="nowrap">Module Bundler</span></a>
<br/><a href="../layout-engine/"><span class="nowrap">Layout Engine</span></a>
<br/><a href="../text-editor/"><span class="nowrap">Text Editor</span></a>
<br/><a href="../http-server/"><span class="nowrap">HTTP Server</span></a>
<br/><a href="../build-manager/"><span class="nowrap">Build Manager</span></a>
<br/><a href="../package-manager/"><span class="nowrap">Package Manager</span></a>
<br/><a href="../issue-tracker/"><span class="nowrap">Issue Tracker</span></a>
<br/><a href="../conclusion/"><span class="nowrap">Conclusion</span></a>
</div>
</div>
<div class="dropdown">
<span class="navtitle">▿ Appendices</span>
<div class="dropdown-content" id="Appendices">
<a href="../license/"><span class="nowrap">License</span></a>
<br/><a href="../conduct/"><span class="nowrap">Code of Conduct</span></a>
<br/><a href="../contributing/"><span class="nowrap">Contributing</span></a>
<br/><a href="../bib/"><span class="nowrap">Bibliography</span></a>
<br/><a href="../gloss/"><span class="nowrap">Glossary</span></a>
<br/><a href="../links/"><span class="nowrap">Links</span></a>
<br/><a href="../solutions/"><span class="nowrap">Solutions</span></a>
<br/><a href="../authors/"><span class="nowrap">Authors</span></a>
</div>
</div>
</div>
</div>
</nav>
  <main>
  <h1>Module Bundler</h1>
  <p class="lede">Turning many files into one</p>
<ul>
<li>JavaScript was designed in a hurry 25 years ago to make pages interactive
<ul>
<li>Nobody realized it would become one of the most popular programming languages in the world</li>
<li>Which means it didn't include support for things that large programs need</li>
<li>Like creating multi-module bundles so that browsers could load a single file
rather than making dozens or hundreds of requests</li>
</ul>
</li>
<li>A <g key="module_bundler">module bundler</g> finds all the files that a set of source files depend on
and combines them into a single loadable file
<ul>
<li>Much more efficient to load</li>
<li>Ensures that dependencies actually resolve</li>
</ul>
</li>
<li>Need to:
<ul>
<li>Find all dependencies</li>
<li>Combine them into one file</li>
<li>Ensure they can find each other correctly once loaded</li>
</ul>
</li>
<li>Our approach is based on <a href="https://www.freecodecamp.org/news/lets-learn-how-module-bundlers-work-and-then-write-one-ourselves-b2e3fe6c88ae/">Adam Kelly's tutorial</a></li>
</ul>
<h2 id="do-we-need-to-handle-circular-dependencies">Do we need to handle circular dependencies?</h2>
<ul>
<li>We can visualize the network of who requires whom as a <g key="directed_graph">directed graph</g>
<ul>
<li>If X requires Y, draw an arrow from X to Y</li>
</ul>
</li>
<li>A <g key="circular_dependency">circular dependency</g> exists if X depends on Y and Y depends on X
<ul>
<li>Either directly or indirectly</li>
</ul>
</li>
<li>May seem nonsensical, but can easily arise with <g key="plugin_architecture">plugin architectures</g>
<ul>
<li>Main program loads an extension</li>
<li>The extension calls utility functions defined alongside the main program</li>
</ul>
</li>
<li>Most <g key="compiled_language">compiled languages</g> can handle this
<ul>
<li>Compile each module into low-level instructions</li>
<li><g key="link">Link</g> those to resolve dependencies</li>
<li>Then run</li>
</ul>
</li>
<li>But <g key="interpreted_language">interpreted languages</g> execute code as it loads
<ul>
<li>So if X is in the process of loading Y and Y tries to call X,
X may not (fully) exist yet</li>
</ul>
</li>
<li>It sort-of works in Python</li>
<li>Create two files</li>
</ul>
<pre title="checking/major.py"><code class="language-py"># major.py

import minor

def top():
    print("top")
    minor.middle()

def bottom():
    print("bottom")

top()
</code></pre>
<pre title="checking/minor.py"><code class="language-py"># minor.py

import major

def middle():
    print("middle")
    major.bottom()
</code></pre>
<ul>
<li>Fails when run from the command line</li>
</ul>
<pre title="checking/py-command-line.sh"><code class="language-sh">python major.py
</code></pre>
<pre title="checking/py-command-line.txt"><code class="language-txt">top
Traceback (most recent call last):
  File "major.py", line 3, in &lt;module&gt;
    import minor
  File "/Users/gvwilson/stjs/module-bundler/checking/minor.py", line 3, in &lt;module&gt;
    import major
  File "/Users/gvwilson/stjs/module-bundler/checking/major.py", line 12, in &lt;module&gt;
    top()
  File "/Users/gvwilson/stjs/module-bundler/checking/major.py", line 7, in top
    minor.middle()
AttributeError: module 'minor' has no attribute 'middle'
</code></pre>
<ul>
<li>But works in the interactive interpreter</li>
</ul>
<pre title="checking/py-interactive.txt"><code class="language-txt">&gt;&gt;&gt; import major
top
middle
bottom
</code></pre>
<ul>
<li>Equivalent in JavaScript</li>
</ul>
<pre title="checking/major.js"><code class="language-js">const { middle } = require('./minor')

const top = () =&gt; {
  console.log('top')
  middle()
}

const bottom = () =&gt; {
  console.log('bottom')
}

top()

module.exports = { top, bottom }
</code></pre>
<pre title="checking/minor.js"><code class="language-js">const { bottom } = require('./major')

const middle = () =&gt; {
  console.log('middle')
  bottom()
}

module.exports = { middle }
</code></pre>
<ul>
<li>Fails on the command line</li>
</ul>
<pre title="checking/js-command-line.sh"><code class="language-sh">node major.js
</code></pre>
<pre title="checking/js-command-line.txt"><code class="language-txt">top
middle
/Users/gvwilson/stjs/module-bundler/checking/minor.js:5
  bottom()
  ^

TypeError: bottom is not a function
    at middle (/Users/gvwilson/stjs/module-bundler/checking/minor.js:5:3)
    at top (/Users/gvwilson/stjs/module-bundler/checking/major.js:5:3)
    at Object.&lt;anonymous&gt; (/Users/gvwilson/stjs/module-bundler/checking/major.js:12:1)
    at Module._compile (internal/modules/cjs/loader.js:1151:30)
    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1171:10)
    at Module.load (internal/modules/cjs/loader.js:1000:32)
    at Function.Module._load (internal/modules/cjs/loader.js:899:14)
    at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:71:12)
    at internal/main/run_main_module.js:17:47
</code></pre>
<ul>
<li>Also fails in the interactive interpreter</li>
</ul>
<pre title="checking/js-interactive.txt"><code class="language-txt">&gt; const major = require('./major')
top
middle
Uncaught TypeError: bottom is not a function
    at middle (/Users/gvwilson/stjs/module-bundler/checking/minor.js:5:3)
    at top (/Users/gvwilson/stjs/module-bundler/checking/major.js:5:3)
    at Object.&lt;anonymous&gt; (/Users/gvwilson/stjs/module-bundler/checking/major.js:12:1)
    at Module._compile (internal/modules/cjs/loader.js:1151:30)
    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1171:10)
    at Module.load (internal/modules/cjs/loader.js:1000:32)
    at Function.Module._load (internal/modules/cjs/loader.js:899:14)
    at Module.require (internal/modules/cjs/loader.js:1040:19)
    at require (internal/modules/cjs/helpers.js:72:18)
</code></pre>
<ul>
<li>So we will <em>not</em> handle circular dependencies
<ul>
<li>But we <em>will</em> detect them and generate a sensible error message</li>
</ul>
</li>
</ul>
<h2 id="how-can-we-safely-get-the-contents-of-a-module">How can we safely get the contents of a module?</h2>
<ul>
<li>Start with a simple file that exports a single function</li>
</ul>
<pre title="simple/other.js"><code class="language-js">const other = () =&gt; {
  return 'message from other'
}

module.exports = other
</code></pre>
<ul>
<li>We can read it and eval the content:</li>
</ul>
<pre title="capture-exports-pollute.js"><code class="language-js">
const fs = require('fs')

const main = () =&gt; {
  const source = fs.readFileSync(process.argv[2], 'utf-8')
  console.log('before', module)
  eval(source)
  console.log('after', module)
}

main()
</code></pre>
<pre title="capture-exports-pollute.sh"><code class="language-sh">node capture-exports-pollute.js simple/other.js
</code></pre>
<pre title="capture-exports-pollute.txt"><code class="language-txt">before Module {
  id: '.',
  path: '/Users/gvwilson/stjs/module-bundler',
  exports: {},
  parent: null,
  filename: '/Users/gvwilson/stjs/module-bundler/capture-exports-pollute.js',
  loaded: false,
  children: [],
  paths: [
    '/Users/gvwilson/stjs/module-bundler/node_modules',
    '/Users/gvwilson/stjs/node_modules',
    '/Users/gvwilson/node_modules',
    '/Users/node_modules',
    '/node_modules'
  ]
}
after Module {
  id: '.',
  path: '/Users/gvwilson/stjs/module-bundler',
  exports: [Function: other],
  parent: null,
  filename: '/Users/gvwilson/stjs/module-bundler/capture-exports-pollute.js',
  loaded: false,
  children: [],
  paths: [
    '/Users/gvwilson/stjs/module-bundler/node_modules',
    '/Users/gvwilson/stjs/node_modules',
    '/Users/gvwilson/node_modules',
    '/Users/node_modules',
    '/node_modules'
  ]
}
</code></pre>
<ul>
<li>But this adds the <code>other</code> function to <code>module.exports</code> of the caller
<ul>
<li>Because the <code>module</code> variable in scope when <code>eval</code> is called is the caller's <code>module</code></li>
</ul>
</li>
<li>We need to create a new scope for the <code>eval</code> with something called <code>module</code> that <em>isn't</em> the caller's <code>module</code>
<ul>
<li>Show a bit less output to avoid cluttering the page</li>
</ul>
</li>
</ul>
<pre title="capture-exports-encapsulate.js"><code class="language-js">
const fs = require('fs')

const safeLoad = (module, filename) =&gt; {
  const source = fs.readFileSync(process.argv[2], 'utf-8')
  eval(source)
}

const main = () =&gt; {
  console.log('caller before', module.id, module.exports)
  const childModule = {}
  safeLoad(childModule, process.argv[2])
  console.log('caller after', module.id, module.exports)
  console.log('childModule after', childModule)
}

main()
</code></pre>
<pre title="capture-exports-encapsulate.sh"><code class="language-sh">node capture-exports-encapsulate.js simple/other.js
</code></pre>
<pre title="capture-exports-encapsulate.txt"><code class="language-txt">caller before . {}
caller after . {}
childModule after { exports: [Function: other] }
</code></pre>
<h2 id="what-should-our-test-case-include">What should our test case include?</h2>
<ul>
<li>Use <g key="tdd">test-driven development</g> (TDD)
<ul>
<li>Create the test cases <em>before</em> writing the code to define what the code is supposed to do</li>
<li>Studies don't support the claim that it makes programmers more productive,
but it doesn't seem to do any harm either</li>
</ul>
</li>
<li>Simple case: <code>main.js</code> requires <code>other.js</code> from same directory</li>
</ul>
<pre title="simple/main.js"><code class="language-js">const other = require('./other')

const main = () =&gt; {
  console.log(`main called other ${other()}`)
}

main()
</code></pre>
<pre title="simple/other.js"><code class="language-js">const other = () =&gt; {
  return 'message from other'
}

module.exports = other
</code></pre>
<ul>
<li>Expected behavior</li>
</ul>
<pre title="simple/expected.sh"><code class="language-sh">cd $(dirname $0) &amp;&amp; node main.js
</code></pre>
<pre title="simple/expected.txt"><code class="language-txt">main called other message from other
</code></pre>
<ul>
<li>More complicated case
<ul>
<li>Name the files geometrically to help keep them straight</li>
</ul>
</li>
<li><code>main.js</code> is the <g key="entry_point">entry point</g>
<ul>
<li><code>./top-left.js</code> doesn't require anything else</li>
<li><code>./top-right.js</code> requires <code>./top-left.js</code> and <code>./subdir/bottom-right.js</code></li>
<li><code>./bottom-left.js</code> requires <code>../top-left.js</code> and <code>./bottom-right.js</code></li>
<li><code>./bottom-right.js</code> doesn't require anything else</li>
</ul>
</li>
</ul>
<pre title="full/main.js"><code class="language-js">// main.js

const topLeft = require('./top-left')                // none
const topRight = require('./top-right')              // needs top-left + bottom-right
const bottomLeft = require('./subdir/bottom-left')   // needs top-left + bottom-right
const bottomRight = require('./subdir/bottom-right') // none

const main = () =&gt; {
  const functions = [topLeft, topRight, bottomLeft, bottomRight]
  functions.forEach(func =&gt; {
    console.log(`${func('main')}`)
  })
}

main()
</code></pre>
<pre title="full/top-left.js"><code class="language-js">// top-left.js

const topLeft = (caller) =&gt; {
  return `topLeft from ${caller}`
}

module.exports = topLeft
</code></pre>
<pre title="full/top-right.js"><code class="language-js">// top-right.js

const topLeft = require('./top-left')
const bottomRight = require('./subdir/bottom-right')

const topRight = (caller) =&gt; {
  const first = topLeft('topRight')
  const second = bottomRight('topRight')
  return `topRight from ${caller} with ${first} and ${second}`
}

module.exports = topRight
</code></pre>
<pre title="full/subdir/bottom-left.js"><code class="language-js">// subdir/bottom-left.js

const topLeft = require('../top-left')
const bottomRight = require('./bottom-right')

const bottomLeft = (caller) =&gt; {
  const first = topLeft('bottomLeft')
  const second = bottomRight('bottomLeft')
  return `bottomLeft from ${caller} with ${first} and ${second}`
}

module.exports = bottomLeft
</code></pre>
<pre title="full/subdir/bottom-right.js"><code class="language-js">// subdir/bottom-right.js

const bottomRight = (caller) =&gt; {
  return `bottomRight from ${caller}`
}

module.exports = bottomRight
</code></pre>
<ul>
<li>Run <code>main.js</code> directly</li>
<li>When we're done, we should have a single <code>.js</code> file that produces exactly the same output</li>
</ul>
<pre title="full/expected.sh"><code class="language-sh">cd $(dirname $0) &amp;&amp; node main.js
</code></pre>
<pre title="full/expected.txt"><code class="language-txt">topLeft from main
topRight from main with topLeft from topRight and bottomRight from topRight
bottomLeft from main with topLeft from bottomLeft and bottomRight from bottomLeft
bottomRight from main
</code></pre>
<h2 id="how-can-we-load-a-single-file">How can we load a single file?</h2>
<p>FIXME</p>
<h2 id="how-can-we-combine-multiple-files">How can we combine multiple files?</h2>
<ul>
<li>Concatenate the source of the files
<ul>
<li>But wrap each in a function that takes a parameter called <code>module</code></li>
<li>And then save the value of <code>module.exports</code> (if any)</li>
</ul>
</li>
<li>Result is going to look like this:</li>
</ul>
<pre title="concatenate-by-hand.js"><code class="language-js">const everything = {
  'simple/other.js': ((module) =&gt; {
    const other = () =&gt; {
      return 'message from other'
    }

    module.exports = other
    return module
  })({})
}

console.log('everything', everything)
</code></pre>
<pre title="concatenate-by-hand.txt"><code class="language-txt">everything { 'simple/other.js': { exports: [Function: other] } }
</code></pre>
<ul>
<li>Create a lookup table with one entry for each module</li>
<li>Use the filename as a key
<ul>
<li>We will revisit this later</li>
</ul>
</li>
<li>Create the function we need with a <code>module</code> parameter</li>
<li>Call it immediately to get the module's exports
<ul>
<li>An <g key="iifd">immediately-invoked function declaration</g> (IFFD)</li>
<li>Parentheses around function definition are required by JavaScript parser</li>
<li>Pass in an empty object to be filled in and returned</li>
</ul>
</li>
<li>We can create this by concatenating strings
<ul>
<li>It would be nice if JavaScript template literals could be defined in one place
and filled in somewhere else</li>
<li>Since they can't, we'll use string replacement</li>
</ul>
</li>
<li>Note that we create <code>everything</code> rather than <code>const everything</code>
<ul>
<li>FIXME: why doesn't the latter work?</li>
</ul>
</li>
<li>Testing this is a multi-step process
<ul>
<li>Run <code>concatenate-programmatically.js</code> with <code>simple/other.js</code> as an argument
to create a file we can execute that contains a module definition</li>
</ul>
</li>
</ul>
<pre title="concatenate-programmatically.js"><code class="language-js">const fs = require('fs')

const TOP = 'everything = {'

const TEMPLATE = `'FILENAME': ((module) =&gt; {
BODY
return module
})({})`

const BOTTOM = '}'

const createEverything = (filenames) =&gt; {
  const sections = filenames.map(filename =&gt; {
    const body = fs.readFileSync(filename, 'utf-8')
    return TEMPLATE
      .replace('FILENAME', filename)
      .replace('BODY', body)
  })
  return `${TOP}\n${sections.join('\n')}\n${BOTTOM}`
}

const main = () =&gt; {
  const result = createEverything(process.argv.slice(2))
  console.log(result)
}

main()
</code></pre>
<pre title="concatenate-programmatically.sh"><code class="language-sh">node concatenate-programmatically.js simple/other.js &gt; concatenate-programmatically-output.js
</code></pre>
<pre title="concatenate-programmatically-output.js"><code class="language-js">everything = {
'simple/other.js': ((module) =&gt; {
const other = () =&gt; {
  return 'message from other'
}

module.exports = other

return module
})({})
}
</code></pre>
<ul>
<li>Load and evaluate that file and check that <code>everything</code> is defined correctly</li>
</ul>
<pre title="concatenate-programmatically-output-test.js"><code class="language-js">
const fs = require('fs')
const source = fs.readFileSync('concatenate-programmatically-output.js', 'utf-8')
eval(source)
console.log(everything)
</code></pre>
<pre title="concatenate-programmatically-output-test.txt"><code class="language-txt">{ 'simple/other.js': { exports: [Function: other] } }
</code></pre>
<h2 id="how-can-we-find-all-the-dependencies">How can we find all the dependencies?</h2>
<ul>
<li>To get dependencies for one file, parse it and extract all the <code>require</code> calls
<ul>
<li>Relatively straightforward given what we know about <a href="https://github.com/acornjs/acorn">Acorn</a></li>
<li>Though notice how we build the module so that it can be run from the command line <em>or</em> loaded</li>
</ul>
</li>
</ul>
<pre title="extract-require.js"><code class="language-js">const acorn = require('acorn')
const fs = require('fs')
const walk = require('acorn-walk')

const getRequires = (filename) =&gt; {
  const entryPointFile = filename
  const text = fs.readFileSync(entryPointFile)
  const ast = acorn.parse(text)
  const requires = []
  walk.simple(ast, {
    CallExpression: (node, state) =&gt; {
      if ((node.callee.type === 'Identifier') &amp;&amp;
          (node.callee.name === 'require')) {
        state.push(node.arguments[0].value)
      }
    }
  }, null, requires)
  return requires
}

if (require.main === module) {
  const result = getRequires(process.argv[2])
  console.log(result)
} else {
  module.exports = getRequires
}
</code></pre>
<pre title="extract-require.sh"><code class="language-sh">node extract-require.js full/main.js
</code></pre>
<pre title="extract-require.txt"><code class="language-txt">[
  './top-left',
  './top-right',
  './subdir/bottom-left',
  './subdir/bottom-right'
]
</code></pre>
<ul>
<li>To get all dependencies, need to find <g key="transitive_closure">transitive closure</g>
<ul>
<li>Requirements of requirements of requirements of...</li>
<li>But allow for the case of X and Y requiring each other</li>
</ul>
</li>
<li>Algorithm uses two sets
<ul>
<li>Things we have seen (initially empty)</li>
<li>Things we haven't looked at yet (initially the first file)</li>
</ul>
</li>
<li>Keep taking items from <code>pending</code> until it is empty
<ul>
<li>If the current thing is already in <code>seen</code>, do nothing</li>
<li>Otherwise get its dependencies and add them to either <code>seen</code> or <code>pending</code></li>
</ul>
</li>
<li>Complicated by the fact that we can load something under different names
<ul>
<li><code>./subdir/bottom-left</code> from <code>main</code>, but <code>./bottom-left</code> from <code>./subdir/bottom-right</code></li>
<li>We will use <g key="absolute_path">absolute paths</a> as unique identifiers</li>
</ul>
</li>
<li>Also complicated by the fact that JavaScript's <code>Set</code> doesn't have an equivalent of <code>Array.pop</code>
<ul>
<li>So we will maintain the &quot;set&quot; of pending items as a list</li>
</ul>
</li>
</ul>
<pre title="transitive-closure-only.js"><code class="language-js">const path = require('path')

const getRequires = require('./extract-require')

const transitiveClosure = (entryPointPath) =&gt; {
  const pending = [path.resolve(entryPointPath)]
  const seen = new Set()
  while (pending.length &gt; 0) {
    const candidate = path.resolve(pending.pop())
    if (seen.has(candidate)) {
      continue
    }
    seen.add(candidate)
    const candidateDir = path.dirname(candidate)
    getRequires(candidate)
      .map(raw =&gt; path.resolve(path.join(candidateDir, `${raw}.js`)))
      .filter(cooked =&gt; !seen.has(cooked))
      .forEach(cooked =&gt; pending.push(cooked))
  }
  return [...seen]
}

if (module.loaded) {
  module.exports = transitiveClosure
} else {
  const result = transitiveClosure(process.argv[2])
  console.log(JSON.stringify(result, null, 2))
}
</code></pre>
<pre title="transitive-closure-only.sh"><code class="language-sh">node transitive-closure-only.js full/main.js
</code></pre>
<pre title="transitive-closure-only.txt"><code class="language-txt">[
  "/Users/gvwilson/stjs/module-bundler/full/main.js",
  "/Users/gvwilson/stjs/module-bundler/full/subdir/bottom-right.js",
  "/Users/gvwilson/stjs/module-bundler/full/subdir/bottom-left.js",
  "/Users/gvwilson/stjs/module-bundler/full/top-left.js",
  "/Users/gvwilson/stjs/module-bundler/full/top-right.js"
]
</code></pre>
<ul>
<li>This works...</li>
<li>...but we're not keeping track of the mapping from required names within files to absolute paths</li>
<li>So modify transitive closure to construct and return a second structure
<ul>
<li>Primary keys are the absolute paths to the files being required</li>
<li>Sub-keys are the paths actually used for loading</li>
<li>Values are primary keys</li>
</ul>
</li>
</ul>
<pre title="transitive-closure.js"><code class="language-js">const path = require('path')

const getRequires = require('./extract-require')

const transitiveClosure = (entryPointPath) =&gt; {
  const mapping = {}
  const pending = [path.resolve(entryPointPath)]
  const seen = new Set()
  while (pending.length &gt; 0) {
    const candidate = path.resolve(pending.pop())
    if (seen.has(candidate)) {
      continue
    }
    seen.add(candidate)
    mapping[candidate] = {}
    const candidateDir = path.dirname(candidate)
    getRequires(candidate)
      .map(raw =&gt; {
        mapping[candidate][raw] =
          path.resolve(path.join(candidateDir, `${raw}.js`))
        return mapping[candidate][raw]
      })
      .filter(cooked =&gt; cooked !== null)
      .forEach(cooked =&gt; pending.push(cooked))
  }
  return { filenames: [...seen], mapping }
}

if (require.main === module) {
  const result = transitiveClosure(process.argv[2])
  console.log(JSON.stringify(result, null, 2))
} else {
  module.exports = transitiveClosure
}
</code></pre>
<pre title="transitive-closure.sh"><code class="language-sh">node transitive-closure.js full/main.js
</code></pre>
<pre title="transitive-closure.txt"><code class="language-txt">{
  "filenames": [
    "/Users/gvwilson/stjs/module-bundler/full/main.js",
    "/Users/gvwilson/stjs/module-bundler/full/subdir/bottom-right.js",
    "/Users/gvwilson/stjs/module-bundler/full/subdir/bottom-left.js",
    "/Users/gvwilson/stjs/module-bundler/full/top-left.js",
    "/Users/gvwilson/stjs/module-bundler/full/top-right.js"
  ],
  "mapping": {
    "/Users/gvwilson/stjs/module-bundler/full/main.js": {
      "./top-left": "/Users/gvwilson/stjs/module-bundler/full/top-left.js",
      "./top-right": "/Users/gvwilson/stjs/module-bundler/full/top-right.js",
      "./subdir/bottom-left": "/Users/gvwilson/stjs/module-bundler/full/subdir/bottom-left.js",
      "./subdir/bottom-right": "/Users/gvwilson/stjs/module-bundler/full/subdir/bottom-right.js"
    },
    "/Users/gvwilson/stjs/module-bundler/full/subdir/bottom-right.js": {
      "./bottom-left": "/Users/gvwilson/stjs/module-bundler/full/subdir/bottom-left.js"
    },
    "/Users/gvwilson/stjs/module-bundler/full/subdir/bottom-left.js": {
      "../top-left": "/Users/gvwilson/stjs/module-bundler/full/top-left.js",
      "./bottom-right": "/Users/gvwilson/stjs/module-bundler/full/subdir/bottom-right.js"
    },
    "/Users/gvwilson/stjs/module-bundler/full/top-left.js": {},
    "/Users/gvwilson/stjs/module-bundler/full/top-right.js": {
      "./top-left": "/Users/gvwilson/stjs/module-bundler/full/top-left.js"
    }
  }
}
</code></pre>
</main>
<footer>
<div class="row">
<div class="left3">
<a href="../module-loader/"><em>&laquo; Module Loader</em></a>
</div>
<div class="middle3">
<a href="../license/"><img class="footer" src="../static/cc-by.svg" alt="License" /></a>
<a href="https://github.com/gvwilson/e/"><img class="footer" src="../static/github.svg" alt="Repository" /></a>
© 2020 <a href="../authors/">The Authors</a>
</div>
<div class="right3">
<a href="../layout-engine/"><em>Layout Engine &raquo;</em></a>
</div>
</div>
</footer>
</body>
</html>
