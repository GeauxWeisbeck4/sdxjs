<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
  <title>Package Manager</title>
  <meta name="toRoot" content="..">
  <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
  <link href="../static/site.css" rel="stylesheet" type="text/css">
  <script src="../static/site.js"></script>
  <script>window.onload = () => fixPage()</script>
</head>
<body id="_top">
<nav>
<div class="row">
<div class="left2">
<a href="http://third-bit.com"><img src="../static/logo.svg" alt="site logo" class="site-logo"/></a>
<a href="../"><em>Software Tools in JavaScript</em></a>
</div>
<div class="right2">
<div class="dropdown">
<span class="navtitle">▿ Sections</span>
<div class="dropdown-content" id="Sections">
</div>
</div>
<div class="dropdown">
<span class="navtitle">▿ Chapters</span>
<div class="dropdown-content" id="Chapters">
<a href="../systems-programming/"><span class="nowrap">Systems Programming</span></a>
<br/><a href="../promises/"><span class="nowrap">Promises</span></a>
<br/><a href="../unit-test/"><span class="nowrap">Unit Testing</span></a>
<br/><a href="../file-backup/"><span class="nowrap">File Backup</span></a>
<br/><a href="../style-checker/"><span class="nowrap">Style Checker</span></a>
<br/><a href="../pattern-matching/"><span class="nowrap">Pattern Matching</span></a>
<br/><a href="../regex-parser/"><span class="nowrap">Parsing Expressions</span></a>
<br/><a href="../code-generator/"><span class="nowrap">Code Generator</span></a>
<br/><a href="../page-templates/"><span class="nowrap">Page Templates</span></a>
<br/><a href="../doc-generator/"><span class="nowrap">Documentation Generator</span></a>
<br/><a href="../file-interpolator/"><span class="nowrap">File Interpolator</span></a>
<br/><a href="../module-loader/"><span class="nowrap">Module Loader</span></a>
<br/><a href="../module-bundler/"><span class="nowrap">Module Bundler</span></a>
<br/><a href="../build-manager/"><span class="nowrap">Build Manager</span></a>
<br/><a href="../layout-engine/"><span class="nowrap">Layout Engine</span></a>
<br/><a href="../text-editor/"><span class="nowrap">Text Editor</span></a>
<br/><a href="../package-manager/"><span class="nowrap">Package Manager</span></a>
<br/><a href="../conclusion/"><span class="nowrap">Conclusion</span></a>
</div>
</div>
<div class="dropdown">
<span class="navtitle">▿ Appendices</span>
<div class="dropdown-content" id="Appendices">
<a href="../bib/"><span class="nowrap">Bibliography</span></a>
<br/><a href="../license/"><span class="nowrap">License</span></a>
<br/><a href="../conduct/"><span class="nowrap">Code of Conduct</span></a>
<br/><a href="../contributing/"><span class="nowrap">Contributing</span></a>
<br/><a href="../gloss/"><span class="nowrap">Glossary</span></a>
<br/><a href="../links/"><span class="nowrap">Links</span></a>
<br/><a href="../solutions/"><span class="nowrap">Solutions</span></a>
<br/><a href="../authors/"><span class="nowrap">Authors</span></a>
</div>
</div>
</div>
</div>
</nav>
  <main>
  <h1>Package Manager</h1>
  <p class="lede">Getting and installing packages</p>
<ul>
<li>There's no point building software if you can't install it</li>
<li>Inspired by <a href="https://www.ctan.org/">CTAN</a>, most languages now have an online archive from which developers can download packages
<ul>
<li>Package name</li>
<li>Version(s)</li>
<li>List of dependencies, which may also have versions</li>
</ul>
</li>
<li>Download and installing files uses the systems programming skills of <xref key="systems-programming"></xref></li>
<li>But figuring out which packages to download can be very difficult
<ul>
<li>What if A and B require different versions of C?</li>
<li>Or requires different ranges of versions of C, but there is overlap?</li>
</ul>
</li>
<li>Explore how to find a workable installation or prove that there isn't one
<ul>
<li>Based in part on <a href="https://classic.yarnpkg.com/blog/2017/07/11/lets-dev-a-package-manager/">this tutorial</a> by Maël Nison</li>
</ul>
</li>
</ul>
<h2 id="what-is-semantic-versioning">What is semantic versioning?</h2>
<ul>
<li>Most software projects use <g key="semantic_versioning">semantic versioning</g> for software releases</li>
<li>Version number consists of three integers X.Y.Z:
<ul>
<li>X is the major version</li>
<li>Y is the minor version</li>
<li>Z is the <g key="patch">patch</g> number</li>
<li><a href="https://semver.org/">Full spec</a> allows for more fields, but we will ignore them</li>
</ul>
</li>
<li>Increment major version number every time there's an incompatible externally-visible change</li>
<li>Increment minor version number when adding new functionality in a <g key="backward_compatible">backward-compatible</g> manner
(i.e. without breaking any existing code)</li>
<li>Increment the patch number for backwards-compatible bug fixes that don't add any new features</li>
<li>When specifying a project's dependencies:
<ul>
<li><code>&gt;= 1.2.3</code> means &quot;any version after 1.2.3&quot;</li>
<li><code>&lt; 4</code> means &quot;any version before 4.anything&quot;</li>
<li><code>1.0 - 3.1</code> means &quot;any version in the specified range (including patches)&quot;</li>
<li>Note that 2.1 is greater than 1.99</li>
</ul>
</li>
<li>The <a href="https://www.npmjs.com/package/semver">semver</a> module provides lots of useful functions
<ul>
<li><code>semver.valid('1.2.3')</code></li>
<li><code>semver.satisfies('2.2', '1.0 - 3.1')</code></li>
</ul>
</li>
</ul>
<h2 id="how-can-we-find-a-consistent-set-of-packages">How can we find a consistent set of packages?</h2>
<ul>
<li>Imagine each package is an axis in a multi-dimensional space, with its versions as the tick marks
<ul>
<li>Each point in the space is a possible combination of package versions</li>
<li>Check if a point satisfies all of the constraints</li>
</ul>
</li>
<li>Example
<ul>
<li>Package X
<ul>
<li>X/1 requires Y/1-2 and Z/1</li>
<li>X/2 requires Y/2-3 and Z/1-2</li>
</ul>
</li>
<li>Package Y
<ul>
<li>Y/1 requires Z/2</li>
<li>Y/2 requires Z/2-3</li>
<li>Y/3 requires Z/3</li>
</ul>
</li>
<li>Package Z
<ul>
<li>Z/1, Z/2, and Z/3 don't require anything</li>
</ul>
</li>
</ul>
</li>
<li>18 possibilities (2 for X times 3 for Y times 3 for Z)
<ul>
<li>But 16 are excluded by various incompatibilities</li>
<li>Of the two remaining possibilities, X/2 + Y/3 + Z/3 is strictly greater than X/2 + Y/2 + Z/2</li>
<li>If we wound up with A/1 + B/2 vs. A/2 + B/1, we'd have to add another rule</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>X</th>
<th>Y</th>
<th>Z</th>
<th>Excluded</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>Y/1 - Z/1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>2</td>
<td>X/1 - Z/2</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>3</td>
<td>X/1 - Z/3</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>1</td>
<td>Y/2 - Z/1</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>2</td>
<td>X/1 - Z/2</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>3</td>
<td>X/1 - Z/3</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
<td>1</td>
<td>X/1 - Y/3</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
<td>2</td>
<td>X/1 - Y/3</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
<td>3</td>
<td>X/1 - Y/3</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>1</td>
<td>X/2 - Y/1</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>2</td>
<td>X/2 - Y/1</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>3</td>
<td>X/2 - Y/1</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>1</td>
<td>Y/2 - Z/1</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>3</td>
<td>X/2 - Z/3</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>1</td>
<td>Y/3 - Z/1</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>2</td>
<td>Y/3 - Z/2</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>3</td>
<td>X/2 - Z/3</td>
</tr>
</tbody>
</table>
<ul>
<li>How did we do this?
<ul>
<li>Find all versions of all packages plus their constraints (<g key="transitive_closure">transitive closure</g>)</li>
<li>Pick any two and create a list of valid pairs</li>
<li>Add a third: cross off pairs that can't be satisfied, generate triples of possibilities</li>
<li>Repeat until all packages included</li>
</ul>
</li>
<li>Worst case, wind up with <g key="exponential_explosion">exponential explosion</g> of possibilities
<ul>
<li>Smart algorithms will try to pick additions that minimize the number of new possibilities added</li>
<li>Or create pairs, then combine pairs of pairs, etc.</li>
<li>Our algorithm will be simple (and therefore slow)</li>
</ul>
</li>
</ul>
<h2 id="how-can-we-implement-constraint-satisfaction">How can we implement constraint satisfaction?</h2>
<ul>
<li>Read a JSON data structure describing the problem
<ul>
<li>A real package manager would read <g key="manifest">manifests</g> of packages and construct this structure</li>
<li>Really wish JSON had a standard way to represent comments…</li>
</ul>
</li>
<li>Stick to single-digit version numbers for readability</li>
</ul>
<pre title="double-chained.json"><code class="language-json">{
  "X": {
    "1": {
      "Y": ["1"]
    },
    "2": {
      "Y": ["2"]
    }
  },
  "Y": {
    "1": {},
    "2": {}
  }
}
</code></pre>
<ul>
<li>Check if a configuration (specific versions of all packages) is compatible with a manifest</li>
</ul>
<pre title="allows.js"><code class="language-js">const configStr = require('./config-str')

const allows = (manifest, config) =&gt; {
  for (const [leftN, leftV] of Object.entries(config)) {
    const requirements = manifest[leftN][leftV]
    for (const [rightN, bVAll] of Object.entries(requirements)) {
      if (!bVAll.includes(config[rightN])) {
        const title = configStr(config)
        const missing = config[rightN]
        console.log(`${title} @ ${leftN}/${leftV} ${rightN}/${missing}`)
        return false
      }
    }
  }
  console.log(configStr(config))
  return true
}

module.exports = allows
</code></pre>
<ul>
<li>Simplest way to find configuration is to sweep over all possibilities</li>
</ul>
<pre title="sweep.js"><code class="language-js">const allows = require('./allows')

const sweep = (manifest) =&gt; {
  const names = Object.keys(manifest)
  const result = []
  recurse(manifest, names, {}, result)
  return result
}

const recurse = (manifest, names, configuration, result) =&gt; {
  if (names.length === 0) {
    if (allows(manifest, configuration)) {
      result.push({ ...configuration })
    }
  } else {
    const next = names[0]
    const rest = names.slice(1)
    for (const version in manifest[next]) {
      configuration[next] = version
      recurse(manifest, rest, configuration, result)
    }
  }
}

module.exports = sweep
</code></pre>
<ul>
<li>Run this on the short example</li>
</ul>
<pre title="sweep-double-chained.sh"><code class="language-sh">node driver.js ./sweep double-chained.json
</code></pre>
<pre title="sweep-double-chained.txt"><code class="language-txt">{X:1 Y:1}
{X:1 Y:2} @ X/1 Y/2
{X:2 Y:1} @ X/2 Y/1
{X:2 Y:2}
</code></pre>
<ul>
<li>And on the longer example</li>
</ul>
<pre title="sweep-double-chained.sh"><code class="language-sh">node driver.js ./sweep double-chained.json
</code></pre>
<pre title="sweep-double-chained.txt"><code class="language-txt">{X:1 Y:1}
{X:1 Y:2} @ X/1 Y/2
{X:2 Y:1} @ X/2 Y/1
{X:2 Y:2}
</code></pre>
<ul>
<li>But look at unnecessary work in output
<ul>
<li>Sort by the case that caught the exclusion</li>
<li>9 of the 17 exclusions are redundant rediscovery of a known problem</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>Excluded</th>
<th>X</th>
<th>Y</th>
<th>Z</th>
</tr>
</thead>
<tbody>
<tr>
<td>X/1 - Y/3</td>
<td>1</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>…</td>
<td>1</td>
<td>3</td>
<td>2</td>
</tr>
<tr>
<td>…</td>
<td>1</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>X/1 - Z/2</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>…</td>
<td>1</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>X/1 - Z/3</td>
<td>1</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>…</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>X/2 - Y/1</td>
<td>2</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>…</td>
<td>2</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>…</td>
<td>2</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>X/2 - Z/3</td>
<td>2</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>…</td>
<td>2</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>Y/1 - Z/1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>Y/2 - Z/1</td>
<td>1</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>…</td>
<td>2</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>Y/3 - Z/1</td>
<td>2</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>…</td>
<td>2</td>
<td>3</td>
<td>2</td>
</tr>
<tr>
<td></td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
</tbody>
</table>
<ul>
<li>How can we avoid doing a full check of things that can't possibly work?</li>
</ul>
</main>
<footer>
<div class="row">
<div class="left3">
<a href="../text-editor/"><em>&laquo; Text Editor</em></a>
</div>
<div class="middle3">
<a href="../license/"><img class="footer" src="../static/cc-by.svg" alt="License" /></a>
<a href="https://github.com/gvwilson/e/"><img class="footer" src="../static/github.svg" alt="Repository" /></a>
© 2020 <a href="../authors/">The Authors</a>
</div>
<div class="right3">
<a href="../conclusion/"><em>Conclusion &raquo;</em></a>
</div>
</div>
</footer>
</body>
</html>
