<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
  <title>Style Checker</title>
  <meta name="toRoot" content="..">
  <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
  <link href="../static/site.css" rel="stylesheet" type="text/css">
  <script src="../static/site.js"></script>
  <script>window.onload = () => fixPage()</script>
</head>
<body id="_top">
<nav>
<div class="row">
<div class="left2">
<a href="http://third-bit.com"><img src="../static/logo.svg" alt="site logo" class="site-logo"/></a>
<a href="../"><em>Software Tools in JavaScript</em></a>
</div>
<div class="right2">
<div class="dropdown">
<span class="navtitle">▿ Sections</span>
<div class="dropdown-content" id="Sections">
</div>
</div>
<div class="dropdown">
<span class="navtitle">▿ Chapters</span>
<div class="dropdown-content" id="Chapters">
<a href="../systems-programming/"><span class="nowrap">Systems Programming</span></a>
<br/><a href="../promises/"><span class="nowrap">Promises</span></a>
<br/><a href="../unit-test/"><span class="nowrap">Unit Testing</span></a>
<br/><a href="../file-backup/"><span class="nowrap">File Backup</span></a>
<br/><a href="../style-checker/"><span class="nowrap">Style Checker</span></a>
<br/><a href="../code-generator/"><span class="nowrap">Code Generator</span></a>
<br/><a href="../page-templates/"><span class="nowrap">Page Templates</span></a>
<br/><a href="../doc-generator/"><span class="nowrap">Documentation Generator</span></a>
<br/><a href="../module-loader/"><span class="nowrap">Module Loader</span></a>
<br/><a href="../module-bundler/"><span class="nowrap">Module Bundler</span></a>
<br/><a href="../layout-engine/"><span class="nowrap">Layout Engine</span></a>
<br/><a href="../text-editor/"><span class="nowrap">Text Editor</span></a>
<br/><a href="../http-server/"><span class="nowrap">HTTP Server</span></a>
<br/><a href="../tabular-data/"><span class="nowrap">Tabular Data</span></a>
<br/><a href="../build-manager/"><span class="nowrap">Build Manager</span></a>
<br/><a href="../package-manager/"><span class="nowrap">Package Manager</span></a>
<br/><a href="../conclusion/"><span class="nowrap">Conclusion</span></a>
</div>
</div>
<div class="dropdown">
<span class="navtitle">▿ Appendices</span>
<div class="dropdown-content" id="Appendices">
<a href="../license/"><span class="nowrap">License</span></a>
<br/><a href="../conduct/"><span class="nowrap">Code of Conduct</span></a>
<br/><a href="../contributing/"><span class="nowrap">Contributing</span></a>
<br/><a href="../bib/"><span class="nowrap">Bibliography</span></a>
<br/><a href="../gloss/"><span class="nowrap">Glossary</span></a>
<br/><a href="../links/"><span class="nowrap">Links</span></a>
<br/><a href="../solutions/"><span class="nowrap">Solutions</span></a>
<br/><a href="../authors/"><span class="nowrap">Authors</span></a>
</div>
</div>
</div>
</div>
</nav>
  <main>
  <h1>Style Checker</h1>
  <p class="lede">Checking that code conforms to style guidelines</p>
<ul>
<li>Goal: check that source code conforms to style guidelines.
<ul>
<li>Tools like this are called <g key="linter">linters</g> in honor of an early one for C named <code>lint</code>
because it looked for fluff in source code</li>
<li>&quot;That's legal, but you shouldn't do it&quot;</li>
</ul>
</li>
<li>Inspirations:
<ul>
<li><a href="https://eslint.org/">ESLint</a></li>
</ul>
</li>
<li>Design:
<ul>
<li>Parse source code to create a data structure</li>
<li>Go through the data structure and apply rules for each part of the program</li>
<li>Collect results and report them all at the end</li>
</ul>
</li>
</ul>
<h2 id="how-can-we-parse-javascript-to-create-an-ast">How can we parse JavaScript to create an AST?</h2>
<ul>
<li>A parser for a simple language like arithmetic or JSON is relatively easy to write
<ul>
<li>We could do it in a chapter</li>
</ul>
</li>
<li>A parser for a language as complex as JavaScript is much more work</li>
<li>We will use <a href="https://github.com/acornjs/acorn">Acorn</a> instead</li>
</ul>
<pre title="parse-single-const.js"><code class="language-js">const acorn = require('acorn')

const ast = acorn.parse('const x = 0', {locations: true})
console.log(ast)
</code></pre>
<pre title="parse-single-const.text"><code class="language-text">Node {
  type: 'Program',
  start: 0,
  end: 11,
  loc:
   SourceLocation {
     start: Position { line: 1, column: 0 },
     end: Position { line: 1, column: 11 } },
  body:
   [ Node {
       type: 'VariableDeclaration',
       start: 0,
       end: 11,
       loc: [SourceLocation],
       declarations: [Array],
       kind: 'const' } ],
  sourceType: 'script' }
</code></pre>
<ul>
<li>Produces an <g key="abstract_syntax_tree">abstract syntax tree</g> (AST)
whose nodes store information about what's in the program</li>
<li><a href="https://esprima.org/">Esprima</a> format
<ul>
<li>But we can figure most of it out by inspection rather than by reading the standard</li>
</ul>
</li>
<li>Look at the result of parsing a slightly more complex program
<ul>
<li>A 9-line program produces over 500 lines of structure</li>
</ul>
</li>
</ul>
<pre title="parse-const-func-and-call.js"><code class="language-js">const acorn = require('acorn')

const program = `const value = 2

const double = (x) =&gt; {
  const y = 2 * x
  return y
}

const result = double(value)
console.log(result)
`

const ast = acorn.parse(program, {locations: true})
console.log(JSON.stringify(ast, null, 2))
</code></pre>
<pre title="parse-const-func-and-call.text"><code class="language-text">{
  "type": "Program",
  "start": 0,
  "end": 122,
  "loc": {
    "start": {
      "line": 1,
      "column": 0
    },
    "end": {
      "line": 10,
      "column": 0
    }
  },
  "body": [
    {
      "type": "VariableDeclaration",
      "start": 0,
      "end": 15,
      "loc": {
        "start": {
          "line": 1,
          "column": 0
        },
        "end": {
          "line": 1,
          "column": 15
        }
      },
      "declarations": [
...480 more lines...
</code></pre>
<h2 id="how-can-we-walk-the-ast">How can we walk the AST?</h2>
<ul>
<li>To <g key="walk_tree">walk a tree</g> means to visit each node in turn</li>
<li>Use a helper library <code>acorn-walk</code> to do this
<ul>
<li>Provide a function to act on nodes of type <code>Identifier</code></li>
<li>Use options to say that we want to record locations and to collect comments (in the array <code>onComment</code>)</li>
<li>We create an object called <code>state</code> to record declaration nodes as they're found</li>
<li>Then report them all at the end</li>
</ul>
</li>
</ul>
<pre title="walk-ast.js"><code class="language-js">const acorn = require('acorn')
const walk = require('acorn-walk')

const program = `// Constant
const value = 2

// Function
const double = (x) =&gt; {
  const y = 2 * x
  return y
}

// Main body
const result = double(value)
console.log(result)
`

const options = {
  locations: true,
  onComment: []
}
const ast = acorn.parse(program, options)

const state = {decl: []}
walk.simple(ast, {
  Identifier: (node, state) =&gt; {
    state.decl.push(node)
  }
}, null, state)

state.decl.forEach(node =&gt; console.log(
  `identifier ${node.name} on line ${node.loc.start.line}`
))
const comments = options.onComment.map(
  node =&gt; node.loc.start.line
).join(', ')
console.log(`comments on lines ${comments}`)
</code></pre>
<pre title="walk-ast.text"><code class="language-text">identifier x on line 6
identifier y on line 7
identifier double on line 11
identifier value on line 11
identifier console on line 12
identifier result on line 12
comments on lines 1, 4, 10
</code></pre>
<h2 id="how-can-we-apply-checks">How can we apply checks?</h2>
<ul>
<li>Check the desired properties of nodes of interest</li>
<li>Accumulate results on demand
<ul>
<li>Only create arrays of results when nodes of that type are encountered</li>
<li>Only insert nodes that fail checks</li>
</ul>
</li>
</ul>
<pre title="check-name-lengths.js"><code class="language-js">const acorn = require('acorn')
const walk = require('acorn-walk')

const program = `// Constant
const value = 2

// Function
const double = (x) =&gt; {
  const y = 2 * x
  return y
}

// Main body
const result = double(value)
console.log(result)
`

const applyCheck = (state, label, node, passes) =&gt; {
  if (!passes) {
    if (!(label in state)) {
      state[label] = []
    }
    state[label].push(node)
  }
}

const ast = acorn.parse(program, {locations: true})

const state = {}
walk.simple(ast, {
  Identifier: (node, state) =&gt; {
    applyCheck(state, 'name_length', node, node.name.length &gt;= 4)
  }
}, null, state)

state.name_length.forEach(
  node =&gt; console.log(`${node.name} at line ${node.loc.start.line}`))
</code></pre>
<pre title="check-name-lengths.text"><code class="language-text">x at line 6
y at line 7
</code></pre>
<ul>
<li>Why doesn't the parameter <code>x</code> show up as a violation?</li>
</ul>
<h2 id="how-does-the-ast-walker-work">How does the AST walker work?</h2>
<ul>
<li>Use the <g key="visitor_pattern">Visitor</g> design pattern</li>
<li>Define a class with methods that
<ul>
<li>Walk the tree</li>
<li>Take action depending on the kind of node</li>
<li>Go through the children of that node</li>
</ul>
</li>
<li>Users overrides the set of action methods they're interested in
<ul>
<li>Use <g key="dynamic_lookup">dynamic lookup</g> to look up a method
with the same name as the node type in the walker object</li>
<li>I.e., use the walker object as a lookup table</li>
</ul>
</li>
<li>Not the same architecture as <code>acorn-walk</code>
<ul>
<li>But easier to understand and extend</li>
</ul>
</li>
</ul>
<pre title="walker-class.js"><code class="language-js">const acorn = require('acorn')

// Generic tree walking class.
class Walker {
  // Construct a new AST tree walker.
  constructor (ast) {
    this.ast = ast
  }

  // Walk the tree.
  walk (accumulator) {
    this.stack = []
    this._walk(this.ast, accumulator)
    return accumulator
  }

  // Act on node and then on children.
  _walk (node, accumulator) {
    if (node &amp;&amp; (typeof node === 'object') &amp;&amp; ('type' in node)) {
      this._doNode(node, accumulator)
      this._doChildren(node, accumulator)
    }
  }

  // Handle a single node by lookup.
  _doNode (node, accumulator) {
    if (node.type in this) {
      this[node.type](node, accumulator)
    }
  }

  // Recurse for anything interesting within the node.
  _doChildren (node, accumulator) {
    this.stack.push(node)
    for (let key in node) {
      if (Array.isArray(node[key])) {
        node[key].forEach(child =&gt; {
          this._walk(child, accumulator)
        })
      }
      else if (typeof node[key] === 'object') {
        this._walk(node[key], accumulator)
      }
    }
    this.stack.pop(node)
  }

  // Is the current node a child of some other type of node?
  _childOf (nodeTypes) {
    return this.stack
      &amp;&amp; nodeTypes.includes(this.stack.slice(-1)[0].type)
  }
}

// Walk to accumulate variable and parameter definitions.
class VariableWalker extends Walker {
  Identifier (node, accumulator) {
    if (this._childOf(['ArrowFunctionExpression',
                       'VariableDeclarator'])) {
      accumulator.push(node.name)
    }
  }
}

// Test.
const program = `const value = 2

const double = (x) =&gt; {
  const y = 2 * x
  return y
}

const result = double(value)
console.log(result)
`

const ast = acorn.parse(program, {locations: true})
const walker = new VariableWalker(ast)
const accumulator = []
walker.walk(accumulator)
console.log('definitions are', accumulator)
</code></pre>
<pre title="walker-class.text"><code class="language-text">definitions are [ 'value', 'double', 'x', 'y', 'result' ]
</code></pre>
<h2 id="how-else-could-the-ast-walker-work">How else could the AST walker work?</h2>
<ul>
<li>An alternative approach uses the <g key="iterator_pattern">Iterator</g> pattern
<ul>
<li>Return elements of a complex structure one by one for processing</li>
<li>Visitor takes computation to the nodes, Iterator gets the nodes for processing</li>
</ul>
</li>
<li>Can implement in JavaScript using <g key="generator_function">generator functions</g></li>
<li>Use <code>yield</code> to return a value and suspend processing to be resumed later
<ul>
<li>Result is a two-part structure with <code>value</code> and <code>done</code></li>
</ul>
</li>
<li>Note that a generator function returns an object that then returns values</li>
</ul>
<pre title="generator-example.js"><code class="language-js">function* threeWords () {
  yield 'first'
  yield 'second'
  yield 'third'
}

const gen = threeWords()

console.log(gen.next())
console.log(gen.next())
console.log(gen.next())
console.log(gen.next())
</code></pre>
<pre title="generator-example.text"><code class="language-text">{ value: 'first', done: false }
{ value: 'second', done: false }
{ value: 'third', done: false }
{ value: undefined, done: true }
</code></pre>
<ul>
<li>This generator takes an irregular nested array of strings and yields:
<ul>
<li>A string</li>
<li>Another generator (using <code>yield*</code> to mean &quot;uses its values until they run out&quot;)</li>
</ul>
</li>
</ul>
<pre title="generator-tree.js"><code class="language-js">function* getNodes (here) {
  if (typeof here === 'string') {
    yield here
  }
  else if (Array.isArray(here)){
    for (const child of here) {
      yield* getNodes(child)
    }
  }
  else {
    throw new Exception(`unknown type "${typeof here}"`)
  }
}

module.exports = getNodes
</code></pre>
<ul>
<li>Manage iteration explicitly</li>
</ul>
<pre title="generator-tree-while.js"><code class="language-js">const getNodes = require('./generator-tree')

const nested = ['first', ['second', 'third']]
const gen = getNodes(nested)
let current = gen.next()
while (!current.done) {
  console.log(current.value)
  current = gen.next()
}
</code></pre>
<pre title="generator-tree-while.text"><code class="language-text">first
second
third
</code></pre>
<ul>
<li>But <code>for…of</code> knows how to work with generators</li>
</ul>
<pre title="generator-tree-for.js"><code class="language-js">const getNodes = require('./generator-tree')

const nested = ['first', ['second', 'third']]
for (const value of getNodes(nested)) {
  console.log(value)
}
</code></pre>
<pre title="generator-tree-for.text"><code class="language-text">first
second
third
</code></pre>
<ul>
<li>Use this to count the number of expressions of various types in code</li>
</ul>
<pre title="generator-count.js"><code class="language-js">const acorn = require('acorn')

function* getNodes (node) {
  if (node &amp;&amp; (typeof node === 'object') &amp;&amp; ('type' in node)) {
    yield node
    for (let key in node) {
      if (Array.isArray(node[key])) {
        for (const child of node[key]) {
          yield* getNodes(child)
        }
      }
      else if (typeof node[key] === 'object') {
        yield* getNodes(node[key])
      }
    }
  }
}

// Test.
const program = `const value = 2

const double = (x) =&gt; {
  const y = 2 * x
  return 2 * y + 1
}

const result = double(value)
console.log(result)
`

const ast = acorn.parse(program, {locations: true})
const result = {}
for (const node of getNodes(ast)) {
  if (node.type === 'BinaryExpression') {
    if (node.operator in result) {
      result[node.operator] += 1
    }
    else {
      result[node.operator] = 1
    }
  }
}
console.log('counts are', result)
</code></pre>
<pre title="generator-count.text"><code class="language-text">counts are { '*': 2, '+': 1 }
</code></pre>
<ul>
<li>More difficult to do variable identifiers than previous Visitor approach
<ul>
<li>Generator doesn't keep state, so we have to maintain that outside for ourselves</li>
</ul>
</li>
</ul>
<h2 id="exercises">Exercises</h2>
<h3>Function length</h3>
<p>Derive a class from <code>Walker</code> that reports the length in lines of each function defined in the code being checked.</p>
<h3>Expression depth</h3>
<p>Derive a class from <code>Walker</code> that reports how deep each top-level expression in the source code is.
For example,
the depth of <code>1 + 2 * 3</code> is 2,
while the depth of <code>max(1 + 2 + 3)</code> is 3
(one level for the function call, one for the first addition, and one for the nested addition).</p>
<h3>Downward and upward</h3>
<p>Modify <code>Walker</code> so that users can specify
one action to take at a node on the way down the tree
and a separate action to take on the way up.
(Hint: require users to specify <code>Nodename_downward</code> and/or <code>Nodename_upward</code> methods in their class,
then use string concatenation to construct method names while traversing the tree.)</p>
<h3>Aggregating across files</h3>
<p>Create a command-line program called <code>sniff.js</code>
that checks for style violations in any number of source files.
The first command-line argument to <code>sniff.js</code> must be a JavaScript source file
that exports a class derived from <code>Walker</code> called <code>Check</code>
that implements the checks the user wants.
The other command-line arguments must be the names of JavaScript source files to be checked:</p>
<pre title="across-files/sniff.sh"><code class="language-sh">node sniff.js my-check.js source-1.js source-2.js
</code></pre>
</main>
<footer>
<div class="row">
<div class="left3">
<a href="../file-backup/"><em>&laquo; File Backup</em></a>
</div>
<div class="middle3">
<a href="../license/"><img class="footer" src="../static/cc-by.svg" alt="License" /></a>
<a href="https://github.com/gvwilson/e/"><img class="footer" src="../static/github.svg" alt="Repository" /></a>
© 2020 <a href="../authors/">The Authors</a>
</div>
<div class="right3">
<a href="../code-generator/"><em>Code Generator &raquo;</em></a>
</div>
</div>
</footer>
</body>
</html>
