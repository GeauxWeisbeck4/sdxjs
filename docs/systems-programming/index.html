<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
  <title>Systems Programming</title>
  <meta name="toRoot" content="..">
  <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
  <link href="../static/site.css" rel="stylesheet" type="text/css">
  <script src="../static/site.js"></script>
  <script>window.onload = () => fixPage()</script>
</head>
<body id="_top">
<nav>
<div class="row">
<div class="left2">
<a href="http://third-bit.com"><img src="../static/logo.svg" alt="site logo" class="site-logo"/></a>
<a href="../"><em>Software Tools in JavaScript</em></a>
</div>
<div class="right2">
<div class="dropdown">
<span class="navtitle">▿ Sections</span>
<div class="dropdown-content" id="Sections">
</div>
</div>
<div class="dropdown">
<span class="navtitle">▿ Chapters</span>
<div class="dropdown-content" id="Chapters">
<a href="../systems-programming/"><span class="nowrap">Systems Programming</span></a>
<br/><a href="../promises/"><span class="nowrap">Promises</span></a>
<br/><a href="../unit-test/"><span class="nowrap">Unit Testing</span></a>
<br/><a href="../file-backup/"><span class="nowrap">File Backup</span></a>
<br/><a href="../data-table/"><span class="nowrap">Data Tables</span></a>
<br/><a href="../pattern-matching/"><span class="nowrap">Pattern Matching</span></a>
<br/><a href="../regex-parser/"><span class="nowrap">Parsing Expressions</span></a>
<br/><a href="../page-templates/"><span class="nowrap">Page Templates</span></a>
<br/><a href="../build-manager/"><span class="nowrap">Build Manager</span></a>
<br/><a href="../layout-engine/"><span class="nowrap">Layout Engine</span></a>
<br/><a href="../text-editor/"><span class="nowrap">Text Editor</span></a>
<br/><a href="../file-interpolator/"><span class="nowrap">File Interpolator</span></a>
<br/><a href="../module-loader/"><span class="nowrap">Module Loader</span></a>
<br/><a href="../module-bundler/"><span class="nowrap">Module Bundler</span></a>
<br/><a href="../package-manager/"><span class="nowrap">Package Manager</span></a>
<br/><a href="../style-checker/"><span class="nowrap">Style Checker</span></a>
<br/><a href="../code-generator/"><span class="nowrap">Code Generator</span></a>
<br/><a href="../doc-generator/"><span class="nowrap">Documentation Generator</span></a>
<br/><a href="../virtual-machine/"><span class="nowrap">Virtual Machine</span></a>
<br/><a href="../debugger/"><span class="nowrap">Debugger</span></a>
<br/><a href="../code-analyzer/"><span class="nowrap">Code Analyzer</span></a>
<br/><a href="../conclusion/"><span class="nowrap">Conclusion</span></a>
</div>
</div>
<div class="dropdown">
<span class="navtitle">▿ Appendices</span>
<div class="dropdown-content" id="Appendices">
<a href="../bib/"><span class="nowrap">Bibliography</span></a>
<br/><a href="../license/"><span class="nowrap">License</span></a>
<br/><a href="../conduct/"><span class="nowrap">Code of Conduct</span></a>
<br/><a href="../contributing/"><span class="nowrap">Contributing</span></a>
<br/><a href="../gloss/"><span class="nowrap">Glossary</span></a>
<br/><a href="../links/"><span class="nowrap">Links</span></a>
<br/><a href="../authors/"><span class="nowrap">Authors</span></a>
</div>
</div>
</div>
</div>
</nav>
  <main>
  <h1>Systems Programming</h1>
  <h2 class="lede">Using callbacks to manipulate files and directories</h2>
<ul>
<li>JavaScript is an <g key="asynchronous">asynchronous</g> language
<ul>
<li>Its designers didn't want browsers to freeze while waiting for data</li>
<li>So any operation that might be slow is implemented as &quot;describe what to do <em>later</em> when data is available&quot;</li>
<li>And anything that touches files is slow compared from a CPU's point of view</li>
</ul>
</li>
<li>JavaScript's original solution to this problem was hard to understand in programs of even moderate size
<ul>
<li>So a second layer was added, and then a third</li>
<li>We need to understand all three layers in order to debug things when they go wrong</li>
</ul>
</li>
<li>This chapter introduces the first two layers
<ul>
<li><xref key="file-backup"></xref> introduces the third</li>
</ul>
</li>
<li>This chapter also shows how to load libraries and how to work with files and directories
<ul>
<li>Because we're going to be doing a lot of both</li>
</ul>
</li>
</ul>
<h2 id="how-can-we-list-a-directory">How can we list a directory?</h2>
<ul>
<li>Let's try listing the contents of a directory the way we would in Python or Java</li>
</ul>
<pre title="list-dir-wrong.js"><code class="language-js">import fs from 'fs'

const srcDir = process.argv[2]
const results = fs.readdir(srcDir)
for (const name of results) {
  console.log(name)
}
</code></pre>
<ul>
<li>Use <code>require(library-name)</code> to load a library
<ul>
<li>Returns an object</li>
<li>Assign that to a constant
<ul>
<li>Allows us to give short nicknames to meaningfully-named libraries</li>
</ul>
</li>
<li>Use <code>library.component</code> to refer to things in the library</li>
</ul>
</li>
</ul>
<div class="callout">
<h3 id="require-versus-import"><code>require</code> versus <code>import</code></h3>
<p>In 2015, a new version of JavaScript called ES6 introduced the keyword <code>import</code> for importing modules.
It improves on <code>require</code> in several ways, but Node still uses <code>require</code> by default.
We can change our settings to use <code>import</code> instead,
but even if we do,
Node prints a warning message each time we run a program.
We have therefore decided to stick to <code>require</code> in this book.</p>
</div>
<ul>
<li>Use the <a href="https://nodejs.org/api/fs.html"><code>fs</code></a> library (&quot;fs&quot; is short for &quot;<g key="filesystem">filesystem</g>&quot;)
<ul>
<li>Contains functions to create directories, read or delete files, etc.</li>
</ul>
</li>
<li>The program's <g key="command_line_argument">command-line arguments</g> are stored in <code>process.argv</code>
<ul>
<li><code>process.argv[0]</code> is the name of the program used to run our code (in this case <code>node</code>)</li>
<li><code>process.argv[1]</code> is the name of our program (in this case <code>list-dir-wrong.js</code>)</li>
<li><code>process.argv[2]</code> is the first argument after the name of our program</li>
</ul>
</li>
<li><code>fs.readdir</code> is supposed to return an array of strings (the names of the things in the directory)</li>
<li>Use <code>for (const name of results)</code> to loop over the <em>contents</em> of that array
<ul>
<li><code>const name</code> means &quot;<code>name</code> is unchangeable inside the loop&quot;</li>
</ul>
</li>
<li>And <code>console.log</code> is the equivalent of other languages' <code>print</code>
<ul>
<li>Strange name because its original purpose was to create <g key="log_message">log messages</g> in the browser <g key="console">console</g></li>
</ul>
</li>
</ul>
<pre title="list-dir-wrong.sh"><code class="language-sh">node list-dir-wrong.js .
exit 0
</code></pre>
<pre title="list-dir-wrong.out"><code class="language-out">internal/process/esm_loader.js:74
    internalBinding('errors').triggerUncaughtException(
                              ^
TypeError [ERR_INVALID_CALLBACK]: Callback must be a function. Received \
 undefined
    at makeCallback (fs.js:168:11)
    at Object.readdir (fs.js:994:14)
    at /u/stjs/systems-programming/list-dir-wrong.js:4:20
    at ModuleJob.run (internal/modules/esm/module_job.js:146:23)
    at async Loader.import (internal/modules/esm/loader.js:165:24)
    at async Object.loadESM (internal/process/esm_loader.js:68:5) {
  code: 'ERR_INVALID_CALLBACK'
}
</code></pre>
<ul>
<li>Error message comes from something we didn't write whose source we would struggle to read
<ul>
<li>Our code is the third <code>at</code> line (look for the name of our file <code>list-dir-wrong.js</code>)</li>
<li>Everything below it is what Node does to load and run our program</li>
</ul>
</li>
<li>The problem is that <code>fs.readdir</code> doesn't return anything</li>
<li>Instead, its <a href="https://nodejs.org/api/fs.html">documentation</a> says that it takes a <g key="callback">callback function</g></li>
</ul>
<h2 id="what-is-a-callback-function">What is a callback function?</h2>
<ul>
<li>JavaScript uses a <g key="single_threaded">single-threaded</g> programming model
<ul>
<li>Any operation that might delay, such as file I/O, is split into &quot;start&quot; and &quot;data ready&quot;</li>
<li>The &quot;start&quot; part is the code we already have</li>
<li>We need to write a function that specifies what we want to do when our data is ready</li>
</ul>
</li>
<li>JavaScript saves a reference to this function to call when the data is ready
<ul>
<li>The function must take a specific set of parameters</li>
<li>A standard <g key="protocol">protocol</g> like the various kind of USB ports and connectors that allows us to plug things together</li>
</ul>
</li>
</ul>
<div class="fixme">
<p>diagram showing callbacks</p>
</div>
<pre title="list-dir-function-defined.js"><code class="language-js">import fs from 'fs'

const listContents = (err, files) =&gt; {
  console.log('running callback')
  if (err) {
    console.error(err)
  } else {
    for (const name of files) {
      console.log(name)
    }
  }
}

const srcDir = process.argv[2]
fs.readdir(srcDir, listContents)
console.log('last line of program')
</code></pre>
<ul>
<li>Node callbacks always get an error (if any) as their first argument
<ul>
<li>Use <code>console.error</code> to report it for now</li>
<li>Do something more sensible once we understand exceptions</li>
</ul>
</li>
<li>The results from successful execution are passed as the other argument (in this case, <code>files</code>)</li>
</ul>
<pre title="list-dir-function-defined.sh"><code class="language-sh">node list-dir-function-defined.js .
</code></pre>
<pre title="list-dir-function-defined.out"><code class="language-out">last line of program
running callback
Makefile
array-filter
copy-file-filtered.js
copy-file-unfiltered-wrap.sh
copy-file-unfiltered.js
copy-file-unfiltered.out
copy-file-unfiltered.sh
copy-file-unfiltered.txt
counting-lines
destructuring-assignment
glob-all-files.js
glob-all-files.out
glob-ensure-output-directory.js
glob-filter-with-options.js
glob-get-then-filter-idiomatic.js
glob-get-then-filter-pedantic.js
glob-get-then-filter-pedantic.out
glob-patterns
glob-with-dest-directory.js
glob-with-source-directory.js
index.md
list-dir-function-anonymous.js
list-dir-function-defined.js
list-dir-function-defined.out
list-dir-function-defined.sh
list-dir-wrong-wrapped.sh
list-dir-wrong.js
list-dir-wrong.sh
rename-files
significant-entries
string-interpolation
trace-anonymous
trace-callback
where-is-node
</code></pre>
<ul>
<li>Nothing else in this book will make sense if we don't understand the order of execution
<ol>
<li>Read the program file</li>
<li>Execute the first line to load the <code>fs</code> library</li>
<li>Define a function of two parameters and assign it to <code>listContents</code>
<ul>
<li>Remember, a function is just another kind of data</li>
<li>Instead of being made up of numbers, characters, or pixels, it is made up of instructions</li>
<li>But these are stored in memory like anything else</li>
</ul>
</li>
<li>Get the name of the directory from the command-line arguments</li>
<li>Call <code>fs.readdir</code> to start a filesystem operation
<ul>
<li>Tell it what directory we want to read</li>
<li>And what function to call when data is available</li>
</ul>
</li>
<li>Print a message to show we're at the end of the file</li>
<li>Wait (this part is invisible)</li>
<li>Filesystem operation finishes</li>
<li>Our callback function runs and prints its output</li>
</ol>
</li>
</ul>
<h2 id="what-are-anonymous-functions">What are anonymous functions?</h2>
<ul>
<li>More idiomatic to define the callback as an <g key="anonymous_function">anonymous function</g> where it's used
<ul>
<li>Most callbacks are only used in one place, so there's no need to give them names</li>
<li>Makes it easier to see what's going to happen when the operation completes</li>
<li>But takes some getting used to, since the order of execution is now very different from the order of reading.</li>
</ul>
</li>
</ul>
<pre title="list-dir-function-anonymous.js"><code class="language-js">import fs from 'fs'

const srcDir = process.argv[2]
fs.readdir(srcDir, (err, files) =&gt; {
  if (err) {
    console.error(err)
  } else {
    for (const name of files) {
      console.log(name)
    }
  }
})
</code></pre>
<h2 id="how-can-we-select-a-set-of-files">How can we select a set of files?</h2>
<ul>
<li>Often want to copy just a subset of files
<ul>
<li>Include only those listed</li>
<li>Copy everything except those explicitly excluded (the <code>.gitignore</code> model)</li>
</ul>
</li>
<li>Use the <a href="https://www.npmjs.com/package/glob"><code>glob</code></a> module
<ul>
<li><g key="globbing">Globbing</g> (short for &quot;global&quot;) is an old Unix term for matching a set of files by name</li>
<li>Like most of programming it works by filename, not by actual content type</li>
</ul>
</li>
</ul>
<pre title="glob-all-files.js"><code class="language-js">import glob from 'glob'

glob('**/*.*', (err, files) =&gt; {
  if (err) {
    console.log(err)
  } else {
    for (const filename of files) {
      console.log(filename)
    }
  }
})
</code></pre>
<pre title="glob-all-files.out"><code class="language-out">array-filter/filter.js
array-filter/filter.txt
array-filter/problem.md
array-filter/solution.md
copy-file-filtered.js
copy-file-unfiltered-wrap.sh
copy-file-unfiltered.js
copy-file-unfiltered.out
copy-file-unfiltered.sh
copy-file-unfiltered.txt
counting-lines/problem.md
counting-lines/solution.md
destructuring-assignment/problem.md
destructuring-assignment/solution.md
glob-all-files.js
glob-all-files.out
glob-ensure-output-directory.js
glob-filter-with-options.js
glob-get-then-filter-idiomatic.js
glob-get-then-filter-pedantic.js
glob-patterns/problem.md
glob-patterns/solution.md
glob-with-dest-directory.js
glob-with-source-directory.js
index.md
list-dir-function-anonymous.js
list-dir-function-defined.js
list-dir-function-defined.sh
list-dir-wrong-wrapped.sh
list-dir-wrong.js
list-dir-wrong.sh
rename-files/problem.md
rename-files/solution.md
significant-entries/problem.md
significant-entries/solution.md
string-interpolation/interpolate.js
string-interpolation/interpolate.txt
string-interpolation/problem.md
string-interpolation/solution.md
trace-anonymous/problem.md
trace-anonymous/solution.md
trace-anonymous/trace.js
trace-callback/problem.md
trace-callback/solution.md
trace-callback/trace.js
where-is-node/problem.md
where-is-node/solution.md
</code></pre>
<ul>
<li>Get filenames matching a pattern and then do something with the list
<ul>
<li>The leading <code>**</code> means &quot;recurse into subdirectories&quot;</li>
<li>The <code>*.*</code> means &quot;any characters followed by '.' followed by any characters&quot;</li>
<li>Names that <em>don't</em> match <code>*.*</code> won't be included</li>
<li>And by default, names that start with <code>.</code> (like <code>.gitignore</code>) aren't included</li>
</ul>
</li>
<li>Works, but we probably don't want to copy editor backup files ending with <code>~</code></li>
<li>We can get the list and then <g key="filter">filter</g> those out</li>
</ul>
<pre title="glob-get-then-filter-pedantic.js"><code class="language-js">import glob from 'glob'

glob('**/*.*', (err, files) =&gt; {
  if (err) {
    console.log(err)
  } else {
    files = files.filter((f) =&gt; { return !f.endsWith('~') })
    for (const filename of files) {
      console.log(filename)
    }
  }
})
</code></pre>
<pre title="glob-get-then-filter-pedantic.out"><code class="language-out">array-filter/filter.js
array-filter/filter.txt
array-filter/problem.md
array-filter/solution.md
copy-file-filtered.js
copy-file-unfiltered-wrap.sh
copy-file-unfiltered.js
copy-file-unfiltered.out
copy-file-unfiltered.sh
copy-file-unfiltered.txt
counting-lines/problem.md
counting-lines/solution.md
destructuring-assignment/problem.md
destructuring-assignment/solution.md
glob-all-files.js
glob-all-files.out
glob-ensure-output-directory.js
glob-filter-with-options.js
glob-get-then-filter-idiomatic.js
glob-get-then-filter-pedantic.js
glob-get-then-filter-pedantic.out
glob-patterns/problem.md
glob-patterns/solution.md
glob-with-dest-directory.js
glob-with-source-directory.js
index.md
list-dir-function-anonymous.js
list-dir-function-defined.js
list-dir-function-defined.sh
list-dir-wrong-wrapped.sh
list-dir-wrong.js
list-dir-wrong.sh
rename-files/problem.md
rename-files/solution.md
significant-entries/problem.md
significant-entries/solution.md
string-interpolation/interpolate.js
string-interpolation/interpolate.txt
string-interpolation/problem.md
string-interpolation/solution.md
trace-anonymous/problem.md
trace-anonymous/solution.md
trace-anonymous/trace.js
trace-callback/problem.md
trace-callback/solution.md
trace-callback/trace.js
where-is-node/problem.md
where-is-node/solution.md
</code></pre>
<ul>
<li><code>Array.filter</code> creates a new array containing all the items of the original that pass the test
<ul>
<li>The test is specified as a callback function called once for each item that returns a <g key="boolean">Boolean</g></li>
</ul>
</li>
</ul>
<div class="fixme">
<p>diagram showing Array.filter</p>
</div>
<ul>
<li>We can make this more idiomatic by:
<ul>
<li>Removing the parentheses around the single parameter</li>
<li>Writing just the expression we want the function to return</li>
</ul>
</li>
</ul>
<pre title="glob-get-then-filter-idiomatic.js"><code class="language-js">import glob from 'glob'

glob('**/*.*', (err, files) =&gt; {
  if (err) {
    console.log(err)
  } else {
    files = files.filter(f =&gt; !f.endsWith('~'))
    for (const filename of files) {
      console.log(filename)
    }
  }
})
</code></pre>
<ul>
<li>It turns out that <code>glob</code> can filter for us
<ul>
<li>Its documentation says it has an <code>options</code> argument</li>
<li>We can pass an object full of key-value settings to control its behavior</li>
<li>This is another common pattern in Node libraries and in our own code</li>
</ul>
</li>
</ul>
<pre title="glob-filter-with-options.js"><code class="language-js">import glob from 'glob'

glob('**/*.*', { ignore: '*~' }, (err, files) =&gt; {
  if (err) {
    console.log(err)
  } else {
    for (const filename of files) {
      console.log(filename)
    }
  }
})
</code></pre>
<ul>
<li>Notice that we don't quote the key in this object
<ul>
<li>The keys in objects are almost always strings</li>
<li>So if that string is simple enough that it won't confuse the parser, we don't need to put quotes around it</li>
<li>&quot;Simple enough&quot; means &quot;only contains letters, digits, and the underscore&quot;</li>
<li>Or equivalently &quot;looks like it could be a variable name&quot;</li>
</ul>
</li>
</ul>
<div class="callout">
<h3 id="no-one-knows-everything">No one knows everything</h3>
<p>We combined <code>glob.glob</code> and <code>Array.filter</code> in our functions for more than a year
before someone pointed out the <code>ignore</code> option for <code>glob.glob</code>.
This shows:</p>
<ol>
<li>
<p>Life is short,
so most of us find a way to solve the problem in front of us
and re-use it rather than looking for something better.</p>
</li>
<li>
<p>Code reviews aren't just about finding bugs:
they are also the most effective way to transfer knowledge between programmers.
Even if someone is much more experienced than you,
there's a good chance you might have stumbled over a better way to do something
than the one they're using (see point #1 above).</p>
</li>
</ol>
</div>
<ul>
<li>Now specify a source directory and fold that into the glob</li>
</ul>
<pre title="glob-with-source-directory.js"><code class="language-js">import glob from 'glob'

const srcDir = process.argv[2]

glob(`${srcDir}/**/*.*`, { ignore: '*~' }, (err, files) =&gt; {
  if (err) {
    console.log(err)
  } else {
    for (const filename of files) {
      console.log(filename)
    }
  }
})
</code></pre>
<ul>
<li>This uses <g key="string_interpolation">string interpolation</g>
<ul>
<li>Back-quote the string</li>
<li>Use <code>${name}</code> to insert the value of an expression</li>
<li>This is completely separate from the globbing</li>
</ul>
</li>
</ul>
<h2 id="how-can-we-copy-a-set-of-files">How can we copy a set of files?</h2>
<ul>
<li>We now have the <g key="path">paths</g> to the files we are copying</li>
<li>So we can take a second argument that specifies an output directory
<ul>
<li>Construct the output path by replacing the name of the source directory with the name of the output directory</li>
</ul>
</li>
</ul>
<pre title="glob-with-dest-directory.js"><code class="language-js">import glob from 'glob'

const [srcDir, dstDir] = process.argv.slice(2)

glob(`${srcDir}/**/*.*`, { ignore: '*~' }, (err, files) =&gt; {
  if (err) {
    console.log(err)
  } else {
    for (const srcName of files) {
      const dstName = srcName.replace(srcDir, dstDir)
      console.log(srcName, dstName)
    }
  }
})
</code></pre>
<ul>
<li>This uses <g key="destructuring_assignment">destructuring assignment</g> to create two variables at once
<ul>
<li>Only works if both source and destination are given on the command line, so we should check that</li>
</ul>
</li>
</ul>
<div class="fixme">
<p>diagram showing destructuring assignment</p>
</div>
<ul>
<li>But this only works if the destination directory already exists
<ul>
<li><code>fs</code> and equivalent libraries in other languages (mostly) won't create the directories we need automatically</li>
</ul>
</li>
<li>This comes up so often that there is a function <code>ensureDir</code> to do what we need</li>
</ul>
<pre title="glob-ensure-output-directory.js"><code class="language-js">import glob from 'glob'
import fs from 'fs-extra'
import path from 'path'

const [srcRoot, dstRoot] = process.argv.slice(2)

glob(`${srcRoot}/**/*.*`, { ignore: '*~' }, (err, files) =&gt; {
  if (err) {
    console.log(err)
  } else {
    for (const srcName of files) {
      const dstName = srcName.replace(srcRoot, dstRoot)
      const dstDir = path.dirname(dstName)
      fs.ensureDir(dstDir, (err) =&gt; {
        if (err) {
          console.error(err)
        }
      })
    }
  }
})
</code></pre>
<ul>
<li><a href="https://www.npmjs.com/package/fs-extra"><code>fs-extra</code></a> provides some useful utilities on top of <code>fs</code></li>
<li>And use <a href="https://nodejs.org/api/path.html"><code>path</code></a> to manipulate pathnames because someone else has figured out the string operations needed to handle various cases</li>
<li>This code gives us an empty tree of directories</li>
<li>Note the name changes
<ul>
<li>Use <code>srcRoot</code> and <code>dstRoot</code> because we're going to need <code>dstDir</code></li>
<li>Yes, this was a bug…</li>
</ul>
</li>
<li>We can now copy the files</li>
</ul>
<pre title="copy-file-unfiltered.js"><code class="language-js">import glob from 'glob'
import fs from 'fs-extra'
import path from 'path'

const [srcRoot, dstRoot] = process.argv.slice(2)

glob(`${srcRoot}/**/*.*`, { ignore: '*~' }, (err, files) =&gt; {
  if (err) {
    console.log(err)
  } else {
    for (const srcName of files) {
      const dstName = srcName.replace(srcRoot, dstRoot)
      const dstDir = path.dirname(dstName)
      fs.ensureDir(dstDir, (err) =&gt; {
        if (err) {
          console.error(err)
        } else {
          fs.copy(srcName, dstName, (err) =&gt; {
            if (err) {
              console.error(err)
            }
          })
        }
      })
    }
  }
})
</code></pre>
<ul>
<li>Three levels of callback
<ul>
<li>When <code>glob</code> has data, do things and then call <code>ensureDir</code></li>
<li>When <code>ensureDir</code> completes, copy a file</li>
<li>When <code>copy</code> finishes, check the error status</li>
</ul>
</li>
<li>Trace this for two directories each containing one file</li>
</ul>
<div class="fixme">
<p>diagram showing three levels of callback</p>
</div>
<ul>
<li>It <em>almost</em> works</li>
</ul>
<pre title="copy-file-unfiltered.sh"><code class="language-sh">rm -rf /tmp/out
mkdir /tmp/out
node copy-file-unfiltered.js ../node_modules /tmp/out 2&gt;&amp;1 | head -n 6
</code></pre>
<pre title="copy-file-unfiltered.out"><code class="language-out">[Error: ENOENT: no such file or directory, chmod \
 '/tmp/out/@nodelib/fs.stat/package.json'] {
  errno: -2,
  code: 'ENOENT',
  syscall: 'chmod',
  path: '/tmp/out/@nodelib/fs.stat/package.json'
}
</code></pre>
<ul>
<li><code>node_modules/fs.stat</code> is a directory, not a file, but matches our <code>glob</code>
<ul>
<li>Use <code>fs.stat</code> to get the properties of something in the filesystem and then check if it's a file</li>
<li>Name is short for &quot;status&quot;</li>
</ul>
</li>
</ul>
<pre title="copy-file-filtered.js"><code class="language-js">import glob from 'glob'
import fs from 'fs-extra'
import path from 'path'

const [srcRoot, dstRoot] = process.argv.slice(2)

glob(`${srcRoot}/**/*.*`, { ignore: '*~' }, (err, files) =&gt; {
  if (err) {
    console.log(err)
  } else {
    for (const srcName of files) {
      fs.stat(srcName, (err, stats) =&gt; {
        if (err) {
          console.error(err)
        } else if (stats.isFile()) {
          const dstName = srcName.replace(srcRoot, dstRoot)
          const dstDir = path.dirname(dstName)
          fs.ensureDir(dstDir, (err) =&gt; {
            if (err) {
              console.error(err)
            } else {
              fs.copy(srcName, dstName, (err) =&gt; {
                if (err) {
                  console.error(err)
                }
              })
            }
          })
        }
      })
    }
  }
})
</code></pre>
<ul>
<li>This works…</li>
<li>…but four levels of asynchronous callbacks is hard to understand</li>
<li>We need a better mechanism</li>
</ul>
<h2 id="exercises">Exercises</h2>
<h3 class="exercise">Where is Node?</h3>
<p>Write a program called <code>wherenode.js</code> that prints the full path to the version of Node is is run with.</p>
<h3 class="exercise">Tracing callbacks</h3>
<p>In what order does the program below print messages?</p>
<pre title="trace-callback/trace.js"><code class="language-js">const red = () =&gt; {
  console.log('RED')
}

const green = (func) =&gt; {
  console.log('GREEN')
  func()
}

const blue = (left, right) =&gt; {
  console.log('BLUE')
  left(right)
}

blue(green, red)
</code></pre>
<h3 class="exercise">Tracing anonymous callbacks</h3>
<p>In what order does the program below print messages?</p>
<pre title="trace-anonymous/trace.js"><code class="language-js">const blue = (left, right) =&gt; {
  console.log('BLUE')
  left(right)
}

blue(
  (callback) =&gt; {
    console.log('GREEN')
    callback()
  },
  () =&gt; console.log('RED')
)
</code></pre>
<h3 class="exercise">Significant entries</h3>
<p><code>count-lines-histogram.js</code> displays many zeroes and gives no visual sense of how large entries are.
Modify it so that:</p>
<ol>
<li>
<p>When it is run with the <code>--nonzero</code> flag only non-zero values are shown.</p>
</li>
<li>
<p>When it is run with the <code>--graphical</code> flag the numeric values are replaced with rows of asterisks.</p>
</li>
<li>
<p>If both flags are given the program prints an error message instead of running.</p>
</li>
</ol>
<h3 class="exercise">Glob patterns</h3>
<p>What filenames does each of the following glob patterns match?</p>
<ul>
<li><code>results-[0123456789].csv</code></li>
<li><code>results.(tsv|csv)</code></li>
<li><code>results.dat?</code></li>
<li><code>./results.data</code></li>
</ul>
<h3 class="exercise">Filtering arrays</h3>
<p>Fill in the blank in the code below so that it runs correctly.
Note: you can compare strings in JavaScript using <code>&lt;</code>, <code>&gt;=</code>, and other operators,
so that (for example) <code>person.personal &gt; 'P'</code> is <code>true</code>
if someone's personal name starts with a letter that comes after 'P' in the alphabet.</p>
<pre title="array-filter/filter.js"><code class="language-js">const people = [
  { personal: 'Jean', family: 'Jennings' },
  { personal: 'Marlyn', family: 'Wescoff' },
  { personal: 'Ruth', family: 'Lichterman' },
  { personal: 'Betty', family: 'Snyder' },
  { personal: 'Frances', family: 'Bilas' },
  { personal: 'Kay', family: 'McNulty' }
]

const result = people.filter(____ =&gt; ____)

console.log(result)
</code></pre>
<pre title="array-filter/filter.txt"><code class="language-txt">[
  { personal: 'Jean', family: 'Jennings' },
  { personal: 'Ruth', family: 'Lichterman' },
  { personal: 'Frances', family: 'Bilas' }
]
</code></pre>
<h3 class="exercise">String interpolation</h3>
<p>Fill in the code below so that it prints the message shown.</p>
<pre title="string-interpolation/interpolate.js"><code class="language-js">const people = [
  { personal: 'Christine', family: 'Darden' },
  { personal: 'Mary', family: 'Jackson' },
  { personal: 'Katherine', family: 'Johnson' },
  { personal: 'Dorothy', family: 'Vaughan' }
]

for (const person of people) {
  console.log(`$____, $____`)
}
</code></pre>
<pre title="string-interpolation/interpolate.txt"><code class="language-txt">Darden, Christine
Jackson, Mary
Johnson, Katherine
Vaughan, Dorothy
</code></pre>
<h3 class="exercise">Destructuring assignment</h3>
<p>What is assigned to each named variable in each statement below?</p>
<ul>
<li><code>const first = [10, 20, 30]</code></li>
<li><code>const [first, second] = [10, 20, 30]</code></li>
<li><code>const [first, second, third] = [10, 20, 30]</code></li>
<li><code>const [first, second, third, fourth] = [10, 20, 30]</code></li>
<li><code>const {left, right} = {left: 10, right: 30}</code></li>
<li><code>const {left, middle, right} = {left: 10, middle: 20, right: 30}</code></li>
</ul>
<h3 class="exercise">Counting lines</h3>
<p>Write a program called <code>lc</code> that counts and reports the number of lines in one or more files and the total number of lines,
so that <code>lc a.txt b.txt</code> displays something like:</p>
<pre><code class="language-txt">a.txt 475
b.txt 31
total 506
</code></pre>
<h3 class="exercise">Renaming files</h3>
<p>Write a program called <code>rename</code> that takes three or more command-line arguments:</p>
<ol>
<li>A <g key="filename_extension">filename extension</g> to match.</li>
<li>An extension to replace it with.</li>
<li>The names of one or more existing files.</li>
</ol>
<p>When it runs,
<code>rename</code> renames any files with the first extension to create files with the second extension,
but will <em>not</em> overwrite an existing file.
For example,
suppose a directory contains <code>a.txt</code>, <code>b.txt</code>, and <code>b.bck</code>.
The command:</p>
<pre><code class="language-sh">rename .txt .bck a.txt b.txt
</code></pre>
<p class="noindent">will rename `a.txt` to `a.bck`,
but will *not* rename `b.txt` because `b.bck` already exists.</p>
</main>
<footer>
<div class="row">
<div class="left3">
&nbsp;
</div>
<div class="middle3">
<a href="../license/"><img class="footer" src="../static/cc-by.svg" alt="License" /></a>
<a href="https://github.com/software-tools-in-javascript/stjs/"><img class="footer" src="../static/github.svg" alt="Repository" /></a>
© 2020 <a href="../authors/">The Authors</a>
</div>
<div class="right3">
<a href="../promises/"><em>Promises &raquo;</em></a>
</div>
</div>
</footer>
</body>
</html>
