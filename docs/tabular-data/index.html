<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
  <title>Tabular Data</title>
  <meta name="relativeRoot" content="..">
  <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
  <link href="../static/site.css" rel="stylesheet" type="text/css">
  <script src="../static/site.js"></script>
  <script>window.onload = () => fixPage()</script>
</head>
<body id="_top">
<nav>
<div class="row">
<div class="left2">
<a href="http://third-bit.com"><img src="../static/logo.svg" alt="site logo" class="site-logo"/></a>
<a href="../"><em>Software Tools in JavaScript</em></a>
</div>
<div class="right2">
<div class="dropdown">
<span class="navtitle">▿ Sections</span>
<div class="dropdown-content" id="Sections">
</div>
</div>
<div class="dropdown">
<span class="navtitle">▿ Chapters</span>
<div class="dropdown-content" id="Chapters">
<a href="../systems-programming/"><span class="nowrap">Systems Programming</span></a>
<br/><a href="../promises/"><span class="nowrap">Promises</span></a>
<br/><a href="../unit-test/"><span class="nowrap">Unit Testing</span></a>
<br/><a href="../file-backup/"><span class="nowrap">File Backup</span></a>
<br/><a href="../style-checker/"><span class="nowrap">Style Checker</span></a>
<br/><a href="../code-generator/"><span class="nowrap">Code Generator</span></a>
<br/><a href="../page-templates/"><span class="nowrap">Page Templates</span></a>
<br/><a href="../module-loader/"><span class="nowrap">Module Loader</span></a>
<br/><a href="../module-bundler/"><span class="nowrap">Module Bundler</span></a>
<br/><a href="../layout-engine/"><span class="nowrap">Layout Engine</span></a>
<br/><a href="../text-editor/"><span class="nowrap">Text Editor</span></a>
<br/><a href="../doc-generator/"><span class="nowrap">Documentation Generator</span></a>
<br/><a href="../http-server/"><span class="nowrap">HTTP Server</span></a>
<br/><a href="../tabular-data/"><span class="nowrap">Tabular Data</span></a>
<br/><a href="../build-manager/"><span class="nowrap">Build Manager</span></a>
<br/><a href="../package-manager/"><span class="nowrap">Package Manager</span></a>
<br/><a href="../conclusion/"><span class="nowrap">Conclusion</span></a>
</div>
</div>
<div class="dropdown">
<span class="navtitle">▿ Appendices</span>
<div class="dropdown-content" id="Appendices">
<a href="../license/"><span class="nowrap">License</span></a>
<br/><a href="../conduct/"><span class="nowrap">Code of Conduct</span></a>
<br/><a href="../contributing/"><span class="nowrap">Contributing</span></a>
<br/><a href="../bib/"><span class="nowrap">Bibliography</span></a>
<br/><a href="../gloss/"><span class="nowrap">Glossary</span></a>
<br/><a href="../links/"><span class="nowrap">Links</span></a>
<br/><a href="../solutions/"><span class="nowrap">Solutions</span></a>
<br/><a href="../authors/"><span class="nowrap">Authors</span></a>
</div>
</div>
</div>
</div>
</nav>
  <main>
  <h1>Tabular Data</h1>
  <p class="lede">Storing data in tables</p>
<ul>
<li>Storing data in tables inspired by the <a href="https://www.tidyverse.org/">tidyverse</a> and <a href="http://www.data-forge-js.com/">DataForge</a>.</li>
<li>Outline</li>
</ul>
<pre title="dataframe.js"><code class="language-js">const assert = require('assert')

class DataFrame {
  /*+ Construct a new dataframe + constructor.js +*/
  /*+ Check for equality + equal.js +*/
  /*+ Drop and select + dropselect.js +*/
  /*+ Filter + filter.js +*/
  /*+ Mutate + mutate.js +*/
  /*+ Sort + sort.js +*/
  /*+ Find unique values + unique.js +*/
  /*+ Grouping + group.js +*/
  /*+ Make groupID + makegroupid.js +*/
  /*+ Summarizing + summarize.js +*/
  /*+ Summarizers + summarizefuncs.js +*/
  /*+ Join + join.js +*/
  /*+ Join helpers + joinhelpers.js +*/
  /*+ Utilities + utilities.js +*/
}

/*+ Static variables + static.js +*/

DataFrame
</code></pre>
<h2 id="what-basic-operations-do-we-need">What basic operations do we need?</h2>
<ul>
<li>Constructor</li>
</ul>
<pre title="constructor.js"><code class="language-js">  constructor (values, oldColumns = null) {
    this._checkData(values)
    this.data = values
    this.columns = this._makeColumns(values, oldColumns)
  }

  _checkData (values) {
    assert(Array.isArray(values),
           `Values used to construct dataframe must be an array, not ${typeof values}`)
    if (values.length === 0) {
      return
    }
    const expected = new Set(Object.keys(values[0]))
    expected.forEach(name =&gt; {
      assert(name.match(DataFrame.COLUMN_NAME) || DataFrame.SPECIAL_NAMES.has(name),
             `Column name "${name}" not allowed`)
    })
    values.forEach((row, index) =&gt; {
      const keys = Object.keys(row)
      assert(keys.length === expected.size,
             `Row ${index} has wrong number of columns`)
      assert(keys.every(k =&gt; expected.has(k)),
             `Row ${index} has wrong column name(s)`)
    })
  }
</code></pre>
<ul>
<li>Equality check</li>
</ul>
<pre title="equal.js"><code class="language-js">  equal (other) {
    assert(other instanceof DataFrame,
           `Can only compare dataframes with dataframes`)

    const cols = Array.from(this.columns.keys())

    if (this.columns.size !== other.columns.size) {
      return false
    }
    if (!cols.every(column =&gt; other.columns.has(column))) {
      return false
    }

    if (this.data.length !== other.data.length) {
      return false
    }
    if (this.data.length === 0) {
      return true
    }

    const compare = (left, right) =&gt; {
      for (const k of cols) {
        if (left[k] &lt; right[k]) {
          return -1
        }
        if (left[k] &gt; right[k]) {
          return 1
        }
      }
      return 0
    }
    const thisRows = this.data.slice().sort(compare)
    const otherRows = other.data.slice().sort(compare)
    return thisRows.every((row, i) =&gt; cols.every(k =&gt; (thisRows[i][k] === otherRows[i][k])))
  }
</code></pre>
<h2 id="how-can-we-choose-what-data-to-work-with">How can we choose what data to work with?</h2>
<ul>
<li>Drop and select</li>
</ul>
<pre title="dropselect.js"><code class="language-js">  drop (columns) {
    assert(this.hasColumns(columns),
           `unknown column(s) [${columns}] in drop`)
    const keep = Array.from(this.columns).filter(c =&gt; (!columns.includes(c)))
    return this.select(keep)
  }

  select (columns) {
    assert(this.hasColumns(columns),
           `unknown column(s) [${columns}] in select`)
    // Dropping all columns.
    if (columns.length === 0) {
      return new DataFrame([])
    }
    // Keeping some columns.
    const newData = this.data.map((row, i) =&gt; {
      const result = {}
      columns.forEach(key =&gt; {
        result[key] = row[key]
      })
      return result
    })
    return new DataFrame(newData, columns)
  }
</code></pre>
<ul>
<li>Filter rows</li>
</ul>
<pre title="filter.js"><code class="language-js">  filter (expr) {
    assert(typeof expr === 'function',
           `filter expression is not a function`)
    const newData = this.data.filter((row, i) =&gt; expr(row, i))
    const newColumns = this._makeColumns(newData, this.columns)
    return new DataFrame(newData, newColumns)
  }
</code></pre>
<h2 id="how-can-we-create-new-values">How can we create new values?</h2>
<ul>
<li>Mutate (add new columns)</li>
</ul>
<pre title="mutate.js"><code class="language-js">  mutate (newName, expr) {
    assert(newName,
           `empty new column name for mutate`)
    assert(newName.match(DataFrame.COLUMN_NAME),
           `illegal new name for column`)
    assert(typeof expr === 'function',
           `new value expression is not a function`)
    const newData = this.data.map((row, i) =&gt; {
      const newRow = {...row}
      newRow[newName] = expr(row, i)
      return newRow
    })
    const newColumns = this._makeColumns(newData, this.columns, {add: [newName]})
    return new DataFrame(newData, newColumns)
  }
</code></pre>
<h2 id="how-can-we-arrange-values">How can we arrange values?</h2>
<ul>
<li>Sort</li>
</ul>
<pre title="sort.js"><code class="language-js">  sort (columns, reverse = false) {
    assert(columns.length &gt; 0,
           `no columns specified for sort`)
    assert(this.hasColumns(columns),
           `unknown column(s) [${columns}] in sort`)
    const result = [...this.data]
    result.sort((left, right) =&gt; {
      return columns.reduce((soFar, col) =&gt; {
        if (soFar !== 0) {
          return soFar
        }
        if (left[col] === DataFrame.MISSING) {
          return -1
        }
        if (right[col] === DataFrame.MISSING) {
          return 1
        }
        if (left[col] &lt; right[col]) {
          return -1
        }
        if (left[col] &gt; right[col]) {
          return 1
        }
        return 0
      }, 0)
    })
    if (reverse) {
      result.reverse()
    }
    return new DataFrame(result, this.columns)
  }
</code></pre>
<h2 id="how-can-we-remove-duplicates">How can we remove duplicates?</h2>
<ul>
<li>Find unique values</li>
</ul>
<pre title="unique.js"><code class="language-js">  unique (columns) {
    assert(columns.length &gt; 0,
           `no columns specified for select`)
    assert(this.hasColumns(columns),
           `unknown column(s) [${columns}] in select`)
    const seen = new Map()
    const newData = []
    this.data.forEach((row, i) =&gt; this._findUnique(seen, newData, row, i, columns))
    return new DataFrame(newData, columns)
  }

  _findUnique (seen, newData, row, i, columns) {
    const thisValue = row[columns[0]]
    const otherColumns = columns.slice(1)
    if (otherColumns.length === 0) {
      if (!seen.has(thisValue)) {
        seen.set(thisValue, true)
        newData.push(row)
      }
    }
    else {
      if (!seen.has(thisValue)) {
        seen.set(thisValue, new Map())
      }
      this._findUnique(seen.get(thisValue), newData, row, i, otherColumns)
    }
  }
</code></pre>
<h2 id="how-can-we-calculate-summaries">How can we calculate summaries?</h2>
<ul>
<li>Grouping and ungrouping</li>
</ul>
<pre title="group.js"><code class="language-js">  groupBy (columns) {
    assert(columns.length &gt; 0,
           `empty column name(s) for grouping`)
    assert(this.hasColumns(columns),
           `unknown column(s) ${columns} in groupBy`)
    assert(columns.length === (new Set(columns)).size,
           `duplicate column(s) in [${columns}] in groupBy`)
    const seen = new Map()
    let nextGroupId = 1
    const groupedData = this.data.map((row, i) =&gt; {
      const thisGroupId = this._makeGroupId(seen, row, i, columns, nextGroupId)
      if (thisGroupId === nextGroupId) {
        nextGroupId += 1
      }
      const newRow = {...row}
      newRow[DataFrame.GROUPCOL] = thisGroupId
      return newRow
    })
    const newColumns = this._makeColumns(groupedData, this.columns,
                                         {add: [DataFrame.GROUPCOL]})
    return new DataFrame(groupedData, newColumns)
  }

  ungroup () {
    assert(this.hasColumns([DataFrame.GROUPCOL]),
           `cannot ungroup data that is not grouped`)
    const newData = this.data.map(row =&gt; {
      row = {...row}
      delete row[DataFrame.GROUPCOL]
      return row
    })
    const newColumns = this._makeColumns(newData, this.columns,
                                         {remove: [DataFrame.GROUPCOL]})
    return new DataFrame(newData, newColumns)
  }
</code></pre>
<ul>
<li>Make a group ID</li>
</ul>
<pre title="makegroupid.js"><code class="language-js">  _makeGroupId (seen, row, i, columns, nextGroupId) {
    const thisValue = row[columns[0]]
    const otherColumns = columns.slice(1)
    if (seen.has(thisValue)) {
      if (otherColumns.length === 0) {
        return seen.get(thisValue)
      }
      else {
        const subMap = seen.get(thisValue)
        return this._makeGroupId(subMap, row, i, otherColumns, nextGroupId)
      }
    }
    else {
      if (otherColumns.length === 0) {
        seen.set(thisValue, nextGroupId)
        return nextGroupId
      }
      else {
        const subMap = new Map()
        seen.set(thisValue, subMap)
        return this._makeGroupId(subMap, row, i, otherColumns, nextGroupId)
      }
    }
  }
</code></pre>
<ul>
<li>Summarization</li>
</ul>
<pre title="summarize.js"><code class="language-js">  summarize (op, column) {
    assert(typeof op === 'function',
           `Require summarization functions`)
    assert(this.hasColumns([column]),
           `unknown column in summarize`)
    const newData = this.data.map(row =&gt; { return {...row} })
    const newCol = `${column}_${op.colName}`
    this._summarizeColumn(newData, op, column, newCol)
    return new DataFrame(newData, [newCol])
  }

  _summarizeColumn (data, op, oldCol, newCol) {
    // Divide values into groups.
    const groups = new Map()
    data.forEach(row =&gt; {
      const groupId = (DataFrame.GROUPCOL in row) ? row[DataFrame.GROUPCOL] : null
      if (!groups.has(groupId)) {
        groups.set(groupId, [])
      }
      groups.get(groupId).push(row)
    })

    // Summarize each group.
    for (let groupId of groups.keys()) {
      const result = op(oldCol, groups.get(groupId))
      groups.set(groupId, result)
    }

    // Paste back in each row.
    data.forEach(row =&gt; {
      const groupId = (DataFrame.GROUPCOL in row) ? row[DataFrame.GROUPCOL] : null
      row[newCol] = groups.get(groupId)
    })
  }
</code></pre>
<ul>
<li>Standard summarization functions</li>
</ul>
<pre title="summarizefuncs.js"><code class="language-js">  static Count (column, rows) {
    return rows.length
  }

  static Maximum (column, rows) {
    if (rows.length === 0) {
      return DataFrame.MISSING
    }
    return rows.reduce((soFar, row) =&gt; {
      return (row[column] &gt; soFar) ? row[column] : soFar
    }, rows[0][column])
  }

  static Mean (column, rows) {
    if (rows.length === 0) {
      return DataFrame.MISSING
    }
    return rows.reduce((total, row) =&gt; {
      return total + row[column]
    }, 0) / rows.length
  }

  static Median (column, rows) {
    if (rows.length === 0) {
      return DataFrame.MISSING
    }
    const temp = [...rows]
    temp.sort((left, right) =&gt; {
      if (left[column] &lt; right[column]) {
        return -1
      }
      else if (left[column] &gt; right[column]) {
        return 1
      }
      return 0
    })
    return temp[Math.floor(rows.length / 2)][column]
  }

  static Minimum (column, rows) {
    if (rows.length === 0) {
      return DataFrame.MISSING
    }
    return rows.reduce((soFar, row) =&gt; {
      return (row[column] &lt; soFar) ? row[column] : soFar
    }, rows[0][column])
  }

  static StdDev (column, rows) {
    if (rows.length === 0) {
      return DataFrame.MISSING
    }
    return Math.sqrt(DataFrame.Variance(column, rows))
  }

  static Sum (column, rows) {
    if (rows.length === 0) {
      return DataFrame.MISSING
    }
    return rows.reduce((total, row) =&gt; {
      return total + row[column]
    }, 0)
  }

  static Variance (column, rows) {
    if (rows.length === 0) {
      return DataFrame.MISSING
    }
    const mean = rows.reduce((total, row) =&gt; total + row[column], 0) / rows.length
    const diffSq = rows.map(row =&gt; (row[column] - mean) ** 2)
    const result = diffSq.reduce((total, val) =&gt; total + val, 0) / diffSq.length
    return result
  }
</code></pre>
<h2 id="how-can-we-combine-datasets">How can we combine datasets?</h2>
<ul>
<li>Join with another dataframe</li>
</ul>
<pre title="join.js"><code class="language-js">  join (thisName, thisCol, other, otherName, otherCol) {
    assert(thisName.match(DataFrame.TABLE_NAME),
           `cannot use ${thisName} as table name`)
    assert(this.hasColumns([thisCol]),
           `this does not have column ${thisCol}`)
    assert(other instanceof DataFrame,
           `other table must be a dataframe`)
    assert(otherName.match(DataFrame.TABLE_NAME),
           `cannot use ${otherName} as table name`)
    assert(other.hasColumns([otherCol]),
           `other table does not have column ${otherCol}`)

    const result = []
    for (let thisRow of this.data) { 
      for (let otherRow of other.data) { 
        if (thisRow[thisCol] === otherRow[otherCol]) {
          const row = {}
          row[DataFrame.JOINCOL] = thisRow[thisCol]
          this._addFieldsExcept(row, thisRow, thisName, thisCol)
          this._addFieldsExcept(row, otherRow, otherName, otherCol)
          result.push(row)
        }
      }
    }

    const newColumns = [DataFrame.JOINCOL]
    this._addColumnsExcept(newColumns, thisName, this.columns, thisCol)
    this._addColumnsExcept(newColumns, otherName, other.columns, otherCol)

    return new DataFrame(result, newColumns)
  }
</code></pre>
<ul>
<li>Join helpers</li>
</ul>
<pre title="joinhelpers.js"><code class="language-js">  _addFieldsExcept (result, row, tableName, exceptName) {
    Object.keys(row)
      .filter(key =&gt; (key !== exceptName))
      .forEach(key =&gt; { result[`${tableName}_${key}`] = row[key] })
  }

  _addColumnsExcept (result, tableName, columns, exceptName) {
    Array.from(columns)
      .filter(col =&gt; (col !== exceptName))
      .forEach(col =&gt; result.push(`${tableName}_${col}`))
    return result
  }
</code></pre>
<h2 id="whats-left-over">What's left over?</h2>
<ul>
<li>Utilities</li>
</ul>
<pre title="utilities.js"><code class="language-js">  // Test whether the dataframe has the specified columns.
  hasColumns (names) {
    assert(Array.isArray(names),
           `require array of names`)
    return (names.length &lt;= this.columns.size)
      &amp;&amp; names.every(n =&gt; (this.columns.has(n)))
  }

  // Create columns for new table from data, existing columns, and explict add/remove lists.
  _makeColumns (data, oldColumns, extras = {}) {
    const result = new Set()

    // Trust the data if there is some.
    if (data.length &gt; 0) {
      Object.keys(data[0]).forEach(key =&gt; result.add(key))
    }

    // Construct.
    else {
      if (oldColumns) {
        oldColumns.forEach(name =&gt; result.add(name))
      }
      if ('add' in extras) {
        extras.add.forEach(name =&gt; result.add(name))
      }
    }

    return result
  }
</code></pre>
</main>
<footer>
<div class="row">
<div class="left3">
<a href="../http-server/"><em>&laquo; HTTP Server</em></a>
</div>
<div class="middle3">
<a href="../license/"><img class="footer" src="../static/cc-by.svg" alt="License" /></a>
<a href="https://github.com/gvwilson/e/"><img class="footer" src="../static/github.svg" alt="Repository" /></a>
© 2020 <a href="../authors/">The Authors</a>
</div>
<div class="right3">
<a href="../build-manager/"><em>Build Manager &raquo;</em></a>
</div>
</div>
</footer>
</body>
</html>
