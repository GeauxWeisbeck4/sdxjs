<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
  <title>Text Editor</title>
  <meta name="toRoot" content="..">
  <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
  <link href="../static/site.css" rel="stylesheet" type="text/css">
  <script src="../static/site.js"></script>
  <script>window.onload = () => fixPage()</script>
</head>
<body id="_top">
<nav>
<div class="row">
<div class="left2">
<a href="http://third-bit.com"><img src="../static/logo.svg" alt="site logo" class="site-logo"/></a>
<a href="../"><em>Software Tools in JavaScript</em></a>
</div>
<div class="right2">
<div class="dropdown">
<span class="navtitle">▿ Sections</span>
<div class="dropdown-content" id="Sections">
</div>
</div>
<div class="dropdown">
<span class="navtitle">▿ Chapters</span>
<div class="dropdown-content" id="Chapters">
<a href="../systems-programming/"><span class="nowrap">Systems Programming</span></a>
<br/><a href="../promises/"><span class="nowrap">Promises</span></a>
<br/><a href="../unit-test/"><span class="nowrap">Unit Testing</span></a>
<br/><a href="../file-backup/"><span class="nowrap">File Backup</span></a>
<br/><a href="../style-checker/"><span class="nowrap">Style Checker</span></a>
<br/><a href="../pattern-matching/"><span class="nowrap">Pattern Matching</span></a>
<br/><a href="../regex-parser/"><span class="nowrap">Parsing Expressions</span></a>
<br/><a href="../code-generator/"><span class="nowrap">Code Generator</span></a>
<br/><a href="../page-templates/"><span class="nowrap">Page Templates</span></a>
<br/><a href="../doc-generator/"><span class="nowrap">Documentation Generator</span></a>
<br/><a href="../file-interpolator/"><span class="nowrap">File Interpolator</span></a>
<br/><a href="../module-loader/"><span class="nowrap">Module Loader</span></a>
<br/><a href="../module-bundler/"><span class="nowrap">Module Bundler</span></a>
<br/><a href="../build-manager/"><span class="nowrap">Build Manager</span></a>
<br/><a href="../layout-engine/"><span class="nowrap">Layout Engine</span></a>
<br/><a href="../text-editor/"><span class="nowrap">Text Editor</span></a>
<br/><a href="../http-server/"><span class="nowrap">HTTP Server</span></a>
<br/><a href="../package-manager/"><span class="nowrap">Package Manager</span></a>
<br/><a href="../issue-tracker/"><span class="nowrap">Issue Tracker</span></a>
<br/><a href="../conclusion/"><span class="nowrap">Conclusion</span></a>
</div>
</div>
<div class="dropdown">
<span class="navtitle">▿ Appendices</span>
<div class="dropdown-content" id="Appendices">
<a href="../bib/"><span class="nowrap">Bibliography</span></a>
<br/><a href="../license/"><span class="nowrap">License</span></a>
<br/><a href="../conduct/"><span class="nowrap">Code of Conduct</span></a>
<br/><a href="../contributing/"><span class="nowrap">Contributing</span></a>
<br/><a href="../gloss/"><span class="nowrap">Glossary</span></a>
<br/><a href="../links/"><span class="nowrap">Links</span></a>
<br/><a href="../solutions/"><span class="nowrap">Solutions</span></a>
<br/><a href="../authors/"><span class="nowrap">Authors</span></a>
</div>
</div>
</div>
</div>
</nav>
  <main>
  <h1>Text Editor</h1>
  <p class="lede">A terminal text editor</p>
<ul>
<li>A terminal editor based on <a href="https://github.com/hakash/termit">Termit</a> using <a href="https://github.com/cronvel/terminal-kit">terminal-kit</a></li>
<li>We are going to refactor an existing editor rather than writing something from scratch
<ul>
<li>Means that we'll see the entire status bar right from the start</li>
<li>And will gloss over some technical details, since this isn't a lesson on terminal management</li>
</ul>
</li>
<li>But will see:
<ul>
<li>How to build a <g key="plugin_architecture">plugin architecture</g></li>
<li>How to implement undo and redo</li>
</ul>
</li>
</ul>
<h2 id="what-does-a-minimal-text-editor-contain">What does a minimal text editor contain?</h2>
<ul>
<li>Outline</li>
</ul>
<pre title="minimal-editor.js:body"><code class="language-js">const terminalKit = require('terminal-kit')

const SETTINGS = {
  statusBar: 'Ctrl+  X:save &amp; eXit / C:exit / O:Open / S:Save / A:save As / K:cut line / U:paste line',
  titleBar: 'Zepto',
  shortDelay: 100,
  mediumDelay: 2000,
  longDelay: 3500
}

class MinimalEditor {
...
}

module.exports = MinimalEditor
</code></pre>
<ul>
<li>Constructor</li>
</ul>
<pre title="minimal-editor.js:constructor"><code class="language-js">  constructor (args) {
    this.settings = { ...SETTINGS }
    this.term = terminalKit.terminal
    this.statusBarTimer = undefined

    this.screenBuffer = new terminalKit.ScreenBuffer({
      dst: this.term,
      height: this.term.height - 2,
      y: 2
    })

    this.textBuffer = new terminalKit.TextBuffer({ dst: this.screenBuffer })
    this.textBuffer.setText('')

    this.term.on('resize', this.onResize.bind(this))
    this.term.on('key', this.onKey.bind(this))

    this.term.fullscreen(true)

    this.textBuffer.moveTo(0, 0)
    this.screenBuffer.moveTo(0, 0)

    this.term.grabInput({ mouse: false })
    this.drawStatusBar()
    this.drawTitleBar()

    this.draw()
  }</code></pre>
<ul>
<li>And when we have to resize</li>
</ul>
<pre title="minimal-editor.js:resize"><code class="language-js">  onResize (width, height) {
    if (this.resizeTimer) {
      clearTimeout(this.resizeTimer)
    }
    this.resizeTimer = setTimeout(() =&gt; {
      this.screenBuffer.resize({
        x: 0,
        y: 2,
        width: width,
        height: height - 2
      })
      this.drawStatusBar()
      this.drawTitleBar()
      this.draw()
    }, this.settings.shortDelay)
  }</code></pre>
<ul>
<li>Drawing the title and status bar</li>
</ul>
<pre title="minimal-editor.js:drawbar"><code class="language-js">  drawBar (pos, message, invert = false) {
    if (invert) {
      this.term.moveTo(pos.x, pos.y)
        .styleReset.white.bold.eraseLine(' ' + message)
    } else {
      this.term.moveTo(pos.x, pos.y)
        .styleReset.bgWhite.black.bold.eraseLine(' ' + message)
    }
  }

  drawStatusBar (message = this.settings.statusBar, timeout = -1) {
    this.drawBar({ x: 0, y: this.term.height }, message)

    this.textBuffer.draw()
    this.screenBuffer.draw({ delta: true })
    this.textBuffer.drawCursor()
    this.screenBuffer.drawCursor()

    if (this.statusBarTimer) {
      clearTimeout(this.statusBarTimer)
    }

    if (timeout &gt;= 0) {
      this.statusBarTimer = setTimeout(() =&gt; this.drawStatusBar(), timeout)
    }
  }

  drawTitleBar () {
    this.drawBar({ x: 1, y: 1 }, this.settings.titleBar)
  }</code></pre>
<ul>
<li>Drawing in general</li>
</ul>
<pre title="minimal-editor.js:draw"><code class="language-js">  draw () {
    this.textBuffer.draw()
    this.screenBuffer.draw({ delta: true })
    this.drawCursor()
  }

  drawCursor () {
    let newBufferX = this.textBuffer.x
    let newBufferY = this.textBuffer.y

    if (this.textBuffer.x &lt; -this.textBuffer.cx) {
      newBufferX = Math.min(0, -this.textBuffer.cx + Math.floor(this.screenBuffer.width / 2))
    } else if (this.textBuffer.x &gt; -this.textBuffer.cx + this.screenBuffer.width - 1) {
      newBufferX = (this.screenBuffer.width / 2) - this.textBuffer.cx
    }

    if (this.textBuffer.y &lt; -this.textBuffer.cy) {
      newBufferY = Math.min(0, -this.textBuffer.cy + Math.floor(this.screenBuffer.height / 2))
    } else if (this.textBuffer.y &gt; -this.textBuffer.cy + this.screenBuffer.height - 1) {
      newBufferY = (this.screenBuffer.height / 2) - this.textBuffer.cy
    }

    if (newBufferY !== this.textBuffer.y || newBufferX !== this.textBuffer.x) {
      this.textBuffer.x = newBufferX
      this.textBuffer.y = newBufferY
      this.textBuffer.draw()
      this.screenBuffer.draw({ delta: true })
    }

    this.textBuffer.drawCursor()
    this.screenBuffer.drawCursor()
  }</code></pre>
<ul>
<li>Handling keys</li>
</ul>
<pre title="minimal-editor.js:onkey"><code class="language-js">  onKey (key, matches, data) {
    switch (key) {
      case 'CTRL_C':
        this.exit()
        break
      case 'ENTER':
        this.newLine()
        break
      default:
        if (data.isCharacter) {
          this.textBuffer.insert(key)
          this.draw()
        }
        break
    }
  }</code></pre>
<ul>
<li>Handling newlines is special</li>
</ul>
<pre title="minimal-editor.js:newline"><code class="language-js">  newLine () {
    this.textBuffer.newLine()
    this.draw()
  }</code></pre>
<ul>
<li>And when the time comes to exit</li>
</ul>
<pre title="minimal-editor.js:exit"><code class="language-js">  exit () {
    setTimeout(() =&gt; {
      this.term.grabInput(false)
      this.term.fullscreen(false)
      setTimeout(() =&gt; process.exit(0), this.settings.shortDelay)
    }, this.settings.shortDelay)
  }</code></pre>
<h2 id="how-can-we-make-the-editor-extensible">How can we make the editor extensible?</h2>
<ul>
<li>Even a minimalist editor like <a href="https://www.nano-editor.org/">Nano</a> has many special keys</li>
<li>Programmers often want to add more or change the <g key="key_binding">bindings</g> of existing keys</li>
<li>Best solution is a <g key="plugin_architecture">plugin architecture</g>
<ul>
<li>The editor provides a few core operations</li>
<li>Loads tiny libraries that connect keys to those operations</li>
</ul>
</li>
<li>Refactor the editor
<ul>
<li><code>onKey</code> looks up the action associated with a key and runs it</li>
<li>Gives that action the key and the editor itself to work with</li>
<li>Constructor adds two bindings to the lookup table</li>
</ul>
</li>
</ul>
<pre title="bindings-editor.js:bindings"><code class="language-js">const MinimalEditor = require('./minimal-editor')
...
class BindingsEditor extends MinimalEditor {
  constructor (args) {
    super(args)
    this.bindings = new Map()
    this.bindings.set(ENTER_BINDING.key, ENTER_BINDING)
    this.bindings.set(EXIT_BINDING.key, EXIT_BINDING)
  }

  onKey (key, matches, data) {
    if (this.bindings.has(key)) {
      this.bindings.get(key).run(this, key)
    } else if (data.isCharacter) {
      this.textBuffer.insert(key)
      this.draw()
    }
  }
}

module.exports = BindingsEditor
</code></pre>
<ul>
<li>Each binding is derived from a very simple base class</li>
</ul>
<pre title="key-binding.js"><code class="language-js">class KeyBinding {
  constructor (key) {
    this.key = key
  }

  run (editor, key) {
    throw new Error('key binding classes must implement run method')
  }
}

module.exports = KeyBinding
</code></pre>
<ul>
<li>Define a class and create a single instance for handling the <code>enter</code> key
<ul>
<li>Tell the editor what key this handles</li>
<li>Act on the editor</li>
</ul>
</li>
</ul>
<pre title="bindings-editor.js:enter-binding"><code class="language-js">const KeyBinding = require('./key-binding')

class EnterBinding extends KeyBinding {
  constructor () {
    super('ENTER')
  }

  run (editor, key) {
    editor.newLine()
  }
}

const ENTER_BINDING = new EnterBinding()</code></pre>
<ul>
<li>JavaScript allows us to define a class without a name and create an instance
<ul>
<li>A way to implement the <g key="singleton_pattern">Singleton</g> pattern</li>
<li></li>
</ul>
</li>
</ul>
<pre title="bindings-editor.js:exit-binding"><code class="language-js">const EXIT_BINDING = new class extends KeyBinding {
  constructor () {
    super('CTRL_C')
  }

  run (editor, key) {
    editor.exit()
  }
}()</code></pre>
<ul>
<li>But if we have to edit the source file to change the bindings, that's hardly extensible</li>
<li>Use a configuration file to specify what bindings to load
<ul>
<li>For simplicity's sake, assume they're all in the same directory</li>
<li>Can easily extend to load a system-wide default configuration from some other directory first and then overlay</li>
</ul>
</li>
<li>Modified editor is looking pretty small</li>
</ul>
<pre title="config-editor.js"><code class="language-js">const fs = require('fs')
const yaml = require('js-yaml')

const MinimalEditor = require('./minimal-editor')

class ConfigEditor extends MinimalEditor {
  constructor (args) {
    super(args.slice(1))
    this.bindings = new Map()
    this.loadBindings(args[0])
  }

  loadBindings (filename) {
    const allNames = yaml.safeLoad(fs.readFileSync(filename, 'utf-8'))
    allNames.forEach(name =&gt; {
      const binding = require(`./${name}`)
      this.bindings.set(binding.key, binding)
    })
  }

  onKey (key, matches, data) {
    if (this.bindings.has(key)) {
      this.bindings.get(key).run(this, key)
    } else if (data.isCharacter) {
      this.textBuffer.insert(key)
      this.draw()
    }
  }
}

module.exports = ConfigEditor
</code></pre>
<ul>
<li>Configuration file is just a list of things to <code>require</code></li>
</ul>
<pre title="simple-config.yml"><code class="language-yml">- simple-enter
- simple-exit
</code></pre>
<ul>
<li>And each binding is an immediately-instantiated class with the object assigned directly to <code>module.exports</code></li>
</ul>
<pre title="simple-enter.js"><code class="language-js">const KeyBinding = require('./key-binding')

module.exports = new class extends KeyBinding {
  constructor () {
    super('ENTER')
  }

  run (editor, key) {
    editor.newLine()
  }
}()
</code></pre>
<h2 id="what-goes-in-the-application-and-what-goes-in-plugins">What goes in the application and what goes in plugins?</h2>
<ul>
<li>At one extreme, the application has a rich interface with lots of operations
<ul>
<li>Plugins are almost empty (i.e., not much use)</li>
</ul>
</li>
<li>At the other extreme, the application is a container for shared state
<ul>
<li>Plugins manipulate that state directly</li>
<li>Usually a bad idea, but classes can have friends</li>
</ul>
</li>
<li>Since we are refactoring an existing implementation:
<ul>
<li>Anything that is needed by two or more plugins becomes a method</li>
<li>Otherwise, manipulate state directly</li>
</ul>
</li>
<li>Add plugins for up/down/left/right and update configuration file
<ul>
<li>All similar in principle to this one</li>
</ul>
</li>
</ul>
<pre title="simple-left.js"><code class="language-js">const KeyBinding = require('./key-binding')

module.exports = new class extends KeyBinding {
  constructor () {
    super('LEFT')
  }

  run (editor, key) {
    editor.textBuffer.moveBackward()
    editor.drawCursor()
  }
}
</code></pre>
</main>
<footer>
<div class="row">
<div class="left3">
<a href="../layout-engine/"><em>&laquo; Layout Engine</em></a>
</div>
<div class="middle3">
<a href="../license/"><img class="footer" src="../static/cc-by.svg" alt="License" /></a>
<a href="https://github.com/gvwilson/e/"><img class="footer" src="../static/github.svg" alt="Repository" /></a>
© 2020 <a href="../authors/">The Authors</a>
</div>
<div class="right3">
<a href="../http-server/"><em>HTTP Server &raquo;</em></a>
</div>
</div>
</footer>
</body>
</html>
