<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
  <title>Text Editor</title>
  <meta name="toRoot" content="..">
  <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
  <link href="../static/fonts.css" rel="stylesheet" type="text/css">
  <link href="../static/site.css" rel="stylesheet" type="text/css">
  <script src="../static/site.js"></script>
  <script>window.onload = () => fixPage()</script>
</head>
<body id="_top">
<nav>
<div class="row">
<div class="left2">
<a href="http://third-bit.com"><img src="../static/logo.svg" alt="site logo" class="site-logo"/></a>
<a href="../"><em>Software Tools in JavaScript</em></a>
</div>
<div class="right2">
<div class="dropdown">
<span class="navtitle">▿ Sections</span>
<div class="dropdown-content" id="Sections">
</div>
</div>
<div class="dropdown">
<span class="navtitle">▿ Chapters</span>
<div class="dropdown-content" id="Chapters">
<a href="../systems-programming/"><span class="nowrap">Systems Programming</span></a>
<br/><a href="../promises/"><span class="nowrap">Promises</span></a>
<br/><a href="../unit-test/"><span class="nowrap">Unit Testing</span></a>
<br/><a href="../file-backup/"><span class="nowrap">File Backup</span></a>
<br/><a href="../data-table/"><span class="nowrap">Data Tables</span></a>
<br/><a href="../pattern-matching/"><span class="nowrap">Pattern Matching</span></a>
<br/><a href="../regex-parser/"><span class="nowrap">Parsing Expressions</span></a>
<br/><a href="../page-templates/"><span class="nowrap">Page Templates</span></a>
<br/><a href="../build-manager/"><span class="nowrap">Build Manager</span></a>
<br/><a href="../layout-engine/"><span class="nowrap">Layout Engine</span></a>
<br/><a href="../text-editor/"><span class="nowrap">Text Editor</span></a>
<br/><a href="../file-interpolator/"><span class="nowrap">File Interpolator</span></a>
<br/><a href="../module-loader/"><span class="nowrap">Module Loader</span></a>
<br/><a href="../module-bundler/"><span class="nowrap">Module Bundler</span></a>
<br/><a href="../package-manager/"><span class="nowrap">Package Manager</span></a>
<br/><a href="../style-checker/"><span class="nowrap">Style Checker</span></a>
<br/><a href="../code-generator/"><span class="nowrap">Code Generator</span></a>
<br/><a href="../doc-generator/"><span class="nowrap">Documentation Generator</span></a>
<br/><a href="../virtual-machine/"><span class="nowrap">Virtual Machine</span></a>
<br/><a href="../debugger/"><span class="nowrap">Debugger</span></a>
<br/><a href="../conclusion/"><span class="nowrap">Conclusion</span></a>
</div>
</div>
<div class="dropdown">
<span class="navtitle">▿ Appendices</span>
<div class="dropdown-content" id="Appendices">
<a href="../bib/"><span class="nowrap">Bibliography</span></a>
<br/><a href="../license/"><span class="nowrap">License</span></a>
<br/><a href="../conduct/"><span class="nowrap">Code of Conduct</span></a>
<br/><a href="../contributing/"><span class="nowrap">Contributing</span></a>
<br/><a href="../gloss/"><span class="nowrap">Glossary</span></a>
<br/><a href="../links/"><span class="nowrap">Links</span></a>
<br/><a href="../authors/"><span class="nowrap">Authors</span></a>
</div>
</div>
</div>
</div>
</nav>
  <main>
  <h1>Text Editor</h1>
  <h2 class="lede">A terminal text editor</h2>
<ul>
<li>A terminal editor based on <a href="https://github.com/hakash/termit">Termit</a> using <a href="https://github.com/cronvel/terminal-kit">terminal-kit</a></li>
<li>We are going to refactor an existing editor rather than writing something from scratch
<ul>
<li>Means that we'll see the entire status bar right from the start</li>
<li>And will gloss over some technical details, since this isn't a lesson on terminal management</li>
</ul>
</li>
<li>But will see:
<ul>
<li>How to build a <g key="plugin_architecture">plugin architecture</g></li>
<li>How to implement undo and redo</li>
</ul>
</li>
</ul>
<h2 id="what-does-a-minimal-text-editor-contain">What does a minimal text editor contain?</h2>
<ul>
<li>Outline</li>
</ul>
<pre title="minimal-editor.js"><code class="language-js">import terminalKit from 'terminal-kit.js'

const SETTINGS = {
  statusBar: 'Ctrl+  C:exit',
  titleBar: 'Zepto',
  shortDelay: 100,
  mediumDelay: 2000,
  longDelay: 3500
}

class MinimalEditor {
...
}

export default MinimalEditor
</code></pre>
<ul>
<li>Constructor</li>
</ul>
<pre title="minimal-editor.js"><code class="language-js">  constructor (args) {
    this.settings = { ...SETTINGS }
    this.term = terminalKit.terminal
    this.statusBarTimer = undefined

    this.screenBuffer = new terminalKit.ScreenBuffer({
      dst: this.term,
      height: this.term.height - 2,
      y: 2
    })

    this.textBuffer = new terminalKit.TextBuffer({ dst: this.screenBuffer })
    this.textBuffer.setText('')

    this.term.on('resize', this.onResize.bind(this))
    this.term.on('key', this.onKey.bind(this))

    this.term.fullscreen(true)

    this.textBuffer.moveTo(0, 0)
    this.screenBuffer.moveTo(0, 0)

    this.term.grabInput({ mouse: false })
    this.drawStatusBar()
    this.drawTitleBar()

    this.draw()
  }</code></pre>
<ul>
<li>And when we have to resize</li>
</ul>
<pre title="minimal-editor.js"><code class="language-js">  onResize (width, height) {
    if (this.resizeTimer) {
      clearTimeout(this.resizeTimer)
    }
    this.resizeTimer = setTimeout(() =&gt; {
      this.screenBuffer.resize({
        x: 0,
        y: 2,
        width: width,
        height: height - 2
      })
      this.drawStatusBar()
      this.drawTitleBar()
      this.draw()
    }, this.settings.shortDelay)
  }</code></pre>
<ul>
<li>Drawing the title and status bar</li>
</ul>
<pre title="minimal-editor.js"><code class="language-js">  drawBar (pos, message, invert = false) {
    if (invert) {
      this.term.moveTo(pos.x, pos.y)
        .styleReset.white.bold.eraseLine(' ' + message)
    } else {
      this.term.moveTo(pos.x, pos.y)
        .styleReset.bgWhite.black.bold.eraseLine(' ' + message)
    }
  }

  drawStatusBar (message = this.settings.statusBar, timeout = -1) {
    this.drawBar({ x: 0, y: this.term.height }, message)

    this.textBuffer.draw()
    this.screenBuffer.draw({ delta: true })
    this.textBuffer.drawCursor()
    this.screenBuffer.drawCursor()

    if (this.statusBarTimer) {
      clearTimeout(this.statusBarTimer)
    }

    if (timeout &gt;= 0) {
      this.statusBarTimer = setTimeout(() =&gt; this.drawStatusBar(), timeout)
    }
  }

  drawTitleBar () {
    this.drawBar({ x: 1, y: 1 }, this.settings.titleBar)
  }</code></pre>
<ul>
<li>Drawing in general</li>
</ul>
<pre title="minimal-editor.js"><code class="language-js">  draw () {
    this.textBuffer.draw()
    this.screenBuffer.draw({ delta: true })
    this.drawCursor()
  }

  drawCursor () {
    let newBufferX = this.textBuffer.x
    let newBufferY = this.textBuffer.y

    if (this.textBuffer.x &lt; -this.textBuffer.cx) {
      newBufferX = Math.min(0, -this.textBuffer.cx +
                                Math.floor(this.screenBuffer.width / 2))
    } else if (this.textBuffer.x &gt;
               -this.textBuffer.cx + this.screenBuffer.width - 1) {
      newBufferX = (this.screenBuffer.width / 2) - this.textBuffer.cx
    }

    if (this.textBuffer.y &lt; -this.textBuffer.cy) {
      newBufferY = Math.min(0, -this.textBuffer.cy +
                               Math.floor(this.screenBuffer.height / 2))
    } else if (this.textBuffer.y &gt;
               -this.textBuffer.cy + this.screenBuffer.height - 1) {
      newBufferY = (this.screenBuffer.height / 2) - this.textBuffer.cy
    }

    if (newBufferY !== this.textBuffer.y ||
        newBufferX !== this.textBuffer.x) {
      this.textBuffer.x = newBufferX
      this.textBuffer.y = newBufferY
      this.textBuffer.draw()
      this.screenBuffer.draw({ delta: true })
    }

    this.textBuffer.drawCursor()
    this.screenBuffer.drawCursor()
  }</code></pre>
<ul>
<li>Handling keys</li>
</ul>
<pre title="minimal-editor.js"><code class="language-js">  onKey (key, matches, data) {
    switch (key) {
      case 'CTRL_C':
        this.exit()
        break
      case 'ENTER':
        this.newLine()
        break
      default:
        if (data.isCharacter) {
          this.textBuffer.insert(key)
          this.draw()
        }
        break
    }
  }</code></pre>
<ul>
<li>Handling newlines is special</li>
</ul>
<pre title="minimal-editor.js"><code class="language-js">  newLine () {
    this.textBuffer.newLine()
    this.draw()
  }</code></pre>
<ul>
<li>And when the time comes to exit</li>
</ul>
<pre title="minimal-editor.js"><code class="language-js">  exit () {
    setTimeout(() =&gt; {
      this.term.grabInput(false)
      this.term.fullscreen(false)
      setTimeout(() =&gt; process.exit(0), this.settings.shortDelay)
    }, this.settings.shortDelay)
  }</code></pre>
<h2 id="how-can-we-make-the-editor-extensible">How can we make the editor extensible?</h2>
<ul>
<li>Even a minimalist editor like <a href="https://www.nano-editor.org/">Nano</a> has many special keys</li>
<li>Programmers often want to add more or change the <g key="key_binding">bindings</g> of existing keys</li>
<li>Best solution is a <g key="plugin_architecture">plugin architecture</g>
<ul>
<li>The editor provides a few core operations</li>
<li>Loads tiny libraries that connect keys to those operations</li>
</ul>
</li>
<li>Refactor the editor
<ul>
<li><code>onKey</code> looks up the action associated with a key and runs it</li>
<li>Gives that action the key and the editor itself to work with</li>
<li>Constructor adds two bindings to the lookup table</li>
</ul>
</li>
</ul>
<pre title="bindings-editor.js"><code class="language-js">import MinimalEditor from './minimal-editor.js'
...
class BindingsEditor extends MinimalEditor {
  constructor (args) {
    super(args)
    this.bindings = new Map()
    this.bindings.set(ENTER_BINDING.key, ENTER_BINDING)
    this.bindings.set(EXIT_BINDING.key, EXIT_BINDING)
  }

  onKey (key, matches, data) {
    if (this.bindings.has(key)) {
      this.bindings.get(key).run(this, key)
    } else if (data.isCharacter) {
      this.textBuffer.insert(key)
      this.draw()
    }
  }
}

export default BindingsEditor
</code></pre>
<ul>
<li>Each binding is derived from a very simple base class</li>
</ul>
<pre title="simple-key-binding.js"><code class="language-js">class KeyBinding {
  constructor (key) {
    this.key = key
  }

  run (editor, key) {
    throw new Error('key binding classes must implement run method')
  }
}

module.exports = KeyBinding
</code></pre>
<ul>
<li>Define a class and create a single instance for handling the <code>enter</code> key
<ul>
<li>Tell the editor what key this handles</li>
<li>Act on the editor</li>
</ul>
</li>
</ul>
<pre title="bindings-editor.js"><code class="language-js">import KeyBinding from './simple-key-binding.js'

class EnterBinding extends KeyBinding {
  constructor () {
    super('ENTER')
  }

  run (editor, key) {
    editor.newLine()
  }
}

const ENTER_BINDING = new EnterBinding()</code></pre>
<ul>
<li>JavaScript allows us to define a class without a name and create an instance
<ul>
<li>A way to implement the <g key="singleton_pattern">Singleton</g> pattern</li>
<li></li>
</ul>
</li>
</ul>
<pre title="bindings-editor.js"><code class="language-js">const EXIT_BINDING = new class extends KeyBinding {
  constructor () {
    super('CTRL_C')
  }

  run (editor, key) {
    editor.exit()
  }
}()</code></pre>
<ul>
<li>But if we have to edit the source file to change the bindings, that's hardly extensible</li>
<li>Use a configuration file to specify what bindings to load
<ul>
<li>For simplicity's sake, assume they're all in the same directory</li>
<li>Can easily extend to load a system-wide default configuration from some other directory first and then overlay</li>
</ul>
</li>
<li>Modified editor is looking pretty small</li>
</ul>
<pre title="config-editor.js"><code class="language-js">import fs from 'fs'
import yaml from 'js-yaml'

import MinimalEditor from './minimal-editor.js'

class ConfigEditor extends MinimalEditor {
  constructor (args) {
    super(args.slice(1))
    this.bindings = new Map()
    this.loadBindings(args[0])
  }

  loadBindings (filename) {
    const allNames = yaml.safeLoad(fs.readFileSync(filename, 'utf-8'))
    allNames.forEach(name =&gt; {
      const binding = require(`./${name}`)
      this.bindings.set(binding.key, binding)
    })
  }

  onKey (key, matches, data) {
    if (this.bindings.has(key)) {
      this.bindings.get(key).run(this, key)
    } else if (data.isCharacter) {
      this.textBuffer.insert(key)
      this.draw()
    }
  }
}

export default ConfigEditor
</code></pre>
<ul>
<li>Configuration file is just a list of things to <code>require</code></li>
</ul>
<pre title="simple-config.yml"><code class="language-yml">- simple-enter
- simple-exit
</code></pre>
<ul>
<li>And each binding is an immediately-instantiated class with the object assigned directly to <code>module.exports</code></li>
</ul>
<pre title="simple-enter.js"><code class="language-js">import KeyBinding from './simple-key-binding.js'

module.exports = new class extends KeyBinding {
  constructor () {
    super('ENTER')
  }

  run (editor, key) {
    editor.newLine()
  }
}()
</code></pre>
<h2 id="what-goes-in-the-application-and-what-goes-in-plugins">What goes in the application and what goes in plugins?</h2>
<ul>
<li>At one extreme, the application has a rich interface with lots of operations
<ul>
<li>Plugins are almost empty (i.e., not much use)</li>
</ul>
</li>
<li>At the other extreme, the application is a container for shared state
<ul>
<li>Plugins manipulate that state directly</li>
<li>Usually a bad idea, but classes can have friends</li>
</ul>
</li>
<li>Since we are refactoring an existing implementation:
<ul>
<li>Anything that is needed by two or more plugins becomes a method</li>
<li>Otherwise, manipulate state directly</li>
</ul>
</li>
<li>Add plugins for up/down/left/right and update configuration file
<ul>
<li>All similar in principle to this one</li>
</ul>
</li>
</ul>
<pre title="simple-left.js"><code class="language-js">import KeyBinding from './simple-key-binding.js'

module.exports = new class extends KeyBinding {
  constructor () {
    super('LEFT')
  }

  run (editor, key) {
    editor.textBuffer.moveBackward()
    editor.drawCursor()
  }
}()
</code></pre>
<ul>
<li>But what if a plugin needs some extra state?
<ul>
<li>Or if multiple plugins need to share some extra state?</li>
</ul>
</li>
<li>Could have a multi-plugin that registers handlers for several keys
<ul>
<li>But that just delays the problem</li>
</ul>
</li>
<li>Instead, a plugin can add some state to the editor
<ul>
<li>Add an <code>init</code> method to <code>KeyBinding</code> that does nothing by default but can be overridden</li>
<li>Adds a new member variable by name if the name is not already in use</li>
<li>So it doesn't matter what order plugins load in</li>
<li>But there <em>is</em> the possibility of name collision between two or more plugins</li>
</ul>
</li>
<li>While we're there, add an <code>isDefault</code> property
<ul>
<li>Might as well make handling generic characters a binding as well</li>
<li>Complain if someone has already registered as the default handler</li>
</ul>
</li>
</ul>
<pre title="init-key-binding.js"><code class="language-js">class KeyBinding {
  constructor (key) {
    this.key = key
    this.isDefault = false
  }

  init (editor) {
    // does nothing but can be overridden
  }

  run (editor, key) {
    throw new Error('key binding classes must implement run method')
  }
}

module.exports = KeyBinding
</code></pre>
<ul>
<li>Modify all existing key bindings to derive from this class
<ul>
<li>But do not override <code>init</code>, since they don't need to</li>
</ul>
</li>
<li>And create a handler for all &quot;other&quot; keys
<ul>
<li>Which is why we've been passing <code>key</code> around all this time</li>
</ul>
</li>
<li>First, derive a new editor class from the one that handles configuration files</li>
</ul>
<pre title="init-editor.js"><code class="language-js">import fs from 'fs'
import yaml from 'js-yaml'

import MinimalEditor from './minimal-editor.js'

class InitEditor extends MinimalEditor {
  constructor (args) {
    super(args.slice(1))
    this.defaultBinding = null
    this.bindings = new Map()
    this.loadBindings(args[0])
  }

  loadBindings (filename) {
    const allNames = yaml.safeLoad(fs.readFileSync(filename, 'utf-8'))
    allNames.forEach(name =&gt; {
      const binding = require(`./${name}`)
      binding.init(this)
      if (binding.isDefault) {
        if (this.defaultBinding !== null) {
          throw new Error('can only have one handler for default binding')
        }
        this.defaultBinding = binding
      } else {
        this.bindings.set(binding.key, binding)
      }
    })
  }

  onKey (key, matches, data) {
    if (this.bindings.has(key)) {
      this.bindings.get(key).run(this, key)
    } else if (data.isCharacter) {
      this.defaultBinding.run(this, key)
    }
  }
}

export default InitEditor
</code></pre>
<ul>
<li>And write the plugin that handles generic characters
<ul>
<li>Identifies itself as the default handler</li>
<li>A little dangerous to specify <code>null</code> as the character it handles</li>
<li>But that's probably better than saying, &quot;If the character is <code>null</code>, this must be the default&quot;</li>
</ul>
</li>
</ul>
<pre title="init-character.js"><code class="language-js">import KeyBinding from './init-key-binding.js'

module.exports = new class extends KeyBinding {
  constructor () {
    super(null)
    this.isDefault = true
  }

  run (editor, key) {
    editor.textBuffer.insert(key)
    editor.draw()
  }
}()
</code></pre>
<ul>
<li>We can finally add some state: a &quot;dirty&quot; flag to show if there are unsaved changes
<ul>
<li>Will add extensions in the next section to make use of this</li>
</ul>
</li>
</ul>
<pre title="dirty-character.js"><code class="language-js">import KeyBinding from './init-key-binding.js'

module.exports = new class extends KeyBinding {
  constructor () {
    super(null)
    this.isDefault = true
  }

  init (editor) {
    editor.addState('dirty', false)
  }

  run (editor, key) {
    editor.dirty = true
    editor.textBuffer.insert(key)
    editor.draw()
  }
}()
</code></pre>
<ul>
<li>And since we're allowing plugins to add state, we should provide a method for that</li>
</ul>
<pre title="dirty-editor.js"><code class="language-js">import InitEditor from './init-editor.js'

class DirtyEditor extends InitEditor {
  addState (name, initialValue) {
    if (!(name in this)) {
      this[name] = initialValue
    }
  }
}

export default DirtyEditor
</code></pre>
<ul>
<li>Avoids the problem of <g key="circular_dependency">circular dependency</g> discussed in <xref key="module-bundler"></xref>
by having plugins manipulate the editor without loading it
<ul>
<li>Works because JavaScript looks methods up dynamically</li>
<li>In a stricter language, we would define an <g key="abstract_base_class">abstract base class</g> for the editor
that both the actual editor and the plugins could depend on</li>
</ul>
</li>
</ul>
<h2 id="how-can-we-replay-operations">How can we replay operations?</h2>
<ul>
<li>Many editors allow us to record keystrokes and play them back
<ul>
<li>And to save recorded operations for re-use, but we won't go that far</li>
</ul>
</li>
<li>Can't quite be done with a plugin
<ul>
<li>Have to intercept keystrokes and recorded them for all handlers</li>
</ul>
</li>
<li>Add two pieces of state to the editor
<ul>
<li><code>isRecording</code> tells the editor whether or not to save keystrokes</li>
<li><code>recordedOperations</code> is the most recently saved operations</li>
</ul>
</li>
<li>Modified editor
<ul>
<li>Parent class does the work of handling the keystroke</li>
</ul>
</li>
</ul>
<pre title="replay-editor.js"><code class="language-js">import DirtyEditor from './dirty-editor.js'

class ReplayEditor extends DirtyEditor {
  constructor (args) {
    super(args)
    this.isRecording = false
    this.recordedOperations = null
  }

  onKey (key, matches, data) {
    if (this.isRecording) {
      this.recordedOperations.push([key, matches, data])
    }
    super.onKey(key, matches, data)
  }
}

export default ReplayEditor
</code></pre>
<ul>
<li>Turning recording on and off
<ul>
<li>A toggle: <key>Ctrl-R</key> will turn recording on if it's off and off if it's on</li>
<li>When we turn it on, we need to clear any accumulated history (restarting)</li>
</ul>
</li>
</ul>
<pre title="replay-record.js"><code class="language-js">import KeyBinding from './init-key-binding.js'

module.exports = new class extends KeyBinding {
  constructor () {
    super('CTRL_R')
  }

  run (editor, key) {
    if (editor.isRecording) {
      editor.isRecording = false
    } else {
      editor.isRecording = true
      editor.recordedOperations = []
    }
  }
}()
</code></pre>
<ul>
<li>Playback is a little more complicated</li>
<li>If we are recording then stop
<ul>
<li>And remove the last entry added to the replay list, because it will be this command</li>
</ul>
</li>
<li>Then re-send every saved keystroke in order</li>
</ul>
<pre title="replay-playback.js"><code class="language-js">import KeyBinding from './init-key-binding.js'

module.exports = new class extends KeyBinding {
  constructor () {
    super('CTRL_P')
  }

  run (editor, key) {
    if (editor.isRecording) {
      editor.isRecording = false
      editor.recordedOperations.pop() // to get rid of this command
    }
    if (editor.recordedOperations) {
      editor.recordedOperations.forEach(op =&gt; editor.onKey(...op))
    }
  }
}()
</code></pre>
<h2 id="how-can-we-undo-operations">How can we undo operations?</h2>
<ul>
<li>Add plugin to backspace
<ul>
<li><key>Ctrl-H</key> on some keyboards</li>
</ul>
</li>
</ul>
<pre title="dirty-backspace.js"><code class="language-js">import KeyBinding from './init-key-binding.js'

module.exports = new class extends KeyBinding {
  constructor () {
    super('BACKSPACE')
  }

  init (editor) {
    editor.addState('dirty', false)
  }

  run (editor, key) {
    editor.dirty = true
    editor.textBuffer.backDelete(1)
    editor.draw()
  }
}()
</code></pre>
<ul>
<li>As soon as we can delete things, we are going to want to undelete them
<ul>
<li>But we want to undelete in the right place if we have moved elsewhere</li>
</ul>
</li>
<li>We need to keep a list of recent operations
<ul>
<li><key>Ctrl-U</key> pops the most recent operation and undoes it</li>
<li>Have to undo every operation in order to make sure we get back to the right place</li>
</ul>
</li>
<li>But where do operations actually live?
<ul>
<li>Copying code from &quot;move left&quot; into the <code>backward</code> method of &quot;move right&quot; is a bad idea (duplication)</li>
<li>Have each operation <code>require</code> its opposite and call its opposite's <code>forward</code> method is bad too (circular dependencies)</li>
<li>Move basic operations back into editor</li>
<li>This kind of refactoring is common in the early stages of a design</li>
</ul>
</li>
<li>How to undo a delete?
<ul>
<li>The handler for character deletion must return the character deleted</li>
<li>We need to save that</li>
<li>If an operation (like &quot;undo&quot;) returns <code>null</code>, don't save it on the undo stack</li>
</ul>
</li>
</ul>
<pre title="undo-editor.js"><code class="language-js">import InitEditor from './init-editor.js'

class UndoEditor extends InitEditor {
  constructor (args) {
    super(args)
    this.stack = []
  }

  onKey (key, matches, data) {
    const op = this.bindings.has(key)
      ? this.bindings.get(key)
      : this.defaultBinding
    const save = op.run(this, key)
    if (save !== null) {
      this.stack.push([op, save])
    }
  }

  undo () {
    if (this.stack.length === 0) {
      return
    }
    const [op, key] = this.stack.pop()
    op.undo(this, key)
  }
...
}

export default UndoEditor
</code></pre>
</main>
<footer>
<div class="row">
<div class="left3">
<a href="../layout-engine/"><em>&laquo; Layout Engine</em></a>
</div>
<div class="middle3">
<a href="../license/"><img class="footer" src="../static/cc-by.svg" alt="License" /></a>
<a href="https://github.com/software-tools-in-javascript/stjs/"><img class="footer" src="../static/github.svg" alt="Repository" /></a>
© 2020 <a href="../authors/">The Authors</a>
</div>
<div class="right3">
<a href="../file-interpolator/"><em>File Interpolator &raquo;</em></a>
</div>
</div>
</footer>
</body>
</html>
