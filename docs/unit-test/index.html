<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
  <title>Unit Testing</title>
  <meta name="toRoot" content="..">
  <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
  <link href="../static/site.css" rel="stylesheet" type="text/css">
  <script src="../static/site.js"></script>
  <script>window.onload = () => fixPage()</script>
</head>
<body id="_top">
<nav>
<div class="row">
<div class="left2">
<a href="http://third-bit.com"><img src="../static/logo.svg" alt="site logo" class="site-logo"/></a>
<a href="../"><em>Software Tools in JavaScript</em></a>
</div>
<div class="right2">
<div class="dropdown">
<span class="navtitle">▿ Sections</span>
<div class="dropdown-content" id="Sections">
</div>
</div>
<div class="dropdown">
<span class="navtitle">▿ Chapters</span>
<div class="dropdown-content" id="Chapters">
<a href="../systems-programming/"><span class="nowrap">Systems Programming</span></a>
<br/><a href="../promises/"><span class="nowrap">Promises</span></a>
<br/><a href="../unit-test/"><span class="nowrap">Unit Testing</span></a>
<br/><a href="../file-backup/"><span class="nowrap">File Backup</span></a>
<br/><a href="../style-checker/"><span class="nowrap">Style Checker</span></a>
<br/><a href="../pattern-matching/"><span class="nowrap">Pattern Matching</span></a>
<br/><a href="../regex-parser/"><span class="nowrap">Parsing Expressions</span></a>
<br/><a href="../code-generator/"><span class="nowrap">Code Generator</span></a>
<br/><a href="../page-templates/"><span class="nowrap">Page Templates</span></a>
<br/><a href="../doc-generator/"><span class="nowrap">Documentation Generator</span></a>
<br/><a href="../module-loader/"><span class="nowrap">Module Loader</span></a>
<br/><a href="../module-bundler/"><span class="nowrap">Module Bundler</span></a>
<br/><a href="../layout-engine/"><span class="nowrap">Layout Engine</span></a>
<br/><a href="../text-editor/"><span class="nowrap">Text Editor</span></a>
<br/><a href="../http-server/"><span class="nowrap">HTTP Server</span></a>
<br/><a href="../build-manager/"><span class="nowrap">Build Manager</span></a>
<br/><a href="../package-manager/"><span class="nowrap">Package Manager</span></a>
<br/><a href="../issue-tracker/"><span class="nowrap">Issue Tracker</span></a>
<br/><a href="../conclusion/"><span class="nowrap">Conclusion</span></a>
</div>
</div>
<div class="dropdown">
<span class="navtitle">▿ Appendices</span>
<div class="dropdown-content" id="Appendices">
<a href="../license/"><span class="nowrap">License</span></a>
<br/><a href="../conduct/"><span class="nowrap">Code of Conduct</span></a>
<br/><a href="../contributing/"><span class="nowrap">Contributing</span></a>
<br/><a href="../bib/"><span class="nowrap">Bibliography</span></a>
<br/><a href="../gloss/"><span class="nowrap">Glossary</span></a>
<br/><a href="../links/"><span class="nowrap">Links</span></a>
<br/><a href="../solutions/"><span class="nowrap">Solutions</span></a>
<br/><a href="../authors/"><span class="nowrap">Authors</span></a>
</div>
</div>
</div>
</div>
</nav>
  <main>
  <h1>Unit Testing</h1>
  <p class="lede">Testing software piece by piece</p>
<ul>
<li>Goal: find and run unit tests and report their results
<ul>
<li>Inspired by <a href="https://mochajs.org/">Mocha</a> and <a href="https://jestjs.io/">Jest</a></li>
</ul>
</li>
<li>Design:
<ul>
<li>Find files containing tests</li>
<li>Load those files</li>
<li>As they load, those files register the tests to be run</li>
<li>We then execute the registered tests and capture results</li>
<li>When all tests are done, we report</li>
</ul>
</li>
<li>Lots of other designs are possible
<ul>
<li>Load files and then inspect them to find and run tests</li>
</ul>
</li>
</ul>
<h2 id="how-should-we-handle-unit-testing">How should we handle unit testing?</h2>
<ul>
<li>Every unit test:
<ul>
<li>Is a function of zero arguments so that it can be called uniformly</li>
<li>Creates a <g key="fixture">fixture</g> to be tested</li>
<li>Uses <g key="assertion">assertions</g>
to compare the <g key="actual_result">actual result</g>
against the <g key="expected_result">expected result</g></li>
</ul>
</li>
<li>Possible results are:
<ul>
<li><g key="pass_test">Pass</g>: works as expected</li>
<li><g key="fail_test">Fail</g>: something is wrong with the code being tested</li>
<li><g key="error_test">Error</g>: something wrong in the test itself,
so we know nothing certain about the system being tested</li>
</ul>
</li>
<li>We need some way to distinguish failure from error
<ul>
<li>Rely on the fact that exceptions are objects</li>
<li>If the object is an instance of <code>assert.AssertionError</code>
then it was <g key="throw_exception">thrown</g> by an assertion,
which (probably) means it's coming out of one of our checks</li>
<li>Any other kind of assertion is unexpected</li>
</ul>
</li>
</ul>
<h2 id="how-can-we-separate-test-registration-execution-and-reporting">How can we separate test registration, execution, and reporting?</h2>
<ul>
<li>Use <g key="global_variable">global variables</g> to record tests and results</li>
<li>The function <code>hopeThat</code> saves a message and a callback function
<ul>
<li>Don't run tests immediately because we want to wrap each one in our own <g key="exception_handler">exception handler</g></li>
</ul>
</li>
<li><code>main</code> runs all registered tests
<ul>
<li>If a test completes without an exception, it passes</li>
<li>If any of the <code>assert</code> calls raises an <code>AssertionError</code>, it fails</li>
<li>If it raises any other exception, it's an error</li>
</ul>
</li>
<li>Tests are run in the order in which they're registered, but we shouldn't rely on that</li>
<li>After all tests are run, report counts</li>
</ul>
<pre title="dry-run.js"><code class="language-js">const assert = require('assert')

// State of tests.
const HopeTests = []
let HopePass = 0
let HopeFail = 0
let HopeError = 0

// Record a single test for running later.
const hopeThat = (message, callback) =&gt; {
  HopeTests.push([message, callback])
}

// Run all of the tests that have been asked for and report summary.
const main = () =&gt; {
  HopeTests.forEach(([message, test]) =&gt; {
    try {
      test()
      HopePass += 1
    } catch (e) {
      if (e instanceof assert.AssertionError) {
        HopeFail += 1
      } else {
        HopeError += 1
      }
    }
  })

  console.log(`pass ${HopePass}`)
  console.log(`fail ${HopeFail}`)
  console.log(`error ${HopeError}`)
}

// Something to test (doesn't handle zero properly).
const sign = (value) =&gt; {
  if (value &lt; 0) {
    return -1
  } else {
    return 1
  }
}

// These two should pass.
hopeThat('Sign of negative is -1', () =&gt; assert(sign(-3) === -1))
hopeThat('Sign of positive is 1', () =&gt; assert(sign(19) === 1))

// This one should fail.
hopeThat('Sign of zero is 0', () =&gt; assert(sign(0) === 0))

// This one is an error.
hopeThat('Sign misspelled is error', () =&gt; assert(sgn(1) === 1))

// Call the main driver.
main()
</code></pre>
<pre title="dry-run.txt"><code class="language-txt">pass 2
fail 1
error 1
</code></pre>
<ul>
<li>Critique
<ul>
<li>Doesn't tell us <em>which</em> tests failed</li>
<li>We don't have a way to test that things raise <code>AssertionError</code> when they should</li>
<li>Those global variables should be bundled together somehow</li>
</ul>
</li>
</ul>
<h2 id="how-should-we-structure-test-registration">How should we structure test registration?</h2>
<ul>
<li>The <code>hope</code> module uses the <g key="singleton_pattern">Singleton</g> <g key="design_pattern">design pattern</g>
<ul>
<li>A class that only has one instance</li>
<li>Singletons are a structured way to manage global variables</li>
<li>Less code to rewrite and re-test if we change our minds later about only having one</li>
</ul>
</li>
<li>Defines class and exports an instance of that class
<ul>
<li>Relies on Node <g key="caching">caches</g> modules so that each is only loaded once</li>
</ul>
</li>
<li><code>Hope.test</code> records a test for later execution</li>
<li><code>Hope.run</code> executes all the tests registered so far</li>
<li>Provide two flavors of output (terse one-liner and full details)</li>
<li>Also provide raw material (title and results) for inspection and formatting (e.g., as HTML)</li>
</ul>
<pre title="hope.js"><code class="language-js">const assert = require('assert')
const caller = require('caller')

class Hope {
  constructor () {
    this.todo = []
    this.passes = []
    this.fails = []
    this.errors = []
  }

  test (comment, callback) {
    this.todo.push([`${caller()}::${comment}`, callback])
  }

  run () {
    this.todo.forEach(([comment, test]) =&gt; {
      try {
        test()
        this.passes.push(comment)
      } catch (e) {
        if (e instanceof assert.AssertionError) {
          this.fails.push(comment)
        } else {
          this.errors.push(comment)
        }
      }
    })
  }

  terse () {
    return this.cases()
      .map(([title, results]) =&gt; `${title}: ${results.length}`)
      .join(' ')
  }

  verbose () {
    let report = ''
    let prefix = ''
    for (const [title, results] of this.cases()) {
      report += `${prefix}${title}:`
      prefix = '\n'
      for (const r of results) {
        report += `${prefix}  ${r}`
      }
    }
    return report
  }

  cases () {
    return [
      ['passes', this.passes],
      ['fails', this.fails],
      ['errors', this.errors]]
  }
}

module.exports = new Hope()
</code></pre>
<ul>
<li>Use the <code>caller</code> module to find the name of who's calling the current function
<ul>
<li>Gives the user more information</li>
<li>Automatically correct (unlike handwritten strings that can fall out of step)</li>
</ul>
</li>
</ul>
<h2 id="how-can-we-build-a-commandline-driver-for-our-test-manager">How can we build a command-line driver for our test manager?</h2>
<ul>
<li>Keeping the files containing tests simple is the most important part of our design</li>
<li>Example in <code>test-add.js</code></li>
</ul>
<pre title="test-add.js"><code class="language-js">const assert = require('assert')
const hope = require('./hope')

hope.test('Sum of 1 and 2', () =&gt; assert((1 + 2) === 3))
</code></pre>
<ul>
<li>Load those <g key="dynamic_loading">dynamically</g>
<ul>
<li><code>require</code> is just a function</li>
<li>Takes a path as a parameter and reads that file</li>
</ul>
</li>
<li>Loading files executes the code they contain
<ul>
<li>Which registers tests as a <g key="side_effect">side effect</g> of calls to <code>hope.test</code></li>
</ul>
</li>
<li>Final part is the command-line tool that finds and loads tests
<ul>
<li>Parse command-line arguments using <code>minimist</code> module</li>
<li>Use the filenames provided or find and load all files that match <code>test-*.js</code></li>
<li>Call <code>hope.run()</code> to run all the tests they have registered</li>
<li>Report results</li>
</ul>
</li>
<li>Doesn't export anything, just runs</li>
</ul>
<pre title="pray.js"><code class="language-js">const minimist = require('minimist')
const glob = require('glob')
const hope = require('./hope')

const DEFAULTS = {
  filenames: [],
  root: '.',
  output: 'terse'
}

const main = (args) =&gt; {
  const options = parse(args)
  if (options.filenames.length === 0) {
    options.filenames = glob.sync(`${options.root}/**/test-*.js`)
  }
  options.filenames.forEach(f =&gt; {
    require(f)
  })
  hope.run()
  const result = (options.output === 'terse')
    ? hope.terse()
    : hope.verbose()
  console.log(result)
}

const parse = (args) =&gt; {
  const options = Object.assign({}, DEFAULTS)
  const argv = minimist(args)
  for (const key in argv) {
    switch (key) {
      case 'd' :
        options.root = argv[key]
        break
      case 'v' :
        options.output = 'verbose'
        break
      case '_':
        options.filenames = argv[key]
        break
      default :
        console.error(`unrecognized option ${key}`)
        break
    }
  }
  return options
}

main(process.argv.slice(2))
</code></pre>
<pre title="pray.sh"><code class="language-sh">node pray.js -v
</code></pre>
<pre title="pray.txt"><code class="language-txt">passes:
  /Users/gvwilson/stjs/unit-test/test-add.js::Sum of 1 and 2
  /Users/gvwilson/stjs/unit-test/test-sub.js::Difference of 1 and 2
fails:
  /Users/gvwilson/stjs/unit-test/test-div.js::Quotient of 1 and 0
  /Users/gvwilson/stjs/unit-test/test-mul.js::Product of 1 and 2
errors:
  /Users/gvwilson/stjs/unit-test/test-missing.js::Sum of x and 0
</code></pre>
<blockquote>
<p><strong>Filenames in <code>minimist</code></strong></p>
<p>If we use a command line like <code>pray.js -v something.js</code>,
then <code>something.js</code> becomes the value of <code>-v</code>.
To indicate that we want <code>something.js</code> added to the list of trailing filenames
associated with the special key <code>_</code> (a single underscore),
we have to write <code>pray.js -v -- something.js</code>.
The double dash is a common Unix convention for signalling the end of parameters.</p>
</blockquote>
<ul>
<li>Trace the <g key="lifecycle">lifecycle</g> of a pair of files <code>test-add.js</code> and <code>test-sub.js</code>
<ul>
<li><code>pray</code> uses <code>glob</code> to find files with tests</li>
<li>It loads <code>test-add.js</code> using <code>require</code></li>
<li>As <code>test-add.js</code> runs, it loads <code>hope.js</code></li>
<li>Which creates a single instance of the class <code>Hope</code></li>
<li><code>test-add.js</code> uses <code>hope.test</code> to register a test (which does <em>not</em> run yet)</li>
<li><code>pray</code> then loads <code>test-sub.js</code>
<ul>
<li><code>require('./hope')</code> in <code>test-sub.js</code> does <em>not</em> reload <code>hope.js</code> because that's already in memory</li>
<li>So the variable <code>hope</code> in <code>test-sub.js</code> refers to the same (unique) instance of <code>Hope</code> already created</li>
<li>So when <code>test-sub.js</code> calls <code>hope.test</code>, its test is added to that object</li>
</ul>
</li>
<li><code>pray</code> then asks that unique instance of <code>Hope</code> to run all of the tests</li>
<li>And then gets a report from it</li>
</ul>
</li>
<li>Note that <code>1/0</code> is a failure rather than an error
<ul>
<li>JavaScript thinks the result is <code>Infinity</code> rather than an exception</li>
</ul>
</li>
</ul>
<h2 id="how-do-we-handle-promises-in-tests">How do we handle promises in tests?</h2>
<p>FIXME: explain how to manage tests that create promises (may require rewriting existing framework)</p>
</main>
<footer>
<div class="row">
<div class="left3">
<a href="../promises/"><em>&laquo; Promises</em></a>
</div>
<div class="middle3">
<a href="../license/"><img class="footer" src="../static/cc-by.svg" alt="License" /></a>
<a href="https://github.com/gvwilson/e/"><img class="footer" src="../static/github.svg" alt="Repository" /></a>
© 2020 <a href="../authors/">The Authors</a>
</div>
<div class="right3">
<a href="../file-backup/"><em>File Backup &raquo;</em></a>
</div>
</div>
</footer>
</body>
</html>
