<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
  <title>File Backup</title>
  <meta name="slug" content="file-backup">
  <meta name="toRoot" content="..">
  <link rel="shortcut icon" type="image/x-icon" href="../../favicon.ico">
  <link href="../../static/fonts.css" rel="stylesheet" type="text/css">
  <link href="../../static/site.css" rel="stylesheet" type="text/css">
  <script>const NUMBERING = {"vol1":"1","systems-programming":"2","promises":"3","unit-test":"4","file-backup":"5","data-table":"6","pattern-matching":"7","regex-parser":"8","page-templates":"9","build-manager":"10","layout-engine":"11","text-editor":"12","file-interpolator":"13","module-loader":"14","module-bundler":"15","package-manager":"16","style-checker":"17","code-generator":"18","doc-generator":"19","virtual-machine":"20","debugger":"21","conclusion":"22","bib":"A","license":"B","conduct":"C","contributing":"D","cognition":"E","gloss":"F","links":"G","authors":"H"}</script>
  <script src="../../static/site.js"></script>
  <script>window.onload = () => fixPage()</script>
</head>
<body id="_top">
<nav>
<div class="row">
<div class="left2">
<a href="../"><img src="../../static/logo.svg" alt="site logo" class="site-logo"/></a>
</div>
<div class="right2">
<div class="dropdown">
<span class="navtitle">▿ Sections</span>
<div class="dropdown-content" id="Sections">
</div>
</div>
<div class="dropdown">
<span class="navtitle">▿ Chapters</span>
<div class="dropdown-content" id="Chapters">
<a href="../systems-programming/"><span class="nowrap">Systems Programming</span></a>
<br/><a href="../promises/"><span class="nowrap">Promises</span></a>
<br/><a href="../unit-test/"><span class="nowrap">Unit Testing</span></a>
<br/><a href="../file-backup/"><span class="nowrap">File Backup</span></a>
<br/><a href="../data-table/"><span class="nowrap">Data Tables</span></a>
<br/><a href="../pattern-matching/"><span class="nowrap">Pattern Matching</span></a>
<br/><a href="../regex-parser/"><span class="nowrap">Parsing Expressions</span></a>
<br/><a href="../page-templates/"><span class="nowrap">Page Templates</span></a>
<br/><a href="../build-manager/"><span class="nowrap">Build Manager</span></a>
<br/><a href="../layout-engine/"><span class="nowrap">Layout Engine</span></a>
<br/><a href="../text-editor/"><span class="nowrap">Text Editor</span></a>
<br/><a href="../file-interpolator/"><span class="nowrap">File Interpolator</span></a>
<br/><a href="../module-loader/"><span class="nowrap">Module Loader</span></a>
<br/><a href="../module-bundler/"><span class="nowrap">Module Bundler</span></a>
<br/><a href="../package-manager/"><span class="nowrap">Package Manager</span></a>
<br/><a href="../style-checker/"><span class="nowrap">Style Checker</span></a>
<br/><a href="../code-generator/"><span class="nowrap">Code Generator</span></a>
<br/><a href="../doc-generator/"><span class="nowrap">Documentation Generator</span></a>
<br/><a href="../virtual-machine/"><span class="nowrap">Virtual Machine</span></a>
<br/><a href="../debugger/"><span class="nowrap">Debugger</span></a>
<br/><a href="../conclusion/"><span class="nowrap">Conclusion</span></a>
</div>
</div>
<div class="dropdown">
<span class="navtitle">▿ Appendices</span>
<div class="dropdown-content" id="Appendices">
<a href="../bib/"><span class="nowrap">Bibliography</span></a>
<br/><a href="../license/"><span class="nowrap">License</span></a>
<br/><a href="../conduct/"><span class="nowrap">Code of Conduct</span></a>
<br/><a href="../contributing/"><span class="nowrap">Contributing</span></a>
<br/><a href="../cognition/"><span class="nowrap">Cognition</span></a>
<br/><a href="../gloss/"><span class="nowrap">Glossary</span></a>
<br/><a href="../links/"><span class="nowrap">Links</span></a>
<br/><a href="../authors/"><span class="nowrap">Authors</span></a>
</div>
</div>
</div>
</div>
</nav>
  <main>
  <h1>File Backup</h1>
  <h2 class="lede">Archiving files with directory structure</h2>
<div class="callout">
  <p>Terms defined: <g key="asynchronous">asynchronous</g>, <g key="csv">comma-separated values (CSV)</g>, <g key="utc">Coordinated Universal Time (UTC)</g>, <g key="cryptographic_hash_function">cryptographic hash function</g>, <g key="hash_function">hash function</g>, <g key="mock_object">mock object</g>, <g key="race_condition">race condition</g>, <g key="stream">stream</g>, <g key="toctou">Time of check/time of use (ToCToU)</g>, <g key="timestamp">timestamp</g></p>
</div>
<ul>
<li>Goal: archiving files with an index that identifies each version so that we don't store redundant data</li>
<li>The basis of <a href="https://git-scm.com/">Git</a></li>
</ul>
<h2 id="what-is-a-hash-code-and-how-can-we-create-one-for-a-file">What is a hash code and how can we create one for a file?</h2>
<ul>
<li>A <g key="hash_function">hash function</g> turns arbitrary data into a fixed-length string of bits
<ul>
<li>That bit string can then be used to place the object in a predictable place in a table</li>
<li>Gives reasonably fast lookup for arbitrary keys</li>
</ul>
</li>
</ul>
<figure class="fixme"><img src="/static/tools-small.jpg" alt="Hash functions"/><figcaption id="file-backup-hash-function">How hash functions speed up lookup.</figcaption></figure>
<ul>
<li>A <g key="cryptographic_hash_function">cryptographic hash function</g> produces keys that appear random
<ul>
<li>Leads to the fastest possible lookup on average</li>
</ul>
</li>
<li>Easy to write a bad hash function but hard to write a strong one
<ul>
<li>Use a library to calculate a 160-bit [SHA-1] hash</li>
<li>Not strong enough to deter a well-funded attacker, but that's not what we're using it for</li>
</ul>
</li>
</ul>
<pre title="hash-text.js"><code class="language-js">import crypto from 'crypto'

// create a SHA1 hasher
const hash = crypto.createHash('sha1')

// encode as hex (rather than binary)
hash.setEncoding('hex')

// send it some text
const text = process.argv[2]
hash.write(text)

// signal end of text
hash.end()

// display the result
const sha1sum = hash.read()
console.log(`SHA1 of "${text}" is ${sha1sum}`)
</code></pre>
<pre title="hash-text.sh"><code class="language-sh">node hash-text.js something
</code></pre>
<pre title="hash-text.out"><code class="language-out">SHA1 of "something" is 1af17e73721dbe0c40011b82ed4bb1a7dbe3ce29
</code></pre>
<ul>
<li>The hash code for a file:
<ul>
<li>Will always be the same for the same content</li>
<li>Is almost certain to be different if even a single byte differs</li>
</ul>
</li>
</ul>
<pre title="hash-file.js"><code class="language-js">import fs from 'fs'
import crypto from 'crypto'

const filename = process.argv[2]
const data = fs.readFileSync(filename, 'utf-8')

const hash = crypto.createHash('sha1').setEncoding('hex')
hash.write(data)
hash.end()
const sha1sum = hash.read()

console.log(`SHA1 of "${filename}" is ${sha1sum}`)
</code></pre>
<pre title="hash-file.sh"><code class="language-sh">node hash-file.js hash-file.js
</code></pre>
<pre title="hash-file.out"><code class="language-out">SHA1 of "hash-file.js" is c54c8ee3e576770d29ae2d0d73568e5a5c49eac0
</code></pre>
<div class="callout">
<h3 id="the-birthday-problem">The Birthday Problem</h3>
<p>The odds that two people share a birthday are 1/365 (ignoring February 29).
The odds that they <em>don't</em> are therefore 364/365.
When we add a third person,
the odds that they don't share a birthday with either of the preceding two people are 363/365,
so the overall odds that nobody shares a birthday are (365/365)×(364/365)×(363/365).
If we keep calculating, there's a 50% chance of two people sharing a birthday in a group of just 23 people,
and a 99.9% chance with 70 people.</p>
<p>We can use the same math to calculate how many files we need to hash before there's a 50% chance of a collision.
Instead of 365, we use 2<sup>160</sup> (the number of values that are 160 bits long),
and quickly get into &quot;if every atom in the universe was a file there still wouldn't be collisions&quot; territory.</p>
</div>
<ul>
<li>More efficient to process the file as a <g key="stream">stream</g>
<ul>
<li>Read the file in chunks</li>
<li>Pass each chunk to an object containing a hashing function, which accumulates a result</li>
<li>Tell the hashing object what to do when the stream finishes</li>
<li>Another example of <g key="asynchronous">asynchronous</g> execution</li>
</ul>
</li>
</ul>
<pre title="hash-stream.js"><code class="language-js">import fs from 'fs'
import crypto from 'crypto'

const filename = process.argv[2]
const hash = crypto.createHash('sha1').setEncoding('hex')
fs.createReadStream(filename).pipe(hash)
hash.on('finish', () =&gt; {
  const final = hash.read()
  console.log('final', final)
})
console.log('program ends')
</code></pre>
<pre title="hash-stream.sh"><code class="language-sh">node hash-stream.js hash-stream.js
</code></pre>
<pre title="hash-stream.out"><code class="language-out">program ends
final dc9e6c231e243860dace2dbf52845b121062b60e
</code></pre>
<figure class="fixme"><img src="/static/tools-small.jpg" alt="Streaming file operations"/><figcaption id="file-backup-streaming">Processing files as streams of chunks.</figcaption></figure>
<ul>
<li>Many files don't change after they're created, or only change very slowly</li>
<li>Wasteful to copy them every time a backup is done</li>
<li>Instead:
<ul>
<li>Copy each file to something like <code>abcd1234.bck</code> where <code>abcd1234</code> is a hash of the file's contents</li>
<li>Store a data structure that records filenames and hash keys at a particular instant</li>
<li>To restore from a particular date, copy saved files to where they need to be</li>
</ul>
</li>
</ul>
<figure class="fixme"><img src="/static/tools-small.jpg" alt="Backup file storage"/><figcaption id="file-backup-storage">Organization of backup file storage.</figcaption></figure>
<h2 id="how-can-async-and-await-simplify-code">How can async and await simplify code?</h2>
<ul>
<li>Step 1: find all files and calculate their hashes</li>
</ul>
<pre title="hash-existing-promise.js"><code class="language-js">import fs from 'fs-extra-promise'
import glob from 'glob-promise'
import crypto from 'crypto'

const statPath = (path) =&gt; {
  return new Promise((resolve, reject) =&gt; {
    fs.statAsync(path)
      .then(stat =&gt; resolve([path, stat]))
      .catch(err =&gt; reject(err))
  })
}

const readPath = (path) =&gt; {
  return new Promise((resolve, reject) =&gt; {
    fs.readFileAsync(path, 'utf-8')
      .then(content =&gt; resolve([path, content]))
      .catch(err =&gt; reject(err))
  })
}

const hashPath = (path, content) =&gt; {
  const hasher = crypto.createHash('sha1').setEncoding('hex')
  hasher.write(content)
  hasher.end()
  return [path, hasher.read()]
}

const hashExisting = (rootDir) =&gt; {
  const pattern = `${rootDir}/**/*`
  const options = {}
  return new Promise((resolve, reject) =&gt; {
    glob(pattern, options)
      .then(matches =&gt; Promise.all(
        matches.map(path =&gt; statPath(path))))
      .then(pairs =&gt; pairs.filter(
        ([path, stat]) =&gt; stat.isFile()))
      .then(pairs =&gt; Promise.all(
        pairs.map(([path, stat]) =&gt; readPath(path))))
      .then(pairs =&gt; Promise.all(
        pairs.map(([path, content]) =&gt; hashPath(path, content))))
      .then(pairs =&gt; resolve(pairs))
      .catch(err =&gt; reject(err))
  })
}

export default hashExisting
</code></pre>
<pre title="run-hash-existing-promise.js"><code class="language-js">import hashExisting from './hash-existing-promise.js'

const root = process.argv[2]
hashExisting(root).then(pairs =&gt; pairs.forEach(
  ([path, hash]) =&gt; console.log(path, hash)
))
</code></pre>
<pre title="run-hash-existing-promise.sh"><code class="language-sh">node run-hash-existing-promise.js . | fgrep -v test/ | fgrep -v '~'
</code></pre>
<pre title="run-hash-existing-promise.slice.out"><code class="language-out">./backup.js 11422489e11be3d8ff76278503457665f6152ebe
./check-existing-files.js 66b933cf9e792e9a9204171d04e0f8b530ec3f4f
./hash-existing-async.js 38518660463a80367f9719a870916eeab2933a8d
./hash-existing-promise.js 2b022a50294697eef84689b63ab46f0b899d14db
./hash-file.js c54c8ee3e576770d29ae2d0d73568e5a5c49eac0
./hash-file.out 7d5014143474e733daf263a94d4d43df30ba91cf
./hash-file.sh ff2f263c71ce98338adf4a8a65c297c9361e3e16
./hash-stream.js dc9e6c231e243860dace2dbf52845b121062b60e
./hash-stream.out af7195be4585e588f301cbfbddd5a47966cb704c
./hash-stream.sh 0dd6064f3005e832fef580f3de7fa0980fd81dee
...
./x-from-to/problem.md 47bb0e1ef733bc2b946f23bb03742272b34f7bf9
./x-from-to/solution.md 412b87759362bb14d417e02efe7c3607274e10ca
./x-io-streams/problem.md 298897364632cd64c8a50c0a08aa3e235335c0d4
./x-io-streams/solution.md 412b87759362bb14d417e02efe7c3607274e10ca
./x-json-manifests/problem.md 83ad4f0d55f420dbe694b72a26a89b9b4d92bea6
./x-json-manifests/solution.md 412b87759362bb14d417e02efe7c3607274e10ca
./x-mock-hashes/problem.md c1e815e888846fddd0e3d28640c0e20a8c665b25
./x-mock-hashes/solution.md 412b87759362bb14d417e02efe7c3607274e10ca
./x-pre-commit/problem.md b7d945af4554fc0f64b708fe735417bee8b33eef
./x-pre-commit/solution.md 412b87759362bb14d417e02efe7c3607274e10ca
</code></pre>
<ul>
<li>This code is clearer than it would be with callbacks, but the layer of promises around everything still obscures meaning</li>
<li>Let's rewrite it using <code>async</code> and <code>await</code></li>
</ul>
<pre title="hash-existing-async.js"><code class="language-js">import fs from 'fs-extra-promise'
import glob from 'glob-promise'
import crypto from 'crypto'

const statPath = async (path) =&gt; {
  const stat = await fs.statAsync(path)
  return [path, stat]
}

const readPath = async (path) =&gt; {
  const content = await fs.readFileAsync(path, 'utf-8')
  return [path, content]
}

const hashPath = (path, content) =&gt; {
  const hasher = crypto.createHash('sha1').setEncoding('hex')
  hasher.write(content)
  hasher.end()
  return [path, hasher.read()]
}

const hashExisting = async (rootDir) =&gt; {
  const pattern = `${rootDir}/**/*`
  const options = {}
  const matches = await glob(pattern, options)
  const stats = await Promise.all(matches.map(path =&gt; statPath(path)))
  const files = stats.filter(([path, stat]) =&gt; stat.isFile())
  const contents = await Promise.all(
    files.map(([path, stat]) =&gt; readPath(path)))
  const hashes = contents.map(
    ([path, content]) =&gt; hashPath(path, content))
  return hashes
}

export default hashExisting
</code></pre>
<pre title="run-hash-existing-async.js"><code class="language-js">import hashExisting from './hash-existing-async.js'

const root = process.argv[2]
hashExisting(root).then(
  pairs =&gt; pairs.forEach(([path, hash]) =&gt; console.log(path, hash)))
</code></pre>
<pre title="run-hash-existing-async.sh"><code class="language-sh">node run-hash-existing-async.js . | fgrep -v test/ | fgrep -v '~'
</code></pre>
<pre title="run-hash-existing-async.slice.out"><code class="language-out">./backup.js 11422489e11be3d8ff76278503457665f6152ebe
./check-existing-files.js 66b933cf9e792e9a9204171d04e0f8b530ec3f4f
./hash-existing-async.js 38518660463a80367f9719a870916eeab2933a8d
./hash-existing-promise.js 2b022a50294697eef84689b63ab46f0b899d14db
./hash-file.js c54c8ee3e576770d29ae2d0d73568e5a5c49eac0
./hash-file.out 7d5014143474e733daf263a94d4d43df30ba91cf
./hash-file.sh ff2f263c71ce98338adf4a8a65c297c9361e3e16
./hash-stream.js dc9e6c231e243860dace2dbf52845b121062b60e
./hash-stream.out af7195be4585e588f301cbfbddd5a47966cb704c
./hash-stream.sh 0dd6064f3005e832fef580f3de7fa0980fd81dee
...
./x-from-to/problem.md 47bb0e1ef733bc2b946f23bb03742272b34f7bf9
./x-from-to/solution.md 412b87759362bb14d417e02efe7c3607274e10ca
./x-io-streams/problem.md 298897364632cd64c8a50c0a08aa3e235335c0d4
./x-io-streams/solution.md 412b87759362bb14d417e02efe7c3607274e10ca
./x-json-manifests/problem.md 83ad4f0d55f420dbe694b72a26a89b9b4d92bea6
./x-json-manifests/solution.md 412b87759362bb14d417e02efe7c3607274e10ca
./x-mock-hashes/problem.md c1e815e888846fddd0e3d28640c0e20a8c665b25
./x-mock-hashes/solution.md 412b87759362bb14d417e02efe7c3607274e10ca
./x-pre-commit/problem.md b7d945af4554fc0f64b708fe735417bee8b33eef
./x-pre-commit/solution.md 412b87759362bb14d417e02efe7c3607274e10ca
</code></pre>
<h2 id="how-can-we-test-javascript">How can we test JavaScript?</h2>
<ul>
<li>Step 2: see which files have and haven't been backed up already
<ul>
<li>Backup directory contains <code>abcd1234.bck</code> (backup files) and <code>ssssssssss.csv</code> (manifest files),
where <code>ssssssssss</code> is the <g key="utc">UTC</g> <g key="timestamp">timestamp</g> of the backup's creation</li>
<li>We assume no more than one backup per second</li>
<li>This is unsafe in practice: leads to a <g key="toctou">Time of check/time of use</g> <g key="race_condition">race condition</g></li>
</ul>
</li>
</ul>
<pre title="check-existing-files.js"><code class="language-js">import glob from 'glob-promise'
import path from 'path'

const findNewFiles = async (rootDir, pathHashPairs) =&gt; {
  const hashToPath = pathHashPairs.reduce((obj, [path, hash]) =&gt; {
    obj[hash] = path
    return obj
  }, {})

  const pattern = `${rootDir}/*.bck`
  const options = {}
  const existingFiles = await glob(pattern, options)

  existingFiles.forEach(filename =&gt; {
    const stripped = path.basename(filename).replace(/\.bck$/, '')
    delete hashToPath[stripped]
  })

  return hashToPath
}

export default findNewFiles
</code></pre>
<figure class="fixme"><img src="/static/tools-small.jpg" alt="Time of check/time of use race condition"/><figcaption id="file-backup-toctou">Race condition when time of check and time of use are not the same.</figcaption></figure>
<ul>
<li>Manually create testing directories with manufactured (shortened) hashes</li>
</ul>
<pre title="tree-test.sh"><code class="language-sh">tree --charset unicode test
</code></pre>
<pre title="tree-test.out"><code class="language-out">test
|-- bck-0-csv-0
|-- bck-1-csv-1
|   |-- 0001.csv
|   `-- abcd1234.bck
|-- bck-4-csv-2
|   |-- 0001.csv
|   |-- 3028.csv
|   |-- 3456cdef.bck
|   |-- abcd1234.bck
|   `-- bcde2345.bck
|-- test-backup.js
|-- test-find-mock.js
`-- test-find.js

3 directories, 10 files
</code></pre>
<ul>
<li>Use <a href="https://mochajs.org/">Mocha</a> for testing
<ul>
<li>All tests are written using <code>async</code></li>
<li>Mocha will automatically wait for them to complete before reporting results</li>
<li>Add <code>&quot;test&quot;: &quot;mocha */test/test-*.js&quot;</code> to the <code>scripts</code> key of <code>package.json</code>,
since we may add tests for other things later</li>
</ul>
</li>
</ul>
<pre title="test/test-find.js"><code class="language-js">import assert from 'assert'

import findNewFiles from '../check-existing-files.js'

describe('pre-existing hashes and actual filesystem', () =&gt; {
  it('finds no pre-existing files when none given or exist', async () =&gt; {
    const expected = {}
    const actual = await findNewFiles('file-backup/test/bck-0-csv-0', [])
    assert.deepStrictEqual(expected, actual,
      'Expected no files')
  })

  it('finds some files when one file is given and none exist', async () =&gt; {
    const check = [['somefile.txt', '9876fedc']]
    const expected = { '9876fedc': 'somefile.txt' }
    const actual = await findNewFiles('file-backup/test/bck-0-csv-0', check)
    assert.deepStrictEqual(expected, actual,
      'Expected one file')
  })

  it('finds nothing needs backup when there is a match', async () =&gt; {
    const check = [['alpha.js', 'abcd1234']]
    const expected = {}
    const actual = await findNewFiles('file-backup/test/bck-1-csv-1', check)
    assert.deepStrictEqual(expected, actual,
      'Expected no files')
  })

  it('finds something needs backup when there is a mismatch', async () =&gt; {
    const check = [['alpha.js', 'a1b2c3d4']]
    const expected = { a1b2c3d4: 'alpha.js' }
    const actual = await findNewFiles('file-backup/test/bck-1-csv-1', check)
    assert.deepStrictEqual(expected, actual,
      'Expected one file')
  })

  it('finds mixed matches', async () =&gt; {
    const check = [
      ['matches.js', '3456cdef'],
      ['matches.txt', 'abcd1234'],
      ['mismatch.txt', '12345678']
    ]
    const expected = { 12345678: 'mismatch.txt' }
    const actual = await findNewFiles('file-backup/test/bck-4-csv-2', check)
    assert.deepStrictEqual(expected, actual,
      'Expected one file')
  })
})
</code></pre>
<pre title="test-check-filesystem.out"><code class="language-out">
&gt; stjs@1.0.0 test /u/stjs
&gt; mocha */test/test-*.js "-g" "pre-existing hashes"



  checks for pre-existing hashes using mock filesystem
    ✓ finds no pre-existing files when none given or exist
    ✓ finds some files when one file is given and none exist
    ✓ finds nothing needs backup when there is a match
    ✓ finds something needs backup when there is a mismatch
    ✓ finds mixed matches

  pre-existing hashes and actual filesystem
    ✓ finds no pre-existing files when none given or exist
    ✓ finds some files when one file is given and none exist
    ✓ finds nothing needs backup when there is a match
    ✓ finds something needs backup when there is a mismatch
    ✓ finds mixed matches


  10 passing (30ms)
</code></pre>
<h2 id="how-can-we-test-code-that-modifies-files">How can we test code that modifies files?</h2>
<ul>
<li>Step 3: copy the files that need copying and create a new timestamped <g key="csv">CSV</g> file
<ul>
<li>Could use JSON, but CSV is easier for humans to read</li>
</ul>
</li>
<li>The code itself will be relatively simple, but setup and cleanup will be annoying</li>
<li>Better solution: use a <g key="mock_object">mock object</g> instead of the real filesystem
<ul>
<li>Has the same interface as the real function/object/class/library</li>
<li>But works differently for testing purposes</li>
</ul>
</li>
</ul>
<figure class="fixme"><img src="/static/tools-small.jpg" alt="Mock filesystem"/><figcaption id="file-backup-mock-fs">Using a mock filesystem to simplify testing.</figcaption></figure>
<ul>
<li>Install <a href="https://www.npmjs.com/package/mock-fs"><code>mock-fs</code></a></li>
<li>Create a mock filesystem with a JSON description of files and their contents</li>
<li>Repeat previous tests using mock
<ul>
<li>Results stay the same</li>
</ul>
</li>
</ul>
<pre title="test/test-find-mock.js"><code class="language-js">import assert from 'assert'
import mock from 'mock-fs'

import findNewFiles from '../check-existing-files.js'

describe('checks for pre-existing hashes using mock filesystem', () =&gt; {
  beforeEach(() =&gt; {
    mock({
      'bck-0-csv-0': {},
      'bck-1-csv-1': {
        '0001.csv': 'alpha.js,abcd1234',
        'abcd1234.bck': 'alpha.js content'
      },
      'bck-4-csv-2': {
        '0001.csv': ['alpha.js,abcd1234',
          'beta.txt,bcde2345'].join('\n'),
        '3024.csv': ['alpha.js,abcd1234',
          'gamma.png,3456cdef',
          'subdir/renamed.txt,bcde2345'].join('\n'),
        '3456cdef.bck': 'gamma.png content',
        'abcd1234.bck': 'alpha content',
        'bcde2345.bck': 'beta.txt became subdir/renamed.txt'
      }
    })
  })

  afterEach(() =&gt; {
    mock.restore()
  })

  it('finds no pre-existing files when none given or exist', async () =&gt; {
    const expected = {}
    const actual = await findNewFiles('bck-0-csv-0', [])
    assert.deepStrictEqual(expected, actual,
      'Expected no files')
  })

  it('finds some files when one file is given and none exist', async () =&gt; {
    const candidates = [['somefile.txt', '9876fedc']]
    const expected = { '9876fedc': 'somefile.txt' }
    const actual = await findNewFiles('bck-0-csv-0', candidates)
    assert.deepStrictEqual(expected, actual,
      'Expected one file')
  })

  it('finds nothing needs backup when there is a match', async () =&gt; {
    const candidates = [['alpha.js', 'abcd1234']]
    const expected = {}
    const actual = await findNewFiles('bck-1-csv-1', candidates)
    assert.deepStrictEqual(expected, actual,
      'Expected no files')
  })

  it('finds something needs backup when there is a mismatch', async () =&gt; {
    const candidates = [['alpha.js', 'a1b2c3d4']]
    const expected = { a1b2c3d4: 'alpha.js' }
    const actual = await findNewFiles('bck-1-csv-1', candidates)
    assert.deepStrictEqual(expected, actual,
      'Expected one file')
  })

  it('finds mixed matches', async () =&gt; {
    const candidates = [['matches.js', '3456cdef'],
      ['matches.txt', 'abcd1234'],
      ['mismatch.txt', '12345678']]
    const expected = { 12345678: 'mismatch.txt' }
    const actual = await findNewFiles('bck-4-csv-2', candidates)
    assert.deepStrictEqual(expected, actual,
      'Expected one file')
  })
})
</code></pre>
<ul>
<li>Now write the code that does the file copying</li>
</ul>
<pre title="backup.js"><code class="language-js">import fs from 'fs-extra-promise'

import hashExisting from './hash-existing-async.js'
import findNewFiles from './check-existing-files.js'

const backup = async (src, dst, timestamp = null) =&gt; {
  if (timestamp === null) {
    timestamp = Math.round((new Date()).getTime() / 1000)
  }
  timestamp = String(timestamp).padStart(10, '0')

  const existing = await hashExisting(src)
  const needToCopy = await findNewFiles(dst, existing)
  await copyFiles(dst, needToCopy)
  await saveManifest(dst, timestamp, existing)
}

const copyFiles = async (dst, needToCopy) =&gt; {
  const promises = Object.keys(needToCopy).map(hash =&gt; {
    const srcPath = needToCopy[hash]
    const dstPath = `${dst}/${hash}.bck`
    fs.copyFileAsync(srcPath, dstPath)
  })
  return Promise.all(promises)
}

const saveManifest = async (dst, timestamp, pathHash) =&gt; {
  pathHash = pathHash.sort()
  const content = pathHash.map(
    ([path, hash]) =&gt; `${path},${hash}`).join('\n')
  const manifest = `${dst}/${timestamp}.csv`
  fs.writeFileAsync(manifest, content, 'utf-8')
}

export default backup
</code></pre>
<ul>
<li>And some tests
<ul>
<li>Which are quite involved, since we want to check with actual file hashes</li>
</ul>
</li>
<li>Set up some fixtures</li>
</ul>
<pre title="test/test-backup.js"><code class="language-js">import backup from '../backup.js'

const hashString = (data) =&gt; {
  const hasher = crypto.createHash('sha1').setEncoding('hex')
  hasher.write(data)
  hasher.end()
  return hasher.read()
}

const Contents = {
  aaa: 'AAA',
  bbb: 'BBB',
  ccc: 'CCC'
}

const Hashes = Object.keys(Contents).reduce((obj, key) =&gt; {
  obj[key] = hashString(Contents[key])
  return obj
}, {})

const Fixture = {
  source: {
    'alpha.txt': Contents.aaa,
    'beta.txt': Contents.bbb,
    gamma: {
      'delta.txt': Contents.ccc
    }
  },
  backup: {}
}

const InitialBackups = Object.keys(Hashes).reduce((set, filename) =&gt; {
  set.add(`backup/${Hashes[filename]}.bck`)
  return set
}, new Set())</code></pre>
<ul>
<li>And then run some tests</li>
</ul>
<pre title="test/test-backup.js"><code class="language-js">describe('check entire backup process', () =&gt; {
  beforeEach(() =&gt; {
    mock(Fixture)
  })

  afterEach(() =&gt; {
    mock.restore()
  })

  it('creates an initial CSV manifest', async () =&gt; {
    await backup('source', 'backup', 0)

    assert.strictEqual((await glob('backup/*')).length, 4,
      'Expected 4 files')

    const actualBackups = new Set(await glob('backup/*.bck'))
    assert.deepStrictEqual(actualBackups, InitialBackups,
      'Expected 3 backup files')

    const actualManifests = await glob('backup/*.csv')
    assert.deepStrictEqual(actualManifests, ['backup/0000000000.csv'],
      'Expected one manifest')
  })

  it('does not duplicate files unnecessarily', async () =&gt; {
    await backup('source', 'backup', 0)
    assert.strictEqual((await glob('backup/*')).length, 4,
      'Expected 4 files after first backup')

    await backup('source', 'backup', 1)
    assert.strictEqual((await glob('backup/*')).length, 5,
      'Expected 5 files after second backup')
    const actualBackups = new Set(await glob('backup/*.bck'))
    assert.deepStrictEqual(actualBackups, InitialBackups,
      'Expected 3 backup files after second backup')

    const actualManifests = (await glob('backup/*.csv')).sort()
    assert.deepStrictEqual(actualManifests,
      ['backup/0000000000.csv', 'backup/0000000001.csv'],
      'Expected two manifests')
  })

  it('adds a file as needed', async () =&gt; {
    await backup('source', 'backup', 0)
    assert.strictEqual((await glob('backup/*')).length, 4,
      'Expected 4 files after first backup')

    await fs.writeFileAsync('source/newfile.txt', 'NNN')
    const hashOfNewFile = hashString('NNN')

    await backup('source', 'backup', 1)
    assert.strictEqual((await glob('backup/*')).length, 6,
      'Expected 6 files after second backup')
    const expected = new Set(InitialBackups)
      .add(`backup/${hashOfNewFile}.bck`)
    const actualBackups = new Set(await glob('backup/*.bck'))
    assert.deepStrictEqual(actualBackups, expected,
      'Expected 4 backup files after second backup')

    const actualManifests = (await glob('backup/*.csv')).sort()
    assert.deepStrictEqual(actualManifests,
      ['backup/0000000000.csv', 'backup/0000000001.csv'],
      'Expected two manifests')
  })
})</code></pre>
<pre title="test-backup.out"><code class="language-out">test-backup.sh: line 1: ../_tools/wrap.js: No such file or directory
</code></pre>
<h2 id="exercises">Exercises</h2>
<h3 class="exercise">Odds of collision</h3>
<p>If hashes were only 2 bits long,
then the chances of collision with each successive file
assuming no previous collision are:</p>
<table>
<thead>
<tr>
<th>Number of Files</th>
<th>Odds of Collision</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0%</td>
</tr>
<tr>
<td>2</td>
<td>25%</td>
</tr>
<tr>
<td>3</td>
<td>50%</td>
</tr>
<tr>
<td>4</td>
<td>75%</td>
</tr>
<tr>
<td>5</td>
<td>100%</td>
</tr>
</tbody>
</table>
<p>A colleague of yours says this means that if we hash four files,
there's only a 75% chance of any collision occurring.
What are the actual odds?</p>
<h3 class="exercise">Streaming I/O</h3>
<p>Write a small program using <code>fs.createReadStream</code> and <code>fs.createWriteStream</code>
that copies a file piece by piece
instead of reading it into memory and then writing it out again.</p>
<h3 class="exercise">Sequencing backups</h3>
<p>Modify the backup program so that manifests are numbered sequentially
as <code>00000001.csv</code>, <code>00000002.csv</code>, and so on
rather than being timestamped.
Why doesn't this solve the time of check/time of use race condition mentioned earlier.</p>
<h3 class="exercise">JSON manifests</h3>
<ol>
<li>
<p>Modify <code>backup.js</code> so that it can save JSON manifests as well as CSV manifests
based on a command-line flag.</p>
</li>
<li>
<p>Write another program called <code>migrate.js</code> that converts a set of manifests
from CSV to JSON.
(The program's name comes from the term <g key="data_migration">data migration</g>.)</p>
</li>
<li>
<p>Modify <code>backup.js</code> programs so that each manifest stores the user name of the person who created it
along with file hashes,
and then modify <code>migrate.js</code> to transform old files into the new format.</p>
</li>
</ol>
<h3 class="exercise">Testing line counting</h3>
<p>Write tests for the line-counting functions of <xref key="promises"></xref> using Mocha and <code>mock-fs</code>.
Did you find (at least) two bugs?</p>
<h3 class="exercise">Mock hashes</h3>
<ol>
<li>Modify the file backup program so that it uses a function called <code>ourHash</code> to hash files.</li>
<li>Create a replacement that returns some predictable value, such as the first few characters of the data.</li>
<li>Rewrite the tests to use this function.</li>
</ol>
<p>How did you modify the main program so that the tests could control which hashing function is used?</p>
<h3 class="exercise">Comparing manifests</h3>
<p>Write a program <code>compare-manifests.js</code> that reads two manifest files and reports:</p>
<ul>
<li>Which files have the same names but different hashes
(i.e., their contents have changed).</li>
<li>Which files have the same hashes but different names
(i.e., they have been renamed).</li>
<li>Which files are in the first hash but neither their names nor their hashes are in the second
(i.e., they have been deleted).</li>
<li>Which files are in the second hash but neither their names nor their hashes are in the first
(i.e., they have been added).</li>
</ul>
<h3 class="exercise">From one state to another</h3>
<ol>
<li>
<p>Write a program called <code>from-to.js</code> that takes the name of a directory
and the name of a manifest file
as its command-line arguments,
then adds, removes, and/or renames files in the directory
to restore the state described in the manifest.
The program should only perform file operations when it needs to,
e.g.,
it should not delete a file and re-add it if the contents have not changed.</p>
</li>
<li>
<p>Write some tests for <code>from-to.js</code> using Mocha and <code>mock-fs</code>.</p>
</li>
</ol>
<h3 class="exercise">File history</h3>
<ol>
<li>
<p>Write a program called <code>file-history.js</code>
that takes the name of a file as a command-line argument
and displays the history of that file
by tracing it back in time through the available manifests.</p>
</li>
<li>
<p>Write tests for your program using Mocha and <code>mock-fs</code>.</p>
</li>
</ol>
<h3 class="exercise">Pre-commit hooks</h3>
<p>Modify <code>backup.js</code> to load and run a function called <code>preCommit</code> from a file called <code>pre-commit.js</code>
stored in the root directory of the files being backed up.
If <code>preCommit</code> returns <code>true</code>, the backup proceeds;
if it returns <code>false</code> or throws an exception,
no backup is created.</p>
</main>
<footer>
<div class="row">
<div class="left3">
<a href="../unit-test/"><em>&laquo; Unit Testing</em></a>
</div>
<div class="middle3">
<a href="../license/"><img class="footer" src="../../static/cc-by.svg" alt="License" /></a>
<a href="https://github.com/software-tools-in-javascript/stjs/"><img class="footer" src="../../static/github.svg" alt="Repository" /></a>
© 2020 <a href="../authors/">The Authors</a>
</div>
<div class="right3">
<a href="../data-table/"><em>Data Tables &raquo;</em></a>
</div>
</div>
</footer>
</body>
</html>
