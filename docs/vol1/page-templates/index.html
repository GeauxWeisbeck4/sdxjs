<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
  <title>Page Templates</title>
  <meta name="slug" content="page-templates">
  <meta name="toRoot" content="..">
  <link rel="shortcut icon" type="image/x-icon" href="../../favicon.ico">
  <link href="../../static/fonts.css" rel="stylesheet" type="text/css">
  <link href="../../static/site.css" rel="stylesheet" type="text/css">
  <link rel="shortcut icon" type="image/x-icon" href="../../favicon.ico">
  <link rel="alternate" type="application/atom+xml" title="Software Tools in JavaScript Volume 1: Tools" href="../../atom.xml">
  <script>const NUMBERING = {"vol1":"1","systems-programming":"2","async-programming":"3","unit-test":"4","file-backup":"5","data-table":"6","pattern-matching":"7","regex-parser":"8","page-templates":"9","build-manager":"10","layout-engine":"11","file-interpolator":"12","module-loader":"13","style-checker":"14","code-generator":"15","doc-generator":"16","module-bundler":"17","package-manager":"18","virtual-machine":"19","debugger":"20","conclusion":"21","bib":"A","license":"B","conduct":"C","contributing":"D","cognition":"E","gloss":"F","links":"G","authors":"H"}</script>
  <script src="../../static/site.js"></script>
  <script>window.onload = () => fixPage(true)</script>
</head>
<body id="_top">
<nav>
<div class="row">
<div class="left2">
<a href="../"><img src="../../static/logo.svg" alt="site logo" class="site-logo"/></a>
</div>
<div class="right2">
<span class="navtitle"><a href="../../blog/">Blog</a></span>
<div class="dropdown">
<span class="navtitle">▿ Sections</span>
<div class="dropdown-content" id="Sections">
</div>
</div>
<div class="dropdown">
<span class="navtitle">▿ Chapters</span>
<div class="dropdown-content" id="Chapters">
<a href="../systems-programming/"><span class="nowrap">Systems Programming</span></a>
<br/><a href="../async-programming/"><span class="nowrap">Asynchronous Programming</span></a>
<br/><a href="../unit-test/"><span class="nowrap">Unit Testing</span></a>
<br/><a href="../file-backup/"><span class="nowrap">File Backup</span></a>
<br/><a href="../data-table/"><span class="nowrap">Data Tables</span></a>
<br/><a href="../pattern-matching/"><span class="nowrap">Pattern Matching</span></a>
<br/><a href="../regex-parser/"><span class="nowrap">Parsing Expressions</span></a>
<br/><a href="../page-templates/"><span class="nowrap">Page Templates</span></a>
<br/><a href="../build-manager/"><span class="nowrap">Build Manager</span></a>
<br/><a href="../layout-engine/"><span class="nowrap">Layout Engine</span></a>
<br/><a href="../file-interpolator/"><span class="nowrap">File Interpolator</span></a>
<br/><a href="../module-loader/"><span class="nowrap">Module Loader</span></a>
<br/><a href="../style-checker/"><span class="nowrap">Style Checker</span></a>
<br/><a href="../code-generator/"><span class="nowrap">Code Generator</span></a>
<br/><a href="../doc-generator/"><span class="nowrap">Documentation Generator</span></a>
<br/><a href="../module-bundler/"><span class="nowrap">Module Bundler</span></a>
<br/><a href="../package-manager/"><span class="nowrap">Package Manager</span></a>
<br/><a href="../virtual-machine/"><span class="nowrap">Virtual Machine</span></a>
<br/><a href="../debugger/"><span class="nowrap">Debugger</span></a>
<br/><a href="../conclusion/"><span class="nowrap">Conclusion</span></a>
</div>
</div>
<div class="dropdown">
<span class="navtitle">▿ Appendices</span>
<div class="dropdown-content" id="Appendices">
<a href="../bib/"><span class="nowrap">Bibliography</span></a>
<br/><a href="../license/"><span class="nowrap">License</span></a>
<br/><a href="../conduct/"><span class="nowrap">Code of Conduct</span></a>
<br/><a href="../contributing/"><span class="nowrap">Contributing</span></a>
<br/><a href="../cognition/"><span class="nowrap">Cognition</span></a>
<br/><a href="../gloss/"><span class="nowrap">Glossary</span></a>
<br/><a href="../links/"><span class="nowrap">Links</span></a>
<br/><a href="../authors/"><span class="nowrap">Authors</span></a>
</div>
</div>
</div>
</div>
</nav>
  <main>
  <h1>Page Templates</h1>
  <h2 class="lede">Generating HTML pages from templates</h2>
<div class="callout">
  <h3 id="terms-defined">Terms defined</h3>
  <p><table><tbody><tr><td><g key="bare_object">bare object</g></td><td><g key="dom">Document Object Model (DOM)</g></td><td><g key="dynamic_scoping">dynamic scoping</g></td></td>
<tr><td><g key="environment">environment</g></td><td><g key="lexical_scoping">lexical scoping</g></td><td><g key="stack_frame">stack frame</g></td></td>
<tr><td><g key="visitor_pattern">Visitor pattern</g></td><td>&nbsp;</td><td>&nbsp;</td></td></tbody></table></p>
</div>
<p>Every program needs documentation in order to be usable,
and the best place to put that documentation is on the web.
Writing and updating pages by hand is time-consuming and error-prone,
particularly when so many of their parts are the same,
so most websites use some kind of tool to create HTML from templates.</p>
<p>Thousands of page templating systems have been written in the last thirty years
in every popular programming language
(and in fact one language, <a href="https://www.php.net/">PHP</a>, was created for this purpose).
Most of these systems use one of three designs
(<f key="page-templates-options"></f>):</p>
<ol>
<li>
<p>Mix commands in a language such as JavaScript with the HTML or Markdown
using some kind of marker to indicate which parts are commands
and which parts are to be taken as-is.
This approach is taken by <a href="https://ejs.co/">EJS</a>,
which we have used to write these lessons.</p>
</li>
<li>
<p>Create a mini-language with its own commands like <a href="https://jekyllrb.com/">Jekyll</a>
(the templating system used by <a href="https://pages.github.com/">GitHub Pages</a>).
Mini-languages are appealing because they are smaller and safer than general-purpose languages,
but experience shows that they quickly grow many of the features
of a general-purpose language.
Again, some kind of marker must be used to show
which parts of the page are code and which are ordinary text.</p>
</li>
<li>
<p>Use specially-named attributes in the HTML.
This approach has been the least popular,
but eliminates the need for a special parser
(since pages are valid HTML).</p>
</li>
</ol>
<figure id="page-templates-options"><img src="./figures/options.svg" alt="Three options for page templates" latexscale="true"/><figcaption>Three different ways to implement page templating.</figcaption></figure>
<p>In this chapter we will build a simple page templating system using the third option.
We will process each page independently by parsing the HTML
and walking the <g key="dom">DOM</g> to find nodes with special attributes.
Our program will execute the instructions in those nodes
to do the equivalent of loops and if/else statements;
other nodes will be copied as-is to create text.</p>
<h2 id="what-will-our-system-look-like">What will our system look like?</h2>
<p>Let's start by deciding what &quot;done&quot; looks like.
Suppose we want to turn an array of strings into an HTML list.
Our page will look like this:</p>
<pre title="input-loop.html"><code class="language-html">&lt;html&gt;
  &lt;body&gt;
    &lt;p&gt;Expect three items&lt;/p&gt;
    &lt;ul q-loop="item:names"&gt;
      &lt;li&gt;&lt;span q-var="item"/&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<div class="continue">
<p>The attribute <code>q-loop</code> tells the tool to repeat that node;
the loop variable and the collection being looped over
are the attribute's value, separated by a colon.
The attribute <code>q-var</code> tells the tool to fill in the node with the value of the variable.
The output will look like HTML without any traces of how it was created:</p>
</div>
<pre title="output-loop.html"><code class="language-html">&lt;html&gt;
  &lt;body&gt;
    &lt;p&gt;Expect three items&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;span&gt;Johnson&lt;/span&gt;&lt;/li&gt;
    
      &lt;li&gt;&lt;span&gt;Vaughan&lt;/span&gt;&lt;/li&gt;
    
      &lt;li&gt;&lt;span&gt;Jackson&lt;/span&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<div class="callout">
<h3 id="humanreadable-vs-machinereadable">Human-readable vs. machine-readable</h3>
<p>The introduction said that mini-languages for page templating
quickly start to accumulate extra features.
We have already started down that road
by putting the loop variable and loop target in a single attribute
and parsing that attribute to get them out.
Doing that makes loop elements easier for people to type,
but means that important information is hidden from standard HTML processing tools,
which can't know that this particular attribute of these particular elements
contains multiple values
or that those values should be extracted by splitting a string on a colon.
We could instead require people to use two attributes, as in:</p>
<pre><code class="language-html">    &lt;ul q-loop=&quot;names&quot; q-loop-var=&quot;item&quot;&gt;
</code></pre>
</div>
<p>What about processing templates?
Our tool needs the template itself,
somewhere to write its output,
and some variables to use in the expansion.
These variables might come from a configuration file,
from a YAML header in the file itself,
or from some mix of the two;
for the moment,
all we need to know is that
we wil pass them into the expansion function as an object:</p>
<pre title="example-call.js"><code class="language-js">const variables = {
  names: ['Johnson', 'Vaughan', 'Jackson']
}
const dom = readHtml('template.html')
const expander = new Expander(dom, variables)
expander.walk()
console.log(expander.result)
</code></pre>
<h2 id="how-can-we-keep-track-of-values">How can we keep track of values?</h2>
<p>Speaking of variables,
we need a way to keep track of their current values:
&quot;current&quot;, because the value of a loop variable changes each time we go around the loop.
We also need to maintain multiple sets of variables
so that we can nest loops.</p>
<p>The standard solution is to create a stack of lookup tables.
Each <g key="stack_frame">stack frame</g> is an object with names and values;
when we need to find a variable,
we look through the stack frames in order to find the uppermost definition of that variable..</p>
<div class="callout">
<h3 id="scoping-rules">Scoping rules</h3>
<p>Searching the stack frame by frame is called is <g key="dynamic_scoping">dynamic scoping</g>,
since we find variables while the program is running.
In contrast,
most programming languages used <g key="lexical_scoping">lexical scoping</g>,
which figures out what a variable name refers to based on the structure of the program text.</p>
</div>
<p>The values in a running program are sometimes called an <g key="environment">environment</g>,
so we have named our stack-handling class <code>Env</code>.
Its methods let us push and pop new stack frames
and find a variable given its name;
if the variable can't be found,
<code>Env.find</code> returns <code>undefined</code> instead of throwing an exception
(<f key="page-templates-stack"></f>).</p>
<pre title="env.js"><code class="language-js">class Env {
  constructor (initial) {
    this.stack = []
    this.push(Object.assign({}, initial))
  }

  push (frame) {
    this.stack.push(frame)
  }

  pop () {
    this.stack.pop()
  }

  find (name) {
    for (let i = this.stack.length - 1; i &gt;= 0; i--) {
      if (name in this.stack[i]) {
        return this.stack[i][name]
      }
    }
    return undefined
  }

  toString () {
    return JSON.stringify(this.stack)
  }
}

export default Env
</code></pre>
<figure id="page-templates-stack"><img src="./figures/stack.svg" alt="Variable stack" latexscale="true"/><figcaption>Using a stack to manage variables.</figcaption></figure>
<h2 id="how-do-we-handle-nodes">How do we handle nodes?</h2>
<p>HTML pages have a nested structure,
so we will process them using the <g key="visitor_pattern">Visitor pattern</g>.
<code>Visitor</code>'s constructor takes the root node of the DOM tree as an argument and saves it.
When we call <code>Visitor.walk</code> without a value,
it starts recursing from that saved root;
if <code>.walk</code> is given a value (as it is during recursive calls),
it uses that instead.</p>
<pre title="visitor.js"><code class="language-js">import assert from 'assert'

class Visitor {
  constructor (root) {
    this.root = root
  }

  walk (node = null) {
    if (node === null) {
      node = this.root
    }
    if (this.open(node)) {
      node.children.forEach(child =&gt; {
        this.walk(child)
      })
    }
    this.close(node)
  }

  open (node) {
    assert(false,
      'Must implemented "open"')
  }

  close (node) {
    assert(false,
      'Must implemented "close"')
  }
}

export default Visitor
</code></pre>
<div class="continue">
<p><code>Visitor</code> defines two methods called <code>open</code> and <code>close</code> that are called
when we first arrive at a node and when we are finished with it
(<f key="page-templates-visitor"></f>).
The default implementations throw exceptions
so that the creators of derived classes must remember to implement their own versions.</p>
</div>
<figure id="page-templates-visitor"><img src="./figures/visitor.svg" alt="The Visitor pattern" latexscale="true"/><figcaption>Using the Visitor pattern to evaluate a page template.</figcaption></figure>
<p>The <code>Expander</code> class is a <code>Visitor</code> and uses an <code>Env</code>.
It loads a handler for each type of special node we support---we will write these in a moment---and
uses them to process each type of node:</p>
<ol>
<li>
<p>If the node is plain text, copy it to the output.</p>
</li>
<li>
<p>If there is a handler for the node, call the handler's <code>open</code> or <code>close</code> method.</p>
</li>
<li>
<p>Otherwise, open or close a regular tag.</p>
</li>
</ol>
<pre title="expander.js"><code class="language-js">import assert from 'assert'

import Visitor from './visitor.js'
import Env from './env.js'

import q_if from './q-if.js'
import q_loop from './q-loop.js'
import q_num from './q-num.js'
import q_var from './q-var.js'

const HANDLERS = {
  'q-if': q_if,
  'q-loop': q_loop,
  'q-num': q_num,
  'q-var': q_var
}

class Expander extends Visitor {
  constructor (root, vars) {
    super(root)
    this.env = new Env(vars)
    this.handlers = HANDLERS
    this.result = []
  }

  open (node) {
    if (node.type === 'text') {
      this.output(node.data)
      return false
    } else if (this.hasHandler(node)) {
      return this.getHandler(node).open(this, node)
    } else {
      this.showTag(node, false)
      return true
    }
  }

  close (node) {
    if (node.type === 'text') {
      return
    }
    if (this.hasHandler(node)) {
      this.getHandler(node).close(this, node)
    } else {
      this.showTag(node, true)
    }
  }
...
}

export default Expander
</code></pre>
<p>Checking to see if there is a handler for a particular node
and getting that handler are straightforward:</p>
<pre title="expander.js"><code class="language-js">  hasHandler (node) {
    for (const name in node.attribs) {
      if (name in this.handlers) {
        return true
      }
    }
    return false
  }

  getHandler (node) {
    const possible = Object.keys(node.attribs)
      .filter(name =&gt; name in this.handlers)
    assert(possible.length === 1,
      'Should be exactly one handler')
    return this.handlers[possible[0]]
  }</code></pre>
<p>Finally, we need a few helper methods to show tags and generate output:</p>
<pre title="expander.js"><code class="language-js">  showTag (node, closing) {
    if (closing) {
      this.output(`&lt;/${node.name}&gt;`)
      return
    }

    this.output(`&lt;${node.name}`)
    for (const name in node.attribs) {
      if (!name.startsWith('q-')) {
        this.output(` ${name}="${node.attribs[name]}"`)
      }
    }
    this.output('&gt;')
  }

  output (text) {
    this.result.push((text === undefined) ? 'UNDEF' : text)
  }

  getResult () {
    return this.result.join('')
  }</code></pre>
<div class="continue">
<p>Notice that this class adds strings to an array and then joins them all right at the end
rather than concatenating strings repeatedly.
Doing this is more efficient and also helps with debugging,
since each string in the array corresponds to a single method call.</p>
</div>
<h2 id="how-do-we-implement-node-handlers">How do we implement node handlers?</h2>
<p>So far we have built a lot of infrastructure but haven't actually processed a single special node.
To do that,
let's start with a handler that copies a constant number into the output:</p>
<pre title="q-num.js"><code class="language-js">export default {
  open: (expander, node) =&gt; {
    expander.showTag(node, false)
    expander.output(node.attribs['q-num'])
  },

  close: (expander, node) =&gt; {
    expander.showTag(node, true)
  }
}
</code></pre>
<div class="continue">
<p>When we enter a node like <code>&lt;span q-num=&quot;123&quot;/&gt;</code>,
this handler prints an opening tag
and then copies the value of the <code>q-num</code> attribute to the output.
When we are exiting the node,
the handler closes the tag.</p>
</div>
<p>Note that this is <em>not</em> a class,
but instead an object with two functions stored under the keys <code>open</code> and <code>close</code>.
We could (and probably should) use a class for each handler
so that handlers can store any extra state they need,
but <g key="bare_object">bare objects</g> are still often used in JavaScript.</p>
<p>So much for constants; what about variables?</p>
<pre title="q-var.js"><code class="language-js">export default {
  open: (expander, node) =&gt; {
    expander.showTag(node, false)
    expander.output(expander.env.find(node.attribs['q-var']))
  },

  close: (expander, node) =&gt; {
    expander.showTag(node, true)
  }
}
</code></pre>
<div class="continue">
<p>This code is almost the same as the previous example;
the only difference is that instead of copying the attribute value directly to the output,
we use the attribute value as a key to look up a value in the environment.</p>
</div>
<p>These two pairs of handlers look plausible, but do they work?
To find out,
we can build a program that loads variable definitions from a JSON file,
reads an HTML template,
and does the expansion:</p>
<pre title="template.js"><code class="language-js">import fs from 'fs'
import htmlparser2 from 'htmlparser2'

import Expander from './expander.js'

const main = () =&gt; {
  const vars = readJSON(process.argv[2])
  const doc = readHtml(process.argv[3])
  const expander = new Expander(doc, vars)
  expander.walk()
  console.log(expander.getResult())
}

const readJSON = (filename) =&gt; {
  const text = fs.readFileSync(filename, 'utf-8')
  return JSON.parse(text)
}

const readHtml = (filename) =&gt; {
  const text = fs.readFileSync(filename, 'utf-8')
  return htmlparser2.parseDOM(text)[0]
}

main()
</code></pre>
<p>As we were writing this chapter,
we added new variables for our test cases one by one.
To avoid repeating text repeatedly,
we show the entire set once:</p>
<pre title="vars.json"><code class="language-json">{
  "firstVariable": "firstValue",
  "secondVariable": "secondValue",
  "variableName": "variableValue",
  "showThis": true,
  "doNotShowThis": false,
  "names": ["Johnson", "Vaughan", "Jackson"]
}
</code></pre>
<p>Our first test:
is static text copied over as-is?</p>
<pre title="input-static-text.html"><code class="language-html">&lt;html&gt;
  &lt;body&gt;
    &lt;h1&gt;Only Static Text&lt;/h1&gt;
    &lt;p&gt;This document only contains:&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;static&lt;/li&gt;
      &lt;li&gt;text&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre title="static-text.sh"><code class="language-sh">node template.js vars.json input-static-text.html
</code></pre>
<pre title="output-static-text.html"><code class="language-html">&lt;html&gt;
  &lt;body&gt;
    &lt;h1&gt;Only Static Text&lt;/h1&gt;
    &lt;p&gt;This document only contains:&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;static&lt;/li&gt;
      &lt;li&gt;text&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<figure id="page-templates-output-static-text"><img src="./figures/output-static-text.svg" alt="Generating static text" latexscale="false"/><figcaption>Static text generated by page templates.</figcaption></figure>
<p>Good.
Now, does the expander handle constants?</p>
<pre title="input-single-constant.html"><code class="language-html">&lt;html&gt;
  &lt;body&gt;
    &lt;p&gt;&lt;span q-num="123"/&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre title="output-single-constant.html"><code class="language-html">&lt;html&gt;
  &lt;body&gt;
    &lt;p&gt;&lt;span&gt;123&lt;/span&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<figure id="page-templates-output-single-constant"><img src="./figures/output-single-constant.svg" alt="Generating a single constant" latexscale="false"/><figcaption>A single constant generated by page templates.</figcaption></figure>
<p>What about a single variable?</p>
<pre title="input-single-variable.html"><code class="language-html">&lt;html&gt;
  &lt;body&gt;
    &lt;p&gt;&lt;span q-var="variableName"/&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre title="output-single-variable.html"><code class="language-html">&lt;html&gt;
  &lt;body&gt;
    &lt;p&gt;&lt;span&gt;variableValue&lt;/span&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<figure id="page-templates-output-single-variable"><img src="./figures/output-single-variable.svg" alt="Generating a single variable" latexscale="false"/><figcaption>A single variable generated by page templates.</figcaption></figure>
<p>What about a page containing multiple variables?
There's no reason it should fail if the single-variable case works,
but variable lookup is one of the more complicated parts of our processing,
so we should check:</p>
<pre title="input-multiple-variables.html"><code class="language-html">&lt;html&gt;
  &lt;body&gt;
    &lt;p&gt;&lt;span q-var="firstVariable" /&gt;&lt;/p&gt;
    &lt;p&gt;&lt;span q-var="secondVariable" /&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre title="output-multiple-variables.html"><code class="language-html">&lt;html&gt;
  &lt;body&gt;
    &lt;p&gt;&lt;span&gt;firstValue&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;&lt;span&gt;secondValue&lt;/span&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<figure id="page-templates-output-multiple-variables"><img src="./figures/output-multiple-variables.svg" alt="Generating multiple variables" latexscale="false"/><figcaption>Multiple variables generated by page templates.</figcaption></figure>
<h2 id="how-can-we-implement-control-flow">How can we implement control flow?</h2>
<p>Our tool supports two types of control flow:
conditional expressions and loops.
Since we don't support Boolean expressions like <code>and</code> and <code>or</code>,
implementing a conditional is as simple as looking up a variable
(which we know how to do)
and then expanding the node if the value is true:</p>
<pre title="q-if.js"><code class="language-js">export default {
  open: (expander, node) =&gt; {
    const doRest = expander.env.find(node.attribs['q-if'])
    if (doRest) {
      expander.showTag(node, false)
    }
    return doRest
  },

  close: (expander, node) =&gt; {
    if (expander.env.find(node.attribs['q-if'])) {
      expander.showTag(node, true)
    }
  }
}
</code></pre>
<p>Let's test it:</p>
<pre title="input-conditional.html"><code class="language-html">&lt;html&gt;
  &lt;body&gt;
    &lt;p q-if="showThis"&gt;This should be shown.&lt;/p&gt;
    &lt;p q-if="doNotShowThis"&gt;This should &lt;em&gt;not&lt;/em&gt; be shown.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre title="output-conditional.html"><code class="language-html">&lt;html&gt;
  &lt;body&gt;
    &lt;p&gt;This should be shown.&lt;/p&gt;
    
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<figure id="page-templates-output-conditional"><img src="./figures/output-conditional.svg" alt="Generating conditional text" latexscale="false"/><figcaption>Conditional text generated by page templates.</figcaption></figure>
<p>And finally we come to loops.
For these,
we need to get the array we're looping over from the environment
and do something once for each of its elements.
That &quot;something&quot; is:</p>
<ol>
<li>
<p>Create a new stack frame holding the current value of the loop variable.</p>
</li>
<li>
<p>Expand all of the node's children with that stack frame in place.</p>
</li>
<li>
<p>Pop the stack frame to get rid of the temporary variable.</p>
</li>
</ol>
<pre title="q-loop.js"><code class="language-js">export default {
  open: (expander, node) =&gt; {
    const [indexName, targetName] = node.attribs['q-loop'].split(':')
    delete node.attribs['q-loop']
    expander.showTag(node, false)
    const target = expander.env.find(targetName)
    for (const index of target) {
      expander.env.push({ [indexName]: index })
      node.children.forEach(child =&gt; expander.walk(child))
      expander.env.pop()
    }
    return false
  },

  close: (expander, node) =&gt; {
    expander.showTag(node, true)
  }
}
</code></pre>
<p>Once again,
it's not done until we test it:</p>
<pre title="input-loop.html"><code class="language-html">&lt;html&gt;
  &lt;body&gt;
    &lt;p&gt;Expect three items&lt;/p&gt;
    &lt;ul q-loop="item:names"&gt;
      &lt;li&gt;&lt;span q-var="item"/&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre title="output-loop.html"><code class="language-html">&lt;html&gt;
  &lt;body&gt;
    &lt;p&gt;Expect three items&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;span&gt;Johnson&lt;/span&gt;&lt;/li&gt;
    
      &lt;li&gt;&lt;span&gt;Vaughan&lt;/span&gt;&lt;/li&gt;
    
      &lt;li&gt;&lt;span&gt;Jackson&lt;/span&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<figure id="page-templates-output-loop"><img src="./figures/output-loop.svg" alt="Generating text with a loop" latexscale="false"/><figcaption>Repeated text generated with a loop by page templates.</figcaption></figure>
<p>Notice how we create the new stack frame using:</p>
<pre><code class="language-js">{ [indexName]: index }
</code></pre>
<div class="continue">
<p>This is an ugly but useful trick.
We can't write:</p>
</div>
<pre><code class="language-js">{ indexName: index }
</code></pre>
<div class="continue">
<p>because that would create an object with the string <code>indexName</code> as a key,
rather than one with the value of the variable <code>indexName</code> as its key.
We can't do this either:</p>
</div>
<pre><code class="language-js">{ `${indexName}`: index }
</code></pre>
<div class="continue">
<p>though it seems like we should be able to.
Instead,
we create an array containing the string we want.
JavaScript automatically converts arrays to strings by concatenating their elements when it needs to,
so our expression is a quick way to get the same effect as:</p>
</div>
<pre><code class="language-js">const temp = {}
temp[indexName] = index
expander.env.push(temp)
</code></pre>
<h2 id="how-did-we-know-how-to-do-all-of-this">How did we know how to do all of this?</h2>
<p>We have just implemented a simple programming language.
It can't do arithmetic,
but if we wanted to add tags like:</p>
<pre><code class="language-js">&lt;span q-math=&quot;+&quot;&gt;&lt;span q-var=&quot;width&quot;/&gt;&lt;span q-num=&quot;1&quot;/&gt;&lt;/span&gt;
</code></pre>
<div class="continue">
<p>we could.
It's unlikely anyone would use the result---typing all of that
is so much clumsier than typing <code>width+1</code> that people wouldn't use it
unless they had no other choice---but the basic design is there.</p>
</div>
<p>We didn't invent any of this from scratch,
any more than we invented the parsing algorithm of <x key="regex-parser"></x>.
Instead,
we did what you are doing now:
we read what other programmers had written
and tried to make sense of the key ideas.</p>
<h2 id="exercises">Exercises</h2>
<h3 class="exercise">Tracing execution</h3>
<p>Add a directive <code>&lt;span q-trace=&quot;variable&quot;/&gt;</code>
that prints the current value of a variable using <code>console.error</code> for debugging.</p>
<h3 class="exercise">Unit tests</h3>
<p>Write unit tests for template expansion using Mocha.</p>
<h3 class="exercise">Trimming text</h3>
<p>Modify all of the directives to take an extra optional attribute <code>q-trim=&quot;true&quot;</code>
If this attribute is set,
leading and trailing whitespace is trimmed from the directive's expansion.</p>
<h3 class="exercise">Literal text</h3>
<p>Add a directive <code>&lt;div q-literal=&quot;true&quot;&gt;…&lt;/div&gt;</code> that copies the enclosed text as-is
without interpreting or expanding any contained directives.
(A directive like this would be needed when writing documentation for the template expander.)</p>
<h3 class="exercise">Including other files</h3>
<ol>
<li>
<p>Add a directive <code>&lt;div q-include=&quot;filename.html&quot;/&gt;</code> that includes another file
in the file being processed.</p>
</li>
<li>
<p>Should included files be processed and the result copied into the including file,
or should the text be copied in and then processed?
What difference does it make to the way variables are evaluated?</p>
</li>
</ol>
<h3 class="exercise">HTML snippets</h3>
<p>Add a directive <code>&lt;div q-snippet=&quot;variable&quot;&gt;…&lt;/div&gt;</code> that saves some text in a variable
so that it can be displayed later.
For example:</p>
<pre><code class="language-html">&lt;html&gt;
  &lt;body&gt;
    &lt;div q-snippet=&quot;prefix&quot;&gt;&lt;strong&gt;Important:&lt;/strong&gt;&lt;/div&gt;
    &lt;p&gt;Expect three items&lt;/p&gt;
    &lt;ul&gt;
      &lt;li q-loop=&quot;item:names&quot;&gt;
        &lt;span q-var=&quot;prefix&quot;&gt;&lt;span q-var=&quot;item&quot;/&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<div class="continue">
<p>would printed the word &quot;Important:&quot; in bold before each item in the list.</p>
</div>
<h3 class="exercise">YAML headers</h3>
<p>Modify the template expander to handle variables defined in a YAML header in the page being processed.
For example, if the page is:</p>
<pre><code class="language-html">---
name: &quot;Dorothy Johnson Vaughan&quot;
---
&lt;html&gt;
  &lt;body&gt;
    &lt;p&gt;&lt;span q-var=&quot;name&quot;/&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<div class="continue">
<p>will create a paragraph containing the given name.</p>
</div>
<h3 class="exercise">Expanding all files</h3>
<p>Write a program <code>expand-all.js</code> that takes two directory names as command-line arguments
and builds a website in the second directory by expanding all of the HTML files found in the first
or in sub-directories of the first.</p>
<h3 class="exercise">Counting loops</h3>
<p>Add a directive <code>&lt;div q-index=&quot;indexName&quot; q-limit=&quot;limitName&quot;&gt;…&lt;/div&gt;</code>
that loops from zero to the value in the variable <code>limitName</code>,
putting the current iteration index in <code>indexName</code>.</p>
<h3 class="exercise">Auxiliary functions</h3>
<ol>
<li>
<p>Modify <code>Expander</code> so that it takes an extra argument <code>auxiliaries</code>
containing zero or more named functions:</p>
<pre><code class="language-js">const expander = new Expander(root, vars, {
  max: Math.max,
  trim: (x) =&gt; x.trim()
})
</code></pre>
</li>
<li>
<p>Add a directive <code>&lt;span q-call=&quot;functionName&quot; q-args=&quot;var,var&quot;/&gt;</code>
that looks up a function in <code>auxiliaries</code> and calls it
with the given variables as arguments.</p>
</li>
</ol>
</main>
<footer>
<div class="row">
<div class="left3">
<a href="../regex-parser/"><em>&laquo; Parsing Expressions</em></a>
</div>
<div class="middle3">
<a href="../license/"><img class="footer" src="../../static/cc-by.svg" alt="License" /></a>
<a href="https://github.com/software-tools-in-javascript/stjs/"><img class="footer" src="../../static/github.svg" alt="Repository" /></a>
<a href="mailto:info@stjs.tech"><img class="footer" src="../../static/email.svg" alt="Email" /></a>
© 2020 <a href="../authors/">The Authors</a>
</div>
<div class="right3">
<a href="../build-manager/"><em>Build Manager &raquo;</em></a>
</div>
</div>
</footer>
</body>
</html>
