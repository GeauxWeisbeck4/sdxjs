<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
  <title>Systems Programming</title>
  <meta name="slug" content="systems-programming">
  <meta name="toRoot" content="..">
  <link rel="shortcut icon" type="image/x-icon" href="../../favicon.ico">
  <link href="../../static/fonts.css" rel="stylesheet" type="text/css">
  <link href="../../static/site.css" rel="stylesheet" type="text/css">
  <script>const NUMBERING = {"vol1":"1","systems-programming":"2","async-programming":"3","unit-test":"4","file-backup":"5","data-table":"6","pattern-matching":"7","regex-parser":"8","page-templates":"9","build-manager":"10","layout-engine":"11","text-editor":"12","file-interpolator":"13","module-loader":"14","module-bundler":"15","package-manager":"16","style-checker":"17","code-generator":"18","doc-generator":"19","virtual-machine":"20","debugger":"21","conclusion":"22","bib":"A","license":"B","conduct":"C","contributing":"D","cognition":"E","gloss":"F","links":"G","authors":"H"}</script>
  <script src="../../static/site.js"></script>
  <script>window.onload = () => fixPage()</script>
</head>
<body id="_top">
<nav>
<div class="row">
<div class="left2">
<a href="../"><img src="../../static/logo.svg" alt="site logo" class="site-logo"/></a>
</div>
<div class="right2">
<div class="dropdown">
<span class="navtitle">▿ Sections</span>
<div class="dropdown-content" id="Sections">
</div>
</div>
<div class="dropdown">
<span class="navtitle">▿ Chapters</span>
<div class="dropdown-content" id="Chapters">
<a href="../systems-programming/"><span class="nowrap">Systems Programming</span></a>
<br/><a href="../async-programming/"><span class="nowrap">Asynchronous Programming</span></a>
<br/><a href="../unit-test/"><span class="nowrap">Unit Testing</span></a>
<br/><a href="../file-backup/"><span class="nowrap">File Backup</span></a>
<br/><a href="../data-table/"><span class="nowrap">Data Tables</span></a>
<br/><a href="../pattern-matching/"><span class="nowrap">Pattern Matching</span></a>
<br/><a href="../regex-parser/"><span class="nowrap">Parsing Expressions</span></a>
<br/><a href="../page-templates/"><span class="nowrap">Page Templates</span></a>
<br/><a href="../build-manager/"><span class="nowrap">Build Manager</span></a>
<br/><a href="../layout-engine/"><span class="nowrap">Layout Engine</span></a>
<br/><a href="../text-editor/"><span class="nowrap">Text Editor</span></a>
<br/><a href="../file-interpolator/"><span class="nowrap">File Interpolator</span></a>
<br/><a href="../module-loader/"><span class="nowrap">Module Loader</span></a>
<br/><a href="../module-bundler/"><span class="nowrap">Module Bundler</span></a>
<br/><a href="../package-manager/"><span class="nowrap">Package Manager</span></a>
<br/><a href="../style-checker/"><span class="nowrap">Style Checker</span></a>
<br/><a href="../code-generator/"><span class="nowrap">Code Generator</span></a>
<br/><a href="../doc-generator/"><span class="nowrap">Documentation Generator</span></a>
<br/><a href="../virtual-machine/"><span class="nowrap">Virtual Machine</span></a>
<br/><a href="../debugger/"><span class="nowrap">Debugger</span></a>
<br/><a href="../conclusion/"><span class="nowrap">Conclusion</span></a>
</div>
</div>
<div class="dropdown">
<span class="navtitle">▿ Appendices</span>
<div class="dropdown-content" id="Appendices">
<a href="../bib/"><span class="nowrap">Bibliography</span></a>
<br/><a href="../license/"><span class="nowrap">License</span></a>
<br/><a href="../conduct/"><span class="nowrap">Code of Conduct</span></a>
<br/><a href="../contributing/"><span class="nowrap">Contributing</span></a>
<br/><a href="../cognition/"><span class="nowrap">Cognition</span></a>
<br/><a href="../gloss/"><span class="nowrap">Glossary</span></a>
<br/><a href="../links/"><span class="nowrap">Links</span></a>
<br/><a href="../authors/"><span class="nowrap">Authors</span></a>
</div>
</div>
</div>
</div>
</nav>
  <main>
  <h1>Systems Programming</h1>
  <h2 class="lede">Using callbacks to manipulate files and directories</h2>
<div class="callout">
  <p>Terms defined: <g key="anonymous_function">anonymous function</g>, <g key="asynchronous">asynchronous</g>, <g key="boolean">Boolean</g>, <g key="callback">callback function</g>, <g key="callback">callback function</g>, <g key="cognitive_load">cognitive load</g>, <g key="command_line_argument">command-line argument</g>, <g key="console">console</g>, <g key="current_working_directory">current working directory</g>, <g key="destructuring_assignment">destructuring assignment</g>, <g key="edge_case">edge case</g>, <g key="filesystem">filesystem</g>, <g key="filter">filter</g>, <g key="globbing">globbing</g>, <g key="idiomatic">idiomatic</g>, <g key="log_message">log message</g>, <g key="path">path (in filesystem)</g>, <g key="promise">promise</g>, <g key="protocol">protocol</g>, <g key="scope">scope</g>, <g key="single_threaded">single-threaded</g>, <g key="string_interpolation">string interpolation</g></p>
</div>
<p>The biggest difference between JavaScript and most other programming languages
is that many operations in JavaScript are <g key="asynchronous">asynchronous</g>.
Its designers didn't want browsers to freeze while waiting for data to arrive or for users to click on things,
so operations that might be slow are implemented by describing <em>now</em> what to do <em>later</em>.
And since anything that touches the hard drive is slow from a processor's point of view,
<a href="https://nodejs.org/en/">Node</a> implements <g key="filesystem">filesystem</g> operations the same way.</p>
<p>Early JavaScript programs used <g key="callback">callback functions</g> to describe asynchronous operations,
but callbacks can be hard to understand even in small programs.
In 2015,
the language's maintainers standardized a higher-level tool called <g key="promise">promises</g>
to make callbacks a little easier to manage,
and more recently they have added some new keywords called <code>async</code> and <code>await</code> to make it easier still.
We need to understand all three layers in order to debug things when they go wrong,
so this chapter explores callbacks,
while <xref key="async-programming"></xref> shows how promises and <code>async</code>/<code>await</code> work.
This chapter also shows how to read and write files and directories with <a href="https://nodejs.org/en/">Node</a>'s standard libraries,
because we're going to be doing that a lot.</p>
<h2 id="how-can-we-list-a-directory">How can we list a directory?</h2>
<p>To start,
let's try listing the contents of a directory the way we would in Python or Java:</p>
<pre title="list-dir-wrong.js"><code class="language-js">import fs from 'fs'

const srcDir = process.argv[2]
const results = fs.readdir(srcDir)
for (const name of results) {
  console.log(name)
}
</code></pre>
<div class="continue">
<p>We use <code>import <em>module</em> from 'source'</code> to load the library <code><em>source</em></code>
and assign its contents to <code><em>module</em></code>.
After that,
we can refer to things in the library using <code><em>module.component</em></code>
just as we refer to things in any other object.
We can use whatever name we want for the module,
which allows us to give short nicknames to libraries with long names;
we will take advantage of this in future chapters.</p>
</div>
<div class="callout">
<h3 id="require-versus-import"><code>require</code> versus <code>import</code></h3>
<p>In 2015, a new version of JavaScript called ES6 introduced the keyword <code>import</code> for importing modules.
It improves on the older <code>require</code> method in several ways,
but <a href="https://nodejs.org/en/">Node</a> still uses <code>require</code> by default.
To tell it to use <code>import</code>,
we have added <code>&quot;type&quot;: &quot;module&quot;</code> at the top level of <a href="https://nodejs.org/en/">Node</a>'s <code>package.json</code> file.</p>
</div>
<p>Our little program uses the <a href="https://nodejs.org/api/fs.html"><code>fs</code></a> library
which contains functions to create directories, read or delete files, etc.
(Its name is short for &quot;filesystem&quot;.)
<a href="https://nodejs.org/en/">Node</a> automatically stores the program's <g key="command_line_argument">command-line arguments</g>
in an array called <code>process.argv</code>:
<code>process.argv[0]</code> is the name of the program used to run our code (in this case <code>node</code>),
while <code>process.argv[1]</code> is the name of our program (in this case <code>list-dir-wrong.js</code>).
The rest of <code>process.argv</code> holds whatever arguments we gave at the command line when we ran the program,
so <code>process.argv[2]</code> is the first argument after the name of our program:</p>
<figure class="fixme"><img src="/static/tools-small.jpg" alt="Command-line arguments in `process.argv`"/><figcaption id="systems-programming-process-argv">How Node stores command-line arguments in <code>process.argv</code>.</figcaption></figure>
<p>If we run this program with the name of a directory as its argument,
<code>fs.readdir</code> returns the names of the things in that directory as an array of strings.
The program then uses <code>for (const name of results)</code> to loop over the contents of that array.
We could use <code>let</code> instead of <code>const</code>,
but it's good practice to declare things as <code>const</code> wherever possible
so that anyone reading the program knows the variable isn't actually going to vary---doing
this reduces the <g key="cognitive_load">cognitive load</g> on people reading the program
(<xref key="cognition"></xref>).
Finally,
<code>console.log</code> is JavaScript's equivalent of other languages' <code>print</code> command;
its strange name comes from the fact that
its original purpose was to create <g key="log_message">log messages</g> in the browser <g key="console">console</g>.</p>
<p>Unfortunately,
our program doesn't work:</p>
<pre title="list-dir-wrong.sh"><code class="language-sh">node list-dir-wrong.js .
</code></pre>
<pre title="list-dir-wrong.out"><code class="language-out">internal/process/esm_loader.js:74
    internalBinding('errors').triggerUncaughtException(
                              ^

TypeError [ERR_INVALID_CALLBACK]: Callback must be a function. Received \
 undefined
    at makeCallback (fs.js:168:11)
    at Object.readdir (fs.js:994:14)
    at /u/stjs/systems-programming/list-dir-wrong.js:4:20
    at ModuleJob.run (internal/modules/esm/module_job.js:146:23)
    at async Loader.import (internal/modules/esm/loader.js:165:24)
    at async Object.loadESM (internal/process/esm_loader.js:68:5) {
  code: 'ERR_INVALID_CALLBACK'
}
</code></pre>
<div class="continue">
<p>The error message comes from something we didn't write whose source we would struggle to read.
If we look for the name of our file (<code>list-dir-wrong.js</code>)
we see the error occurred on line 4;
everything above that is inside <code>fs.readdir</code>,
while everything below it is <a href="https://nodejs.org/en/">Node</a> loading and running our program.</p>
</div>
<p>The problem is that <code>fs.readdir</code> doesn't return anything.
Instead,
<a href="https://nodejs.org/api/fs.html">its documentation</a> says that it takes a <g key="callback">callback function</g>,
so we need to explore those in order to make our program work.</p>
<h2 id="what-is-a-callback-function">What is a callback function?</h2>
<p>JavaScript uses a <g key="single_threaded">single-threaded</g> programming model:
as the introduction to this lesson said,
it divides operations like file I/O into &quot;please do this&quot; and &quot;do this when you're done&quot;.
<code>fs.readdir</code> is the first part,
but we need to write a function that specifies the second part.
JavaScript saves a reference to this function
and calls with a specific set of parameters when our data is ready.
Those parameters defined a standard <g key="protocol">protocol</g>
for connecting to libraries,
just like the USB standard allows us to plug hardware devices together.</p>
<figure class="fixme"><img src="/static/tools-small.jpg" alt="How callbacks work"/><figcaption id="systems-programming-callbacks">How JavaScript runs callback functions.</figcaption></figure>
<p>This corrected program gives <code>fs.readdir</code> a callback function called <code>listContents</code>:</p>
<pre title="list-dir-function-defined.js"><code class="language-js">import fs from 'fs'

const listContents = (err, files) =&gt; {
  console.log('running callback')
  if (err) {
    console.error(err)
  } else {
    for (const name of files) {
      console.log(name)
    }
  }
}

const srcDir = process.argv[2]
fs.readdir(srcDir, listContents)
console.log('last line of program')
</code></pre>
<div class="continue">
<p><a href="https://nodejs.org/en/">Node</a> callbacks always get an error (if there is any) as their first argument
and the result of a successful function call as their second.
The function can tell the difference by checking to see if the error argument is <code>null</code>.
If it is, the function lists the directory's contents with <code>console.log</code>,
otherwise, it uses <code>console.error</code> to display the error message.
Let's run the program with the <g key="current_working_directory">current working directory</g>
(written as '.')
as an argument:</p>
</div>
<pre title="list-dir-function-defined.sh"><code class="language-sh">node list-dir-function-defined.js .
</code></pre>
<pre title="list-dir-function-defined.slice.out"><code class="language-out">last line of program
running callback
Makefile
copy-file-filtered.js
copy-file-unfiltered.js
copy-file-unfiltered.out
copy-file-unfiltered.sh
copy-file-unfiltered.txt
glob-all-files.js
glob-all-files.slice.out
...
x-array-filter
x-counting-lines
x-destructuring-assignment
x-glob-patterns
x-rename-files
x-significant-entries
x-string-interpolation
x-trace-anonymous
x-trace-callback
x-where-is-node
</code></pre>
<p>Nothing in this book will make sense if we don't understand
the order in which [Node][node.js] executes the statements in this program:</p>
<ol>
<li>
<p>Read the program file.</p>
</li>
<li>
<p>Execute the first line to load the <code>fs</code> library.</p>
</li>
<li>
<p>Define a function of two parameters and assign it to <code>listContents</code>.
Remember, a function is just another kind of data.
Instead of being made up of numbers, characters, or pixels, it is made up of instructions,
but these are stored in memory like anything else.</p>
</li>
<li>
<p>Get the name of the directory from the command-line arguments.</p>
</li>
<li>
<p>Call <code>fs.readdir</code> to start a filesystem operation,
telling it what directory we want to read and what function to call when data is available.</p>
</li>
<li>
<p>Print a message to show we're at the end of the file.</p>
</li>
<li>
<p>Wait until the filesystem operation finishes (this step is invisible).</p>
</li>
<li>
<p>Run the callback function, which prints the directory listing.</p>
</li>
</ol>
<figure class="fixme"><img src="/static/tools-small.jpg" alt="Callback execution order"/><figcaption id="systems-programming-execution-order">When JavaScript runs callback functions.</figcaption></figure>
<h2 id="what-are-anonymous-functions">What are anonymous functions?</h2>
<p>Most programmers wouldn't define the function <code>listContents</code>
and then pass it as a callback.
Instead,
since the callback is only used in one place,
it is more <g key="idiomatic">idiomatic</g>
to define it where it is needed
as an <g key="anonymous_function">anonymous function</g>.
This makes it easier to see what's going to happen when the operation completes,
though it means the order of execution is quite different from the order of reading.
Using an anonymous function gives us the final version of our program:</p>
<pre title="list-dir-function-anonymous.js"><code class="language-js">import fs from 'fs'

const srcDir = process.argv[2]
fs.readdir(srcDir, (err, files) =&gt; {
  if (err) {
    console.error(err)
  } else {
    for (const name of files) {
      console.log(name)
    }
  }
})
</code></pre>
<figure class="fixme"><img src="/static/tools-small.jpg" alt="Anonymous functions as callbacks"/><figcaption id="systems-programming-anonymous-functions">How and when JavaScript creates and runs anonymous callback functions.</figcaption></figure>
<h2 id="how-can-we-select-a-set-of-files">How can we select a set of files?</h2>
<p>Suppose we want to copy some files instead of listing a directory's contents.
Depending on the situation
we might want to copy only those files given on the command line
or all files except some explicitly excluded.
What we <em>don't</em> want to have to do is list the files one by one;
instead,
we want to be able to write patterns like <code>*.js</code>.</p>
<p>To find files that match patterns like that,
we can use the <a href="https://www.npmjs.com/package/glob"><code>glob</code></a> module.
(To <g key="globbing">glob</g> (short for &quot;global&quot;) is an old Unix term for matching a set of files by name.)
The <code>glob</code> module provides a function that takes a pattern and a callback
and does something with every filename that matched the pattern:</p>
<pre title="glob-all-files.js"><code class="language-js">import glob from 'glob'

glob('**/*.*', (err, files) =&gt; {
  if (err) {
    console.log(err)
  } else {
    for (const filename of files) {
      console.log(filename)
    }
  }
})
</code></pre>
<pre title="glob-all-files.slice.out"><code class="language-out">copy-file-filtered.js
copy-file-unfiltered.js
copy-file-unfiltered.out
copy-file-unfiltered.sh
copy-file-unfiltered.txt
glob-all-files.js
glob-all-files.slice.out
glob-ensure-output-directory.js
glob-filter-with-options.js
glob-get-then-filter-idiomatic.js
...
x-string-interpolation/problem.md
x-string-interpolation/solution.md
x-trace-anonymous/problem.md
x-trace-anonymous/solution.md
x-trace-anonymous/trace.js
x-trace-callback/problem.md
x-trace-callback/solution.md
x-trace-callback/trace.js
x-where-is-node/problem.md
x-where-is-node/solution.md
</code></pre>
<p>The leading <code>**</code> means &quot;recurse into subdirectories&quot;;
the <code>*.*</code> means &quot;any characters followed by '.' followed by any characters&quot;.
Names that don't match <code>*.*</code> won't be included,
and by default,
neither are names that start with a '.' character.
(This is another old Unix convention:
files and directories whose names have a leading '.'
usually contain configuration information for various programs,
so most commands will leave them alone unless told to do otherwise.)</p>
<figure class="fixme"><img src="/static/tools-small.jpg" alt="Matching filenames with `glob`"/><figcaption id="systems-programming-globbing">Using <code>glob</code> patterns to match filenames.</figcaption></figure>
<p>This program works,
but we probably don't want to copy editor backup files whose names end with <code>~</code>.
We can get rid of them by <g key="filter">filtering</g> the list that <code>glob</code> returns:</p>
<pre title="glob-get-then-filter-pedantic.js"><code class="language-js">import glob from 'glob'

glob('**/*.*', (err, files) =&gt; {
  if (err) {
    console.log(err)
  } else {
    files = files.filter((f) =&gt; { return !f.endsWith('~') })
    for (const filename of files) {
      console.log(filename)
    }
  }
})
</code></pre>
<pre title="glob-get-then-filter-pedantic.slice.out"><code class="language-out">copy-file-filtered.js
copy-file-unfiltered.js
copy-file-unfiltered.out
copy-file-unfiltered.sh
copy-file-unfiltered.txt
glob-all-files.js
glob-all-files.slice.out
glob-ensure-output-directory.js
glob-filter-with-options.js
glob-get-then-filter-idiomatic.js
...
x-string-interpolation/problem.md
x-string-interpolation/solution.md
x-trace-anonymous/problem.md
x-trace-anonymous/solution.md
x-trace-anonymous/trace.js
x-trace-callback/problem.md
x-trace-callback/solution.md
x-trace-callback/trace.js
x-where-is-node/problem.md
x-where-is-node/solution.md
</code></pre>
<p><code>Array.filter</code> creates a new array containing all the items of the original array that pass a test.
The test is specified as a callback function
that runs once for each item and returns a <g key="boolean">Boolean</g>
that determines if the item is kept in the new array (<code>true</code>) or left out (<code>false</code>).
<code>Array.filter</code> does not modify the original array,
so we can filter our original list of filenames several times if we want to.</p>
<figure class="fixme"><img src="/static/tools-small.jpg" alt="Using `Array.filter`"/><figcaption id="systems-programming-array-filter">Selecting array elements using <code>Array.filter</code>.</figcaption></figure>
<p>We can make our globbing program more idiomatic by
removing the parentheses around the single parameter
and writing just the expression we want the function to return:</p>
<pre title="glob-get-then-filter-idiomatic.js"><code class="language-js">import glob from 'glob'

glob('**/*.*', (err, files) =&gt; {
  if (err) {
    console.log(err)
  } else {
    files = files.filter(f =&gt; !f.endsWith('~'))
    for (const filename of files) {
      console.log(filename)
    }
  }
})
</code></pre>
<p>However,
it turns out that <code>glob</code> will filter for us.
According to its documentation,
the function takes an <code>options</code> object full of key-value settings
that can control its behavior.
This is another common pattern in Node libraries and in our own code:
rather than accepting a large number of rarely-used parameters,
a function can take a single object full of settings.
If we use this,
our program becomes:</p>
<pre title="glob-filter-with-options.js"><code class="language-js">import glob from 'glob'

glob('**/*.*', { ignore: '*~' }, (err, files) =&gt; {
  if (err) {
    console.log(err)
  } else {
    for (const filename of files) {
      console.log(filename)
    }
  }
})
</code></pre>
<p>Notice that we don't quote the key in the <code>options</code> object.
The keys in objects are almost always strings,
and if a string is simple enough that it won't confuse the parser,
we don't need to put quotes around it.
Here,
&quot;simple enough&quot; means &quot;looks like it could be a variable name&quot;,
or equivalently &quot;contains only letters, digits, and the underscore&quot;.</p>
<div class="callout">
<h3 id="no-one-knows-everything">No one knows everything</h3>
<p>We combined <code>glob.glob</code> and <code>Array.filter</code> in our functions for more than a year
before someone pointed out the <code>ignore</code> option for <code>glob.glob</code>.
This shows:</p>
<ol>
<li>
<p>Life is short,
so most of us find a way to solve the problem in front of us
and re-use it rather than looking for something better.</p>
</li>
<li>
<p>Code reviews aren't just about finding bugs:
they are also the most effective way to transfer knowledge between programmers.
Even if someone is much more experienced than you,
there's a good chance you might have stumbled over a better way to do something
than the one they're using (see point #1 above).</p>
</li>
</ol>
</div>
<p>To finish off our globbing program,
let's specify a source directory on the command line and include that in the pattern:</p>
<pre title="glob-with-source-directory.js"><code class="language-js">import glob from 'glob'

const srcDir = process.argv[2]

glob(`${srcDir}/**/*.*`, { ignore: '*~' }, (err, files) =&gt; {
  if (err) {
    console.log(err)
  } else {
    for (const filename of files) {
      console.log(filename)
    }
  }
})
</code></pre>
<div class="continue">
<p>This program uses <g key="string_interpolation">string interpolation</g>
to insert the value of <code>srcDir</code> into a string.
The template string is written in back quotes,
and we use <code>${expression}</code> to insert the value of an expression.
We could create the pattern by concatenating strings using
<code>srcDir + '/**/*.*'</code>,
but most programmers find the interpolating version easier to read.</p>
</div>
<h2 id="how-can-we-copy-a-set-of-files">How can we copy a set of files?</h2>
<p>We now have a way to create the <g key="path">paths</g> of the files we want to copy.
If our program takes a second argument that specifies the output directory to copy those files to,
it can construct the full output path by replacing the name of the source directory with the name of the output directory.</p>
<pre title="glob-with-dest-directory.js"><code class="language-js">import glob from 'glob'

const [srcDir, dstDir] = process.argv.slice(2)

glob(`${srcDir}/**/*.*`, { ignore: '*~' }, (err, files) =&gt; {
  if (err) {
    console.log(err)
  } else {
    for (const srcName of files) {
      const dstName = srcName.replace(srcDir, dstDir)
      console.log(srcName, dstName)
    }
  }
})
</code></pre>
<div class="continue">
<p>This programs uses <g key="destructuring_assignment">destructuring assignment</g> to create two variables at once
by unpacking the elements of an array.
It only works if the array contains enough elements,
i.e.,
if both a source and destination are given on the command line;
we'll add that in the exercises.</p>
</div>
<figure class="fixme"><img src="/static/tools-small.jpg" alt="Matching values with destructuring assignment"/><figcaption id="systems-programming-destructuring-assignment">Assigning many values at once by destructuring.</figcaption></figure>
<p>A more serious problem is that
this program only works if the destination directory already exists:
<code>fs</code> and equivalent libraries in other languages usually won't create directories for us automatically.
The need to do this comes up so often that there is a function called <code>ensureDir</code> to do what we need:</p>
<pre title="glob-ensure-output-directory.js"><code class="language-js">import glob from 'glob'
import fs from 'fs-extra'
import path from 'path'

const [srcRoot, dstRoot] = process.argv.slice(2)

glob(`${srcRoot}/**/*.*`, { ignore: '*~' }, (err, files) =&gt; {
  if (err) {
    console.log(err)
  } else {
    for (const srcName of files) {
      const dstName = srcName.replace(srcRoot, dstRoot)
      const dstDir = path.dirname(dstName)
      fs.ensureDir(dstDir, (err) =&gt; {
        if (err) {
          console.error(err)
        }
      })
    }
  }
})
</code></pre>
<p>Notice that we import from <code>fs-extra</code> instead of <code>fs</code>;
the <a href="https://www.npmjs.com/package/fs-extra"><code>fs-extra</code></a> module provides some useful utilities on top of <code>fs</code>.
We also use <a href="https://nodejs.org/api/path.html"><code>path</code></a> to manipulate pathnames
rather than concatenating or interpolating strings
because there are a lot of tricky <g key="edge_case">edge cases</g> in pathnames
that the authors of that module have figured out for us.</p>
<div class="callout">
<h3 id="using-distinct-names">Using distinct names</h3>
<p>We are now calling our command-line arguments <code>srcRoot</code> and <code>dstRoot</code>
rather than <code>srcDir</code> and <code>dstDir</code>.
As we were writing this example we used <code>dstDir</code> as both
the name of the top-level destination directory (from the command line)
and the name of the particular output directory to create.
JavaScript didn't complain because
every function creates a new <g key="scope">scope</g> for variable definitions,
and it's perfectly legal to give a variable inside a function
the same name as something outside it.
However, &quot;legal&quot; isn't the same thing as &quot;comprehensible&quot;;
giving the two variables different names makes the program easier for humans to read.</p>
</div>
<p>Our file copying program currently creates an empty tree of destination directories
but doesn't actually copy any files.
Let's add a call to <code>fs.copy</code> to do that:</p>
<pre title="copy-file-unfiltered.js"><code class="language-js">import glob from 'glob'
import fs from 'fs-extra'
import path from 'path'

const [srcRoot, dstRoot] = process.argv.slice(2)

glob(`${srcRoot}/**/*.*`, { ignore: '*~' }, (err, files) =&gt; {
  if (err) {
    console.log(err)
  } else {
    for (const srcName of files) {
      const dstName = srcName.replace(srcRoot, dstRoot)
      const dstDir = path.dirname(dstName)
      fs.ensureDir(dstDir, (err) =&gt; {
        if (err) {
          console.error(err)
        } else {
          fs.copy(srcName, dstName, (err) =&gt; {
            if (err) {
              console.error(err)
            }
          })
        }
      })
    }
  }
})
</code></pre>
<p>The program now has three levels of callback:</p>
<ol>
<li>
<p>When <code>glob</code> has data, do things and then call <code>ensureDir</code>.</p>
</li>
<li>
<p>When <code>ensureDir</code> completes, copy a file.</p>
</li>
<li>
<p>When <code>copy</code> finishes, check the error status.</p>
</li>
</ol>
<figure class="fixme"><img src="/static/tools-small.jpg" alt="Three levels of callback"/><figcaption id="systems-programming-triple-callback">Three levels of callback in the running example.</figcaption></figure>
<p>Our program looks like it should work,
but if we try to copy everything in the directory containing these lessons
we get an error message:</p>
<pre title="copy-file-unfiltered.sh"><code class="language-sh">rm -rf /tmp/out
mkdir /tmp/out
node copy-file-unfiltered.js ../node_modules /tmp/out 2&gt;&amp;1 | head -n 6
</code></pre>
<pre title="copy-file-unfiltered.out"><code class="language-out">[Error: ENOENT: no such file or directory, chmod \
 '/tmp/out/@nodelib/fs.stat/package.json'] {
  errno: -2,
  code: 'ENOENT',
  syscall: 'chmod',
  path: '/tmp/out/@nodelib/fs.stat/package.json'
}
</code></pre>
<p>The problem is that <code>node_modules/fs.stat</code> and <code>node_modules/fs.walk</code> match our globbing expression,
but are directories rather than files.
To prevent our program from trying to use <code>fs.copy</code> on directories,
we must use <code>fs.stat</code> to get the properties of the thing whose name <code>glob</code> has given us
and then check if it's a file.
The name &quot;stat&quot; is short for &quot;status&quot;,
and since the status of something in the filesystem can be very complex,
<code>fs.stat</code> returns <a href="https://nodejs.org/api/fs.html#fs_class_fs_stats">an object with methods that can answer common questions</a>.</p>
<p>Here's the final version of our file copying program:</p>
<pre title="copy-file-filtered.js"><code class="language-js">import glob from 'glob'
import fs from 'fs-extra'
import path from 'path'

const [srcRoot, dstRoot] = process.argv.slice(2)

glob(`${srcRoot}/**/*.*`, { ignore: '*~' }, (err, files) =&gt; {
  if (err) {
    console.log(err)
  } else {
    for (const srcName of files) {
      fs.stat(srcName, (err, stats) =&gt; {
        if (err) {
          console.error(err)
        } else if (stats.isFile()) {
          const dstName = srcName.replace(srcRoot, dstRoot)
          const dstDir = path.dirname(dstName)
          fs.ensureDir(dstDir, (err) =&gt; {
            if (err) {
              console.error(err)
            } else {
              fs.copy(srcName, dstName, (err) =&gt; {
                if (err) {
                  console.error(err)
                }
              })
            }
          })
        }
      })
    }
  }
})
</code></pre>
<div class="continue">
<p>It works,
but four levels of asynchronous callbacks is hard for humans to understand.
The <xref key="async-programming">next chapter</xref> will introduce a pair of tools
that make code like this easier to read.</p>
</div>
<h2 id="exercises">Exercises</h2>
<h3 class="exercise">Where is Node?</h3>
<p>Write a program called <code>wherenode.js</code> that prints the full path to the version of Node is is run with.</p>
<h3 class="exercise">Tracing callbacks</h3>
<p>In what order does the program below print messages?</p>
<pre title="x-trace-callback/trace.js"><code class="language-js">const red = () =&gt; {
  console.log('RED')
}

const green = (func) =&gt; {
  console.log('GREEN')
  func()
}

const blue = (left, right) =&gt; {
  console.log('BLUE')
  left(right)
}

blue(green, red)
</code></pre>
<h3 class="exercise">Tracing anonymous callbacks</h3>
<p>In what order does the program below print messages?</p>
<pre title="x-trace-anonymous/trace.js"><code class="language-js">const blue = (left, right) =&gt; {
  console.log('BLUE')
  left(right)
}

blue(
  (callback) =&gt; {
    console.log('GREEN')
    callback()
  },
  () =&gt; console.log('RED')
)
</code></pre>
<h3 class="exercise">Checking arguments</h3>
<p>Modify the file copying program to check that it has been given the right number of command-line arguments
and to print a sensible error message (including a usage statement) if it hasn't.</p>
<h3 class="exercise">Significant entries</h3>
<p><code>count-lines-histogram.js</code> displays many zeroes and gives no visual sense of how large entries are.
Modify it so that:</p>
<ol>
<li>
<p>When it is run with the <code>--nonzero</code> flag only non-zero values are shown.</p>
</li>
<li>
<p>When it is run with the <code>--graphical</code> flag the numeric values are replaced with rows of asterisks.</p>
</li>
<li>
<p>If both flags are given the program prints an error message instead of running.</p>
</li>
</ol>
<h3 class="exercise">Glob patterns</h3>
<p>What filenames does each of the following glob patterns match?</p>
<ul>
<li><code>results-[0123456789].csv</code></li>
<li><code>results.(tsv|csv)</code></li>
<li><code>results.dat?</code></li>
<li><code>./results.data</code></li>
</ul>
<h3 class="exercise">Filtering arrays</h3>
<p>Fill in the blank in the code below so that it runs correctly.
Note: you can compare strings in JavaScript using <code>&lt;</code>, <code>&gt;=</code>, and other operators,
so that (for example) <code>person.personal &gt; 'P'</code> is <code>true</code>
if someone's personal name starts with a letter that comes after 'P' in the alphabet.</p>
<pre title="x-array-filter/filter.js"><code class="language-js">const people = [
  { personal: 'Jean', family: 'Jennings' },
  { personal: 'Marlyn', family: 'Wescoff' },
  { personal: 'Ruth', family: 'Lichterman' },
  { personal: 'Betty', family: 'Snyder' },
  { personal: 'Frances', family: 'Bilas' },
  { personal: 'Kay', family: 'McNulty' }
]

const result = people.filter(____ =&gt; ____)

console.log(result)
</code></pre>
<pre title="x-array-filter/filter.txt"><code class="language-txt">[
  { personal: 'Jean', family: 'Jennings' },
  { personal: 'Ruth', family: 'Lichterman' },
  { personal: 'Frances', family: 'Bilas' }
]
</code></pre>
<h3 class="exercise">String interpolation</h3>
<p>Fill in the code below so that it prints the message shown.</p>
<pre title="x-string-interpolation/interpolate.js"><code class="language-js">const people = [
  { personal: 'Christine', family: 'Darden' },
  { personal: 'Mary', family: 'Jackson' },
  { personal: 'Katherine', family: 'Johnson' },
  { personal: 'Dorothy', family: 'Vaughan' }
]

for (const person of people) {
  console.log(`$____, $____`)
}
</code></pre>
<pre title="x-string-interpolation/interpolate.txt"><code class="language-txt">Darden, Christine
Jackson, Mary
Johnson, Katherine
Vaughan, Dorothy
</code></pre>
<h3 class="exercise">Destructuring assignment</h3>
<p>What is assigned to each named variable in each statement below?</p>
<ol>
<li><code>const first = [10, 20, 30]</code></li>
<li><code>const [first, second] = [10, 20, 30]</code></li>
<li><code>const [first, second, third] = [10, 20, 30]</code></li>
<li><code>const [first, second, third, fourth] = [10, 20, 30]</code></li>
<li><code>const {left, right} = {left: 10, right: 30}</code></li>
<li><code>const {left, middle, right} = {left: 10, middle: 20, right: 30}</code></li>
</ol>
<h3 class="exercise">Counting lines</h3>
<p>Write a program called <code>lc</code> that counts and reports the number of lines in one or more files and the total number of lines,
so that <code>lc a.txt b.txt</code> displays something like:</p>
<pre><code class="language-txt">a.txt 475
b.txt 31
total 506
</code></pre>
<h3 class="exercise">Renaming files</h3>
<p>Write a program called <code>rename</code> that takes three or more command-line arguments:</p>
<ol>
<li>A <g key="filename_extension">filename extension</g> to match.</li>
<li>An extension to replace it with.</li>
<li>The names of one or more existing files.</li>
</ol>
<p>When it runs,
<code>rename</code> renames any files with the first extension to create files with the second extension,
but will <em>not</em> overwrite an existing file.
For example,
suppose a directory contains <code>a.txt</code>, <code>b.txt</code>, and <code>b.bck</code>.
The command:</p>
<pre><code class="language-sh">rename .txt .bck a.txt b.txt
</code></pre>
<div class="continue">
<p>will rename <code>a.txt</code> to <code>a.bck</code>,
but will <em>not</em> rename <code>b.txt</code> because <code>b.bck</code> already exists.</p>
</div>
</main>
<footer>
<div class="row">
<div class="left3">
&nbsp;
</div>
<div class="middle3">
<a href="../license/"><img class="footer" src="../../static/cc-by.svg" alt="License" /></a>
<a href="https://github.com/software-tools-in-javascript/stjs/"><img class="footer" src="../../static/github.svg" alt="Repository" /></a>
© 2020 <a href="../authors/">The Authors</a>
</div>
<div class="right3">
<a href="../async-programming/"><em>Asynchronous Programming &raquo;</em></a>
</div>
</div>
</footer>
</body>
</html>
