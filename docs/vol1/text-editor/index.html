<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
  <title>Text Editor</title>
  <meta name="toRoot" content="..">
  <link rel="shortcut icon" type="image/x-icon" href="../../favicon.ico">
  <link href="../../static/fonts.css" rel="stylesheet" type="text/css">
  <link href="../../static/site.css" rel="stylesheet" type="text/css">
  <script>const NUMBERING = {"vol1":"1","systems-programming":"2","promises":"3","unit-test":"4","file-backup":"5","data-table":"6","pattern-matching":"7","regex-parser":"8","page-templates":"9","build-manager":"10","layout-engine":"11","text-editor":"12","file-interpolator":"13","module-loader":"14","module-bundler":"15","package-manager":"16","style-checker":"17","code-generator":"18","doc-generator":"19","virtual-machine":"20","debugger":"21","conclusion":"22","bib":"A","license":"B","conduct":"C","contributing":"D","gloss":"E","links":"F","authors":"G"}</script>
  <script src="../../static/site.js"></script>
  <script>window.onload = () => fixPage()</script>
</head>
<body id="_top">
<nav>
<div class="row">
<div class="left2">
<a href="../"><img src="../../static/logo.svg" alt="site logo" class="site-logo"/></a>
</div>
<div class="right2">
<div class="dropdown">
<span class="navtitle">▿ Sections</span>
<div class="dropdown-content" id="Sections">
</div>
</div>
<div class="dropdown">
<span class="navtitle">▿ Chapters</span>
<div class="dropdown-content" id="Chapters">
<a href="../systems-programming/"><span class="nowrap">Systems Programming</span></a>
<br/><a href="../promises/"><span class="nowrap">Promises</span></a>
<br/><a href="../unit-test/"><span class="nowrap">Unit Testing</span></a>
<br/><a href="../file-backup/"><span class="nowrap">File Backup</span></a>
<br/><a href="../data-table/"><span class="nowrap">Data Tables</span></a>
<br/><a href="../pattern-matching/"><span class="nowrap">Pattern Matching</span></a>
<br/><a href="../regex-parser/"><span class="nowrap">Parsing Expressions</span></a>
<br/><a href="../page-templates/"><span class="nowrap">Page Templates</span></a>
<br/><a href="../build-manager/"><span class="nowrap">Build Manager</span></a>
<br/><a href="../layout-engine/"><span class="nowrap">Layout Engine</span></a>
<br/><a href="../text-editor/"><span class="nowrap">Text Editor</span></a>
<br/><a href="../file-interpolator/"><span class="nowrap">File Interpolator</span></a>
<br/><a href="../module-loader/"><span class="nowrap">Module Loader</span></a>
<br/><a href="../module-bundler/"><span class="nowrap">Module Bundler</span></a>
<br/><a href="../package-manager/"><span class="nowrap">Package Manager</span></a>
<br/><a href="../style-checker/"><span class="nowrap">Style Checker</span></a>
<br/><a href="../code-generator/"><span class="nowrap">Code Generator</span></a>
<br/><a href="../doc-generator/"><span class="nowrap">Documentation Generator</span></a>
<br/><a href="../virtual-machine/"><span class="nowrap">Virtual Machine</span></a>
<br/><a href="../debugger/"><span class="nowrap">Debugger</span></a>
<br/><a href="../conclusion/"><span class="nowrap">Conclusion</span></a>
</div>
</div>
<div class="dropdown">
<span class="navtitle">▿ Appendices</span>
<div class="dropdown-content" id="Appendices">
<a href="../bib/"><span class="nowrap">Bibliography</span></a>
<br/><a href="../license/"><span class="nowrap">License</span></a>
<br/><a href="../conduct/"><span class="nowrap">Code of Conduct</span></a>
<br/><a href="../contributing/"><span class="nowrap">Contributing</span></a>
<br/><a href="../gloss/"><span class="nowrap">Glossary</span></a>
<br/><a href="../links/"><span class="nowrap">Links</span></a>
<br/><a href="../authors/"><span class="nowrap">Authors</span></a>
</div>
</div>
</div>
</div>
</nav>
  <main>
  <h1>Text Editor</h1>
  <h2 class="lede">Editing text in the terminal</h2>
<div class="callout">
  <p>Terms defined: <g key="driver">driver</g>, <g key="key_binding">key binding</g>, <g key="plugin_architecture">plugin architecture</g>, <g key="refactoring">refactoring</g>, <g key="screen_buffer">screen buffer</g>, <g key="text_buffer">text buffer</g></p>
</div>
<ul>
<li>We have been writing a lot of files---how does the editor itself work?</li>
<li>Explore by <g key="refactoring">refactoring</g> a terminal editor based on <a href="https://jotr.me/">Morten Olsrud</a>'s <a href="https://github.com/hakash/termit">Termit</a>
<ul>
<li>Uses the <a href="https://github.com/cronvel/terminal-kit">terminal-kit</a> package to manage screen interactions</li>
</ul>
</li>
<li>We will not dive into technical details, since this isn't a lesson on terminal management</li>
<li>But will see:
<ul>
<li>How to build a <g key="plugin_architecture">plugin architecture</g></li>
<li>How to implement undo and redo</li>
</ul>
</li>
</ul>
<h2 id="what-is-our-starting-point">What is our starting point?</h2>
<ul>
<li>As in <xref key="build-manager"></xref> and elsewhere, write a <g key="driver">driver</g> to load and run our experiments</li>
</ul>
<pre title="edit.js"><code class="language-js">const main = async () =&gt; {
  const editorSource = process.argv[2]
  const args = process.argv.slice(3)
  const EditorClass = (await import(editorSource)).default
  const editor = new EditorClass(args[0])
  editor.init()
}

main()
</code></pre>
<ul>
<li>Original editor is
466 lines long
<ul>
<li>Don't need to understand all of the screen operations in order to start changing it</li>
<li>But do need an overview of core concepts</li>
</ul>
</li>
<li>A <g key="screen_buffer">screen buffer</g> holds contents of a rectangular area of the screen
<ul>
<li>Each cell contains a character, foreground and background colors, etc.</li>
<li>Buffer as a whole writes directly to the terminal, or to another screen buffer</li>
</ul>
</li>
<li>A <g key="text_buffer">text buffer</g> is always backed by a screen buffer
<ul>
<li>Holds lines of text (an array of strings)</li>
<li>Provides methods for user-level text interaction</li>
</ul>
</li>
<li>Start with a basic editor that draws on the screen and exits immediately when any key is pressed
<ul>
<li>Just
166 lines long</li>
</ul>
</li>
</ul>
<pre title="base-editor.js"><code class="language-js">import terminalKit from 'terminal-kit'

const CONTROLS = [
  'X:save &amp; eXit',
  'C:exit',
  'O:Open',
  'S:Save',
  'A:save As',
  'K:cut line',
  'U:paste line'
]

const STATUS_BAR = 'Ctrl+  ' + CONTROLS.join(' / ')
const TITLE_BAR = 'Zepto'
const SHORT_DELAY = 100

export default class BaseEditor {
  constructor () {
    this.term = terminalKit.terminal
    this.statusBar = STATUS_BAR
    this.titleBar = TITLE_BAR
    this.shortDelay = SHORT_DELAY
    this.fileIsModified = false
    this.statusBarTimer = undefined

    this.screenBuffer = new terminalKit.ScreenBuffer({
      dst: this.term,
      height: this.term.height - 2,
      y: 2
    })

    this.textBuffer = new terminalKit.TextBuffer({
      dst: this.screenBuffer
    })
    this.textBuffer.setText('')
  }
...
}
</code></pre>
<ul>
<li>Constructor creates <code>this.term</code>, which connects the editor to the text terminal</li>
<li>Sets a few constants
<ul>
<li>Mostly self-explanatory</li>
<li><code>this.statusBarTime</code> used to control how long the status bar is displayed</li>
</ul>
</li>
<li>Creates the screen buffer and text buffer
<ul>
<li>Screen buffer is the height of the terminal minus two lines (for title bar at the top and status bar at the bottom)</li>
</ul>
</li>
<li>Set the text being edited to an empty string</li>
<li>Provide an <code>onKey</code> method to handle keystrokes
<ul>
<li>For now, exit on any key</li>
</ul>
</li>
</ul>
<pre title="base-editor.js"><code class="language-js">  onKey (key, matches, data) {
    this.exit() // FIXME
  }

  exit () {
    setTimeout(() =&gt; {
      this.term.grabInput(false)
      this.term.fullscreen(false)
      setTimeout(() =&gt; process.exit(0), this.shortDelay)
    }, this.shortDelay)
  }</code></pre>
<ul>
<li>Now add the basic operations
<ul>
<li>For example, saving files</li>
</ul>
</li>
</ul>
<pre title="core-operations.js"><code class="language-js">  saveFile () {
    if (!this.fileIsModified) {
      return
    }

    if (this.getText() === '') {
      return
    }

    if (this.currentFile) {
      this.save(this.currentFile)
    } else {
      this.saveAs()
    }
  }

  save (file, callback = () =&gt; {}) {
    this.disableUserInteraction = true
    try {
      fs.writeFileSync(file, this.getText())
      this.fileIsModified = false
      this.currentFile = file
      this.drawStatusBar('Saved!', this.mediumDelay)
      this.disableUserInteraction = false
      callback()
    } catch (e) {
      this.disableUserInteraction = false
      callback(e)
    }
  }

  saveAs (callback) {
    this.getFileNameFromUser('Save as: ',
      file =&gt; this.save(file, callback),
      this.currentFile)
  }</code></pre>
<ul>
<li>Other commands to move cursor, cut and paste lines, etc.</li>
<li>But <code>onKey</code> is one big switch statement</li>
</ul>
<pre title="core-operations.js"><code class="language-js">  onKey (key, matches, data) {
    if (this.disableUserInteraction &amp;&amp; key !== 'CTRL_C') {
      return
    }

    switch (key) {
      case 'CTRL_C':
        this.exit()
        break
      case 'CTRL_X':
        this.saveAndExit()
        break
      case 'CTRL_S':
        this.saveFile()
        break
...
      case 'BACKSPACE':
        this.backspace()
        break
      case 'ENTER':
        this.newLine()
        break
      default:
        if (data.isCharacter) {
          this.onCharacter(key)
        }
        break
    }
  }</code></pre>
<ul>
<li>Adding methods isn't enough to give the editor new functionality
<ul>
<li>Must also insert text into the switch statement</li>
<li>Which will be fragile</li>
</ul>
</li>
<li>And there's no obvious way to record features for playback or for undo/redo</li>
</ul>
<h2 id="how-can-we-make-the-editor-extensible">How can we make the editor extensible?</h2>
<ul>
<li>Lookup tables should be tables, not if/else or switch statements</li>
<li>Modify the editor to:
<ul>
<li>Create a table of <g key="key_binding">key bindings</g></li>
<li>Look keys up in that table to find out what to do</li>
</ul>
</li>
</ul>
<pre title="lookup-editor.js"><code class="language-js">import CoreEditor from './core-operations.js'

export default class LookupEditor extends CoreEditor {
  constructor () {
    super()
    this.bindings = this.createDefaultBindings()
  }

  onKey (key, matches, data) {
    if (this.disableUserInteraction &amp;&amp; key !== 'CTRL_C') {
      return
    }
    if (key in this.bindings) {
      this.bindings[key]()
    } else if (data.isCharacter) {
      this.onCharacter(key)
    }
  }
...
}
</code></pre>
<ul>
<li>Creating bindings is just building a table of functions</li>
</ul>
<pre title="lookup-editor.js"><code class="language-js">  createDefaultBindings () {
    return {
      BACKSPACE: () =&gt; this.backspace(),
      CTRL_A: () =&gt; this.saveAs(),
      CTRL_C: () =&gt; this.exit(),
      CTRL_K: () =&gt; this.cutLine(),
      CTRL_O: () =&gt; this.open(),
      CTRL_S: () =&gt; this.saveFile(),
      CTRL_U: () =&gt; this.pasteLine(),
      CTRL_X: () =&gt; this.saveAndExit(),
      DELETE: () =&gt; this.deleteChar(),
      DOWN: () =&gt; this.down(),
      END: () =&gt; this.endOfLine(),
      ENTER: () =&gt; this.newLine(),
      HOME: () =&gt; this.startOfLine(),
      LEFT: () =&gt; this.left(),
      PAGE_DOWN: () =&gt; this.pgDown(),
      PAGE_UP: () =&gt; this.pgUp(),
      RIGHT: () =&gt; this.right(),
      TAB: () =&gt; this.tab(),
      UP: () =&gt; this.up()
    }
  }</code></pre>
<ul>
<li>To add a new operation
<ul>
<li>Implement the method</li>
<li>Add an entry to the key bindings table in the constructor of the derived class</li>
</ul>
</li>
<li>But we can now also provide plugins</li>
<li>Load functions that take the editor and the arguments to <code>onKey</code> as input
<ul>
<li>Have to modify the default handlers to take these four arguments as well, just in case</li>
</ul>
</li>
</ul>
<pre title="plugin-editor.js"><code class="language-js">import fs from 'fs'
import yaml from 'js-yaml'

import LookupOperations from './lookup-editor.js'

const EDITOR_CONFIG = 'editor-config.yml'

export default class PluginEditor extends LookupEditor {
  constructor () {
    super()
    this.loadPlugins()
  }

  async loadPlugins () {
    if (fs.existsSync(EDITOR_CONFIG)) {
      const config = yaml.safeLoad(fs.readFileSync(EDITOR_CONFIG, 'utf-8'))
      const plugins = await Promise.all(config.map(entry =&gt; import(entry.filename)))
      config.forEach((entry, i) =&gt; {
        const key = entry.key
        const func = plugins[i].default
        this.bindings[key] = func
      })
    }
  }
...
}
</code></pre>
<ul>
<li>Notice the two-step <code>import</code> because <code>Promise.all</code> needs promises
<ul>
<li>Wille write an <code>async</code> function that combines the steps in the exercises</li>
</ul>
</li>
</ul>
<h2 id="how-can-we-record-and-play-back">How can we record and play back?</h2>
<ul>
<li>Many editors allow us to record keystrokes and play them back
<ul>
<li>And to save recorded operations for re-use, but we won't go that far</li>
</ul>
</li>
<li>Can't quite be done with a plugin
<ul>
<li>Have to intercept keystrokes and recorded them for all handlers</li>
</ul>
</li>
<li>Add two pieces of state to the editor
<ul>
<li><code>isRecording</code> tells the editor whether or not to save keystrokes</li>
<li><code>recordedOperations</code> is the most recently saved operations</li>
</ul>
</li>
<li>Modified editor
<ul>
<li>Parent class does the work of handling the keystroke</li>
</ul>
</li>
<li>Turning recording on and off
<ul>
<li>A toggle: <key>Ctrl-R</key> will turn recording on if it's off and off if it's on</li>
<li>When we turn it on, we need to clear any accumulated history (restarting)</li>
</ul>
</li>
<li>Modify constructor to create the state we need and record the two new key bindings</li>
</ul>
<pre title="replay-editor.js"><code class="language-js">  constructor () {
    super()
    this.isRecording = false
    this.recorded = []
    this.bindings.CTRL_P =
      (editor, key, matches, data) =&gt; this.playback()
    this.bindings.CTRL_R =
      (editor, key, matches, data) =&gt; this.record()
  }</code></pre>
<ul>
<li><code>onKey</code> records everything and then does whatever the keystroke would normally do</li>
</ul>
<pre title="replay-editor.js"><code class="language-js">  onKey (key, matches, data) {
    if (this.isRecording) {
      this.recorded.push([key, matches, data])
    }
    super.onKey(key, matches, data)
  }</code></pre>
<ul>
<li><code>record</code> toggles the <code>isRecording</code> flag and re-starts recording if needed
<ul>
<li>Note the <code>pop</code> so that the command that brought us here isn't recorded</li>
<li>Yes, this led to infinite recursion</li>
</ul>
</li>
</ul>
<pre title="replay-editor.js"><code class="language-js">  record () {
    if (this.isRecording) {
      this.isRecording = false
      this.recorded.pop() // to get rid of this command
    } else {
      this.isRecording = true
      this.recorded = []
    }
  }</code></pre>
<ul>
<li><code>playback</code> also turns off recording
<ul>
<li>Again, want to avoid infinite loop</li>
</ul>
</li>
<li>If any commands have been recorded, re-issue them</li>
</ul>
<pre title="replay-editor.js"><code class="language-js">  playback () {
    if (this.isRecording) {
      this.isRecording = false
      this.recorded.pop() // to get rid of this command
    }
    if (this.recorded.length &gt; 0) {
      this.recorded.forEach(op =&gt; this.onKey(...op))
    }
  }</code></pre>
<ul>
<li>Can be done with plugins
<ul>
<li>The extra state needed in the editor makes a plugin more complicated</li>
<li>Can have both plugins check for the state they need and add member variables if not present</li>
</ul>
</li>
<li>Or write plugins as classes with <code>onLoad</code> and <code>onKey</code> methods</li>
</ul>
<h2 id="how-can-we-undo-operations">How can we undo operations?</h2>
<ul>
<li>The opposite of &quot;move left&quot; is &quot;move right&quot;, so no extra information required</li>
<li>But the opposite of &quot;cut line&quot; is &quot;paste line&quot;
<ul>
<li>Need to record state for some operations but not for others</li>
</ul>
</li>
<li>Solution is one we hinted at earlier: implement each operation as a class
<ul>
<li><code>run</code> and <code>undo</code> methods (because <code>do</code> is a keyword in JavaScript)</li>
</ul>
</li>
<li>But not all operations are undoable
<ul>
<li><code>op.save</code> tells us whether the operation should be saved</li>
<li><code>op.clear</code> tells us whether the undo stack should be cleared</li>
</ul>
</li>
<li>Go all the way back to the original editor and modify the constructor</li>
</ul>
<pre title="undo-editor.js"><code class="language-js">  constructor () {
    super()
    this.bindings = this.createDefaultBindings()
    this.stack = []
  }</code></pre>
<ul>
<li>Handling a key now takes undo into account
<ul>
<li>Look up a class in the bindings table, make an instance, and run it</li>
<li>Look in that instance to see whether to save, clear, or neither</li>
</ul>
</li>
</ul>
<pre title="undo-editor.js"><code class="language-js">  onKey (key, matches, data) {
    if (this.disableUserInteraction &amp;&amp; key !== 'CTRL_C') {
      return
    }

    let op = null
    if (key in this.bindings) {
      op = new this.bindings[key](this, key, matches, data)
    } else if (data.isCharacter) {
      op = new KeyCharacter(this, key, matches, data)
    }

    if (op !== null) {
      op.run()
      if (op.save) {
        this.stack.push(op)
      } else if (op.clear) {
        this.stack = []
      }
    }
  }</code></pre>
<ul>
<li>Base class for operations
<ul>
<li>Record all the information about the keystroke</li>
<li>Set defaults for saving and clearing</li>
<li>Fail if the <code>run</code> or <code>undo</code> methods are called (must be overridden)</li>
</ul>
</li>
</ul>
<pre title="undo-editor.js"><code class="language-js">class KeyBase {
  constructor (editor, key, matches, data) {
    this.editor = editor
    this.key = key
    this.matches = matches
    this.data = data
    this.configure()
  }

  configure () {
    this.save = false
    this.clear = true
  }

  run () {
    throw new Error('run not implemented')
  }

  undo () {
    throw new Error('undo not implemented')
  }
}</code></pre>
<ul>
<li>Handle a printable character
<ul>
<li>Insert it going forward</li>
<li>Backspace to undo</li>
<li>Assumes we are back in the same place</li>
</ul>
</li>
</ul>
<pre title="undo-editor.js"><code class="language-js">class KeyCharacter extends KeyBase {
  configure () {
    this.save = true
  }

  run () {
    this.editor.onCharacter(this.key)
  }

  undo () {
    this.editor.backspace()
  }
}</code></pre>
<ul>
<li>Exiting is easier
<ul>
<li>Indicate that the operation isn't undoable</li>
</ul>
</li>
</ul>
<pre title="undo-editor.js"><code class="language-js">class KeyExit extends KeyBase {
  configure () {
    this.clear = true
  }

  run () {
    this.editor.exit()
  }
}</code></pre>
<ul>
<li>Full of bugs</li>
<li>Going up and then down doesn't restore location if we were at the end of a long line and went up to a short one
<ul>
<li>So the operation should save the XY location to return to and move the cursor there</li>
</ul>
</li>
<li>Cutting a line isn't currently undoable
<ul>
<li>Should save location and text for restoring</li>
</ul>
</li>
<li>Requires a deeper dive into the text buffer</li>
</ul>
<h2 id="exercises">Exercises</h2>
<h3 class="exercise">Understanding the editor</h3>
<ol>
<li>Where is location (0, 0) on the screen?</li>
<li>Why are the <code>setTimeout</code> calls in the base editor needed?
Why are timeouts sometimes reset?</li>
<li>What are <code>Math.min</code>, <code>Math.floor</code>, and division by 2 needed in <code>drawCursor</code>?</li>
<li>Why is <code>right</code> more complex than <code>left and </code>down<code>more complex than</code>up`?</li>
<li>How can <code>getLine</code> be made more efficient?</li>
</ol>
<h3 class="exercise">Inserting a file</h3>
<p>Add a command to insert a file at the cursor's current location.</p>
<h3 class="exercise">Using promises</h3>
<p>Replace all of the callbacks and synchronous operations in <code>BaseEditor</code> and <code>CoreEditor</code> with promises.</p>
<h3 class="exercise">Using bind</h3>
<p>The lookup table in <code>LookupEditor</code> creates functions of no arguments to call methods of no arguments.
Use <code>bind</code> instead.</p>
<h3 class="exercise">Using Promise.all</h3>
<p>Combine the <code>Promise.all</code> and <code>forEach</code> operations in <code>PluginEditor.loadPlugins</code>
into a single call to <code>Promise.all</code>.</p>
<h3 class="exercise">Loading replay and playback as plugins</h3>
<p>Modify <code>ReplayEditor</code> so that it loads the replay and playback functions as plugins.
Each of these functions should check the editor for the two pieces of state they need
and create them if they do not exist.</p>
<h3 class="exercise">Making plugins responsible for saving and clearing</h3>
<p>Instead of having plugins tell the editor to save them on the undo stack or clear the stack entirely,
modify both <code>UndoEditor</code> and the plugins so that commands save themselves or clear the stack directly.</p>
<h3 class="exercise">Showing replayable commands</h3>
<p>Add a command to show the commands currently recorded for replay in the status bar.
Regular characters should be shown as themselves,
while control characters should be shown as <code>^K</code>, <code>^U</code>, and so on.</p>
<h3 class="exercise">Undoing deletion</h3>
<p>This is a more sophisticated version of <code>deleteChar</code> that returns the character being deleted:</p>
<pre><code class="language-js">deleteChar () {
  const cx = this.textBuffer.cx
  const cy = this.textBuffer.cy
  let char = null
  if (cx === 0) {
    if (cy &gt; 0) {
      const last = this.textBuffer.buffer[cy - 1].length - 1
      char = this.textBuffer.buffer[cy - 1][last].char
    }
  } else {
    char = this.textBuffer.buffer[cy][cx - 1].char
  }

  this.textBuffer.backDelete(1)
  this.draw()
  return char
}
</code></pre>
<div class="continue">
<p>Use it to make character deletion undoable.</p>
</div>
<h3 class="exercise">Undoing cursor motion</h3>
<ol>
<li>
<p>Modify all cursor movement commands
to save the cursor's position before the move in the command object.</p>
</li>
<li>
<p>Make undo work correctly for cursor movement commands.</p>
</li>
</ol>
</main>
<footer>
<div class="row">
<div class="left3">
<a href="../layout-engine/"><em>&laquo; Layout Engine</em></a>
</div>
<div class="middle3">
<a href="../license/"><img class="footer" src="../../static/cc-by.svg" alt="License" /></a>
<a href="https://github.com/software-tools-in-javascript/stjs/"><img class="footer" src="../../static/github.svg" alt="Repository" /></a>
© 2020 <a href="../authors/">The Authors</a>
</div>
<div class="right3">
<a href="../file-interpolator/"><em>File Interpolator &raquo;</em></a>
</div>
</div>
</footer>
</body>
</html>
